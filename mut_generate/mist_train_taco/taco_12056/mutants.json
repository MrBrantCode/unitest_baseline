{
  "task_id": "taco_12056",
  "entry_point": "find_shortest_path_length",
  "mutant_count": 229,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n != 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c1 = x + y * 1j",
      "mutated_line": "c1 = x - y * 1j",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x - y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c1 = x + y * 1j",
      "mutated_line": "c1 = x * (y * 1j)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x * (y * 1j)\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "lim = 5000",
      "mutated_line": "lim = 5001",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5001\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "lim = 5000",
      "mutated_line": "lim = 4999",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 4999\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "lim = 5000",
      "mutated_line": "lim = 0",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 0\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "lim = 5000",
      "mutated_line": "lim = 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 1\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "lim = 5000",
      "mutated_line": "lim = -5000",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = -5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] / (2 * n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] / (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] + 2 * n",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] + 2 * n\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] ** (2 * n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] ** (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 1\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = -1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = -1\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 1\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 * n + 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n + 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 * n * 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n * 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 1:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == -1:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 1:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 1\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return -1\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 1\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(x, y, r1) = circles[0]",
      "mutated_line": "(x, y, r1) = circles[1]",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[1]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(x, y, r1) = circles[0]",
      "mutated_line": "(x, y, r1) = circles[-1]",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[-1]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(x, y, r1) = circles[0]",
      "mutated_line": "(x, y, r1) = circles[1]",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[1]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c1 = x + y * 1j",
      "mutated_line": "c1 = x + y / 1j",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y / 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c1 = x + y * 1j",
      "mutated_line": "c1 = x + (y + 1j)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + (y + 1j)\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c1 = x + y * 1j",
      "mutated_line": "c1 = x + y ** 1j",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y ** 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(2, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(0, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(0, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(-1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "c2 = x + y * 1j",
      "mutated_line": "c2 = x - y * 1j",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x - y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "c2 = x + y * 1j",
      "mutated_line": "c2 = x * (y * 1j)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x * (y * 1j)\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "base = c2 - c1",
      "mutated_line": "base = c2 + c1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 + c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "base = c2 - c1",
      "mutated_line": "base = c2 * c1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 * c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cp1 = c1 + rect(r1, t + a)",
      "mutated_line": "cp1 = c1 - rect(r1, t + a)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 - rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cp1 = c1 + rect(r1, t + a)",
      "mutated_line": "cp1 = c1 * rect(r1, t + a)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 * rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cp2 = c1 + rect(r1, t - a)",
      "mutated_line": "cp2 = c1 - rect(r1, t - a)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 - rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cp2 = c1 + rect(r1, t - a)",
      "mutated_line": "cp2 = c1 * rect(r1, t - a)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 * rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] * (2 / n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 / n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] * (2 + n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 + n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] * 2 ** n",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * 2 ** n\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[1] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[-1] = 0",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[-1] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[1] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 / n - 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 / n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 + n - 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 + n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 ** n - 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 ** n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 * n - 2",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 2\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 * n - 0",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 0\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 * n - 0",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 0\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 2 * n - -1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - -1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "c2 = x + y * 1j",
      "mutated_line": "c2 = x + y / 1j",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y / 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "c2 = x + y * 1j",
      "mutated_line": "c2 = x + (y + 1j)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + (y + 1j)\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "c2 = x + y * 1j",
      "mutated_line": "c2 = x + y ** 1j",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y ** 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) * (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) * (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) // (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) // (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] * (3 * n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (3 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] * (1 * n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (1 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] * (0 * n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (0 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] * (1 * n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (1 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = [lim] * (2 * n)",
      "mutated_line": "dist = [lim] * (-2 * n)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (-2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 3 * n - 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 3 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 1 * n - 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 1 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 0 * n - 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 0 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = 1 * n - 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 1 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "g_idx = 2 * n - 1",
      "mutated_line": "g_idx = -2 * n - 1",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = -2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 - 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 - 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = (((i + i % 2) * 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = (((i + i % 2) * 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 2 - 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 - 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, (i + i % 2) * 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, (i + i % 2) * 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t_s1 = cp1 - cp",
      "mutated_line": "t_s1 = cp1 + cp",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 + cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "t_s1 = cp1 - cp",
      "mutated_line": "t_s1 = cp1 * cp",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 * cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "t_s2 = cp2 - cp",
      "mutated_line": "t_s2 = cp2 + cp",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 + cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "t_s2 = cp2 - cp",
      "mutated_line": "t_s2 = cp2 * cp",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 * cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None and phase(s1 / t_s1) >= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None and phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None and phase(s2 / t_s2) <= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None and phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if phase(s1 / s2) < 0:",
      "mutated_line": "if phase(s1 / s2) <= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) <= 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if phase(s1 / s2) < 0:",
      "mutated_line": "if phase(s1 / s2) >= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) >= 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if phase(s1 / s2) < 0:",
      "mutated_line": "if phase(s1 / s2) != 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) != 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if p_s1 != s1:",
      "mutated_line": "if p_s1 == s1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 == s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if p_s2 != s2:",
      "mutated_line": "if p_s2 == s2:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 == s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "gs = goal - cp",
      "mutated_line": "gs = goal + cp",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal + cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "gs = goal - cp",
      "mutated_line": "gs = goal * cp",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal * cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "LCR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if (s1 is None and s2 is None) and (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if (s1 is None and s2 is None) and (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 + r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 + r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2) * r2 ** 2 / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2) * r2 ** 2 / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 / d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 / d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 + d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 + d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1) ** d)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1) ** d)\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cp1 = c1 + rect(r1, t + a)",
      "mutated_line": "cp1 = c1 + rect(r1, t - a)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t - a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cp1 = c1 + rect(r1, t + a)",
      "mutated_line": "cp1 = c1 + rect(r1, t * a)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t * a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cp2 = c1 + rect(r1, t - a)",
      "mutated_line": "cp2 = c1 + rect(r1, t + a)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t + a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cp2 = c1 + rect(r1, t - a)",
      "mutated_line": "cp2 = c1 + rect(r1, t * a)",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t * a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i - i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i - i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i * (i % 2) + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i * (i % 2) + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 2, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 2, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 0, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 0, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 0, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 0, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + -1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + -1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i - i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i - i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i * (i % 2) + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i * (i % 2) + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 2 + 3) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 3) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 2 + 1) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 1) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 2 + 0) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 0) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 2 + 1) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 1) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 2 + -2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + -2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 3), P[j::2], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 3), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 1), P[j::2], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 1), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 0), P[j::2], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 0), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 1), P[j::2], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 1), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, -2), P[j::2], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, -2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is not None or phase(s1 / t_s1) >= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is not None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None or phase(s1 / t_s1) > 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) > 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None or phase(s1 / t_s1) < 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) < 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None or phase(s1 / t_s1) == 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) == 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is not None or phase(s2 / t_s2) <= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is not None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None or phase(s2 / t_s2) < 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) < 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None or phase(s2 / t_s2) > 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) > 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None or phase(s2 / t_s2) == 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) == 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if phase(s1 / s2) < 0:",
      "mutated_line": "if phase(s1 / s2) < 1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 1:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if phase(s1 / s2) < 0:",
      "mutated_line": "if phase(s1 / s2) < -1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < -1:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if phase(s1 / s2) < 0:",
      "mutated_line": "if phase(s1 / s2) < 1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 1:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "LCR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if (s1 is None or s2 is None) or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if (s1 is None or s2 is None) or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "LCR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 or phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 or phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 - d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 - d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 * d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 * d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 * 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 * 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - (r2 + 2)) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - (r2 + 2)) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 / r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 / r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / ((2 + r1) * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / ((2 + r1) * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 ** r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 ** r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i * 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i * 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + (i + 2) + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + (i + 2) + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i * 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i * 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + (i + 2) + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + (i + 2) + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::3], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::3], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::1], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::1], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::0], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::0], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::1], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::1], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::-2], P[k::2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::-2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::3]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::3]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::1]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::1]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::0]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::0]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::1]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::1]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):",
      "mutated_line": "for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::-2]):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::-2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None or phase(s1 / t_s1) >= 1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 1:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None or phase(s1 / t_s1) >= -1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= -1:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None or phase(s1 / t_s1) >= 1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 1:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None or phase(s2 / t_s2) <= 1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 1:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None or phase(s2 / t_s2) <= -1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= -1:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None or phase(s2 / t_s2) <= 1:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 1:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if phase(s1 / s2) < 0:",
      "mutated_line": "if phase(s1 * s2) < 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 * s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if phase(s1 / s2) < 0:",
      "mutated_line": "if phase(s1 // s2) < 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 // s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dist[l] = min(dist[l], d + abs(s1))",
      "mutated_line": "dist[l] = min(dist[l], d - abs(s1))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d - abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "dist[l] = min(dist[l], d + abs(s1))",
      "mutated_line": "dist[l] = min(dist[l], d * abs(s1))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d * abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l - 1] = min(dist[l + 1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l - 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l * 1] = min(dist[l + 1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l * 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 1] = min(dist[l + 1], d - abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d - abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 1] = min(dist[l + 1], d * abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d * abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is not None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is not None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is not None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is not None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) > 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) > 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) < 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) < 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) == 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) == 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) < 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) < 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) > 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) > 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) == 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) == 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "dist[g_idx] = min(dist[g_idx], d + abs(gs))",
      "mutated_line": "dist[g_idx] = min(dist[g_idx], d - abs(gs))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d - abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "dist[g_idx] = min(dist[g_idx], d + abs(gs))",
      "mutated_line": "dist[g_idx] = min(dist[g_idx], d * abs(gs))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d * abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 * 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 * 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 + 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 + 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d * 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d * 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + (d + 2) - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + (d + 2) - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 3) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 3) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 1) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 1) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 0) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 0) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 1) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 1) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** -2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** -2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (3 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (3 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (1 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (1 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (0 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (0 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (1 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (1 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (-2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (-2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 3 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 3 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 1 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 1 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 0 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 0 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 1 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 1 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % -2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % -2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 3 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 3 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 1 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 1 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 0 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 0 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % 1 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 1 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))",
      "mutated_line": "indices = ((i + i % 2 + 1, i + i % -2 + 2) for i in range(g_idx))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % -2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None or phase(s1 * t_s1) >= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 * t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if s1 is None or phase(s1 / t_s1) >= 0:",
      "mutated_line": "if s1 is None or phase(s1 // t_s1) >= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 // t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None or phase(s2 * t_s2) <= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 * t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if s2 is None or phase(s2 / t_s2) <= 0:",
      "mutated_line": "if s2 is None or phase(s2 // t_s2) <= 0:",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 // t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 2] = min(dist[l + 1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 2] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 0] = min(dist[l + 1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 0] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 0] = min(dist[l + 1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 0] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + -1] = min(dist[l + 1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + -1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 1] = min(dist[l - 1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l - 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 1] = min(dist[l * 1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l * 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 1 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 1 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= -1 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= -1 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 1 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 1 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 1):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 1):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= -1):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= -1):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 1):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 1):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 3 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 3 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 1 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 1 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 0 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 0 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 1 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 1 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** -2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** -2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 3 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 3 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 1 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 1 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 0 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 0 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** 1 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 1 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))",
      "mutated_line": "a = acos((r1 ** 2 + d ** -2 - r2 ** 2) / (2 * r1 * d))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** -2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 1] = min(dist[l + 2], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 2], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 1] = min(dist[l + 0], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 0], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 1] = min(dist[l + 0], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 0], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "dist[l + 1] = min(dist[l + 1], d + abs(s2))",
      "mutated_line": "dist[l + 1] = min(dist[l + -1], d + abs(s2))",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + -1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 * gs) >= 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 * gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 // gs) >= 0 and phase(s2 / gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 // gs) >= 0 and phase(s2 / gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 * gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 * gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 / gs) <= 0):",
      "mutated_line": "if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 // gs) <= 0):",
      "code": "from math import acos\nfrom cmath import phase, rect, pi\n\ndef find_shortest_path_length(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    P = []\n    (x, y, r1) = circles[0]\n    c1 = x + y * 1j\n    P.append(c1)\n    for i in range(1, n):\n        (x, y, r2) = circles[i]\n        c2 = x + y * 1j\n        base = c2 - c1\n        d = abs(base)\n        a = acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n        t = phase(base)\n        cp1 = c1 + rect(r1, t + a)\n        cp2 = c1 + rect(r1, t - a)\n        P.append(cp1)\n        P.append(cp2)\n        (c1, r1) = (c2, r2)\n    lim = 5000\n    dist = [lim] * (2 * n)\n    dist[0] = 0\n    goal = c1\n    g_idx = 2 * n - 1\n    indices = ((i + i % 2 + 1, i + i % 2 + 2) for i in range(g_idx))\n    for (tpl_idx, cp, d) in zip(indices, P, dist):\n        (j, k) = tpl_idx\n        s1 = None\n        s2 = None\n        p_s1 = None\n        p_s2 = None\n        for (l, cp1, cp2) in zip(range(j, g_idx, 2), P[j::2], P[k::2]):\n            t_s1 = cp1 - cp\n            t_s2 = cp2 - cp\n            if s1 is None or phase(s1 / t_s1) >= 0:\n                s1 = t_s1\n            if s2 is None or phase(s2 / t_s2) <= 0:\n                s2 = t_s2\n            if phase(s1 / s2) < 0:\n                break\n            if p_s1 != s1:\n                dist[l] = min(dist[l], d + abs(s1))\n                p_s1 = s1\n            if p_s2 != s2:\n                dist[l + 1] = min(dist[l + 1], d + abs(s2))\n                p_s2 = s2\n        else:\n            gs = goal - cp\n            if s1 is None and s2 is None or (phase(s1 / gs) >= 0 and phase(s2 // gs) <= 0):\n                dist[g_idx] = min(dist[g_idx], d + abs(gs))\n    return dist[g_idx]"
    }
  ]
}