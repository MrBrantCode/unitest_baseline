{
  "task_id": "taco_853",
  "entry_point": "calculate_maximum_spanning_tree_weight",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while l1[x] != x:",
      "mutated_line": "while l1[x] == x:",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] == x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "total_weight = 0",
      "mutated_line": "for (c, (x, y)) in G:",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 1\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "total_weight = 0",
      "mutated_line": "for (c, (x, y)) in G:",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = -1\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "total_weight = 0",
      "mutated_line": "for (c, (x, y)) in G:",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 1\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if root(x) != root(y):",
      "mutated_line": "if root(x) == root(y):",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) == root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "total_weight += c",
      "mutated_line": "total_weight -= c",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight -= c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "l1 = list(range(N + 1))",
      "mutated_line": "l1 = list(range(N - 1))",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N - 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "l1 = list(range(N + 1))",
      "mutated_line": "l1 = list(range(N * 1))",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N * 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G.sort(reverse=True, key=lambda x: x[0])",
      "mutated_line": "G.sort(reverse=False, key=lambda x: x[0])",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=False, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "l1 = list(range(N + 1))",
      "mutated_line": "l1 = list(range(N + 2))",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 2))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "l1 = list(range(N + 1))",
      "mutated_line": "l1 = list(range(N + 0))",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 0))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "l1 = list(range(N + 1))",
      "mutated_line": "l1 = list(range(N + 0))",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 0))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "l1 = list(range(N + 1))",
      "mutated_line": "l1 = list(range(N + -1))",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + -1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[0])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G.sort(reverse=True, key=lambda x: x[0])",
      "mutated_line": "G.sort(reverse=True, key=lambda x: x[1])",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[1])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G.sort(reverse=True, key=lambda x: x[0])",
      "mutated_line": "G.sort(reverse=True, key=lambda x: x[-1])",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[-1])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "G.sort(reverse=True, key=lambda x: x[0])",
      "mutated_line": "G.sort(reverse=True, key=lambda x: x[1])",
      "code": "def calculate_maximum_spanning_tree_weight(test_cases):\n\n    def root(x):\n        while l1[x] != x:\n            l1[x] = l1[l1[x]]\n            x = l1[x]\n        return x\n\n    def union(x, y):\n        p = root(x)\n        q = root(y)\n        l1[p] = l1[q]\n    results = []\n    for case in test_cases:\n        (N, M, edges) = case\n        l1 = list(range(N + 1))\n        G = [(c, (a, b)) for (a, b, c) in edges]\n        G.sort(reverse=True, key=lambda x: x[1])\n        total_weight = 0\n        for (c, (x, y)) in G:\n            if root(x) != root(y):\n                total_weight += c\n                union(x, y)\n        results.append(total_weight)\n    return results"
    }
  ]
}