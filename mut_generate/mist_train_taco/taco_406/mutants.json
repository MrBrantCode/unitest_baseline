{
  "task_id": "taco_406",
  "entry_point": "minimum_moves_to_collect_treasures",
  "mutant_count": 125,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "total += min(old_a, old_b)",
      "mutated_line": "total -= min(old_a, old_b)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total -= min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "highest = 1",
      "mutated_line": "highest = 2",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 2\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "highest = 1",
      "mutated_line": "highest = 0",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 0\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "highest = 1",
      "mutated_line": "highest = 0",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 0\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "highest = 1",
      "mutated_line": "highest = -1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = -1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "total = highest - 1",
      "mutated_line": "total = highest + 1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest + 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "total = highest - 1",
      "mutated_line": "total = highest * 1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest * 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[2] = [1, 1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[2] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[0] = [1, 1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[0] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[0] = [1, 1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[0] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[-1] = [1, 1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[-1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[1] = [2, 1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [2, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[1] = [0, 1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [0, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[1] = [0, 1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [0, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[1] = [-1, 1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [-1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[1] = [1, 2]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 2]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[1] = [1, 0]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 0]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[1] = [1, 0]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 0]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vals[1] = [1, 1]",
      "mutated_line": "vals[1] = [1, -1]",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, -1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if r not in vals:",
      "mutated_line": "if r in vals:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if row == 1:",
      "mutated_line": "if row != 1:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row != 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if lower > upper:",
      "mutated_line": "if lower >= upper:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower >= upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if lower > upper:",
      "mutated_line": "if lower <= upper:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower <= upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if lower > upper:",
      "mutated_line": "if lower != upper:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower != upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if pos < len(safe_columns):",
      "mutated_line": "if pos <= len(safe_columns):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos <= len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if pos < len(safe_columns):",
      "mutated_line": "if pos >= len(safe_columns):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos >= len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if pos < len(safe_columns):",
      "mutated_line": "if pos != len(safe_columns):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos != len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 1",
      "mutated_line": "pos2 = bisect.bisect_left(safe_columns, lower) + 1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) + 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 1",
      "mutated_line": "pos2 = bisect.bisect_left(safe_columns, lower) * 1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) * 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if pos2 >= 0:",
      "mutated_line": "if pos2 > 0:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 > 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if pos2 >= 0:",
      "mutated_line": "if pos2 < 0:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 < 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if pos2 >= 0:",
      "mutated_line": "if pos2 == 0:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 == 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(old_a, old_b) = (0, 0)",
      "mutated_line": "(old_a, old_b) = (1, 0)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (1, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(old_a, old_b) = (0, 0)",
      "mutated_line": "(old_a, old_b) = (-1, 0)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (-1, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(old_a, old_b) = (0, 0)",
      "mutated_line": "(old_a, old_b) = (1, 0)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (1, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(old_a, old_b) = (0, 0)",
      "mutated_line": "(old_a, old_b) = (0, 1)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 1)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(old_a, old_b) = (0, 0)",
      "mutated_line": "(old_a, old_b) = (0, -1)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, -1)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(old_a, old_b) = (0, 0)",
      "mutated_line": "(old_a, old_b) = (0, 1)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 1)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(pos_a, pos_b) = (1, 1)",
      "mutated_line": "(pos_a, pos_b) = (2, 1)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (2, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(pos_a, pos_b) = (1, 1)",
      "mutated_line": "(pos_a, pos_b) = (0, 1)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (0, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(pos_a, pos_b) = (1, 1)",
      "mutated_line": "(pos_a, pos_b) = (0, 1)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (0, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(pos_a, pos_b) = (1, 1)",
      "mutated_line": "(pos_a, pos_b) = (-1, 1)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (-1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(pos_a, pos_b) = (1, 1)",
      "mutated_line": "(pos_a, pos_b) = (1, 2)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 2)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(pos_a, pos_b) = (1, 1)",
      "mutated_line": "(pos_a, pos_b) = (1, 0)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 0)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(pos_a, pos_b) = (1, 1)",
      "mutated_line": "(pos_a, pos_b) = (1, 0)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 0)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(pos_a, pos_b) = (1, 1)",
      "mutated_line": "(pos_a, pos_b) = (1, -1)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, -1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(2, n + 1):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(2, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(0, n + 1):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(0, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(0, n + 1):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(0, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(-1, n + 1):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(-1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(1, n - 1):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n - 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(1, n * 1):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n * 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if row not in vals:",
      "mutated_line": "if row in vals:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "mutated_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max + row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max + row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "mutated_line": "new_a = (min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max) * row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = (min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max) * row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "mutated_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max + row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max + row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "mutated_line": "new_b = (min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max) * row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = (min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max) * row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "total = highest - 1",
      "mutated_line": "total = highest - 2",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 2\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "total = highest - 1",
      "mutated_line": "total = highest - 0",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 0\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "total = highest - 1",
      "mutated_line": "total = highest - 0",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 0\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "total = highest - 1",
      "mutated_line": "total = highest - -1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - -1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if row == 1:",
      "mutated_line": "if row == 2:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 2:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if row == 1:",
      "mutated_line": "if row == 0:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 0:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if row == 1:",
      "mutated_line": "if row == 0:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 0:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if row == 1:",
      "mutated_line": "if row == -1:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == -1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return upper - 1",
      "mutated_line": "return upper + 1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper + 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return upper - 1",
      "mutated_line": "return upper * 1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper * 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if safe_columns[pos] <= upper:",
      "mutated_line": "if safe_columns[pos] < upper:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] < upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if safe_columns[pos] <= upper:",
      "mutated_line": "if safe_columns[pos] > upper:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] > upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if safe_columns[pos] <= upper:",
      "mutated_line": "if safe_columns[pos] == upper:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] == upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 1",
      "mutated_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 2",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 2\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 1",
      "mutated_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 0",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 0\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 1",
      "mutated_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 0",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 0\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "pos2 = bisect.bisect_left(safe_columns, lower) - 1",
      "mutated_line": "pos2 = bisect.bisect_left(safe_columns, lower) - -1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - -1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if pos2 >= 0:",
      "mutated_line": "if pos2 >= 1:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 1:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if pos2 >= 0:",
      "mutated_line": "if pos2 >= -1:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= -1:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if pos2 >= 0:",
      "mutated_line": "if pos2 >= 1:",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 1:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(1, n + 2):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 2):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(1, n + 0):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 0):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(1, n + 0):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 0):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for row in range(1, n + 1):",
      "mutated_line": "for row in range(1, n + -1):",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + -1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "mutated_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) - row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) - row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "mutated_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) * row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) * row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "mutated_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) - row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) - row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "mutated_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) * row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) * row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vals[r][0] = min(vals[r][0], c)",
      "mutated_line": "vals[r][1] = min(vals[r][0], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][1] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vals[r][0] = min(vals[r][0], c)",
      "mutated_line": "vals[r][-1] = min(vals[r][0], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][-1] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vals[r][0] = min(vals[r][0], c)",
      "mutated_line": "vals[r][1] = min(vals[r][0], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][1] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vals[r][1] = max(vals[r][1], c)",
      "mutated_line": "vals[r][2] = max(vals[r][1], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][2] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vals[r][1] = max(vals[r][1], c)",
      "mutated_line": "vals[r][0] = max(vals[r][1], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][0] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vals[r][1] = max(vals[r][1], c)",
      "mutated_line": "vals[r][0] = max(vals[r][1], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][0] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vals[r][1] = max(vals[r][1], c)",
      "mutated_line": "vals[r][-1] = max(vals[r][1], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][-1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return upper - 1",
      "mutated_line": "return upper - 2",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 2\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return upper - 1",
      "mutated_line": "return upper - 0",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 0\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return upper - 1",
      "mutated_line": "return upper - 0",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 0\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return upper - 1",
      "mutated_line": "return upper - -1",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - -1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return upper - lower",
      "mutated_line": "return upper + lower",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper + lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return upper - lower",
      "mutated_line": "return upper * lower",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper * lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])",
      "mutated_line": "options.append(lower - safe_columns[pos2] + upper + safe_columns[pos2])",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper + safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])",
      "mutated_line": "options.append((lower - safe_columns[pos2] + upper) * safe_columns[pos2])",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append((lower - safe_columns[pos2] + upper) * safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vals[r][0] = min(vals[r][0], c)",
      "mutated_line": "vals[r][0] = min(vals[r][1], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][1], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vals[r][0] = min(vals[r][0], c)",
      "mutated_line": "vals[r][0] = min(vals[r][-1], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][-1], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vals[r][0] = min(vals[r][0], c)",
      "mutated_line": "vals[r][0] = min(vals[r][1], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][1], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vals[r][1] = max(vals[r][1], c)",
      "mutated_line": "vals[r][1] = max(vals[r][2], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][2], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vals[r][1] = max(vals[r][1], c)",
      "mutated_line": "vals[r][1] = max(vals[r][0], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][0], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vals[r][1] = max(vals[r][1], c)",
      "mutated_line": "vals[r][1] = max(vals[r][0], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][0], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vals[r][1] = max(vals[r][1], c)",
      "mutated_line": "vals[r][1] = max(vals[r][-1], c)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][-1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)",
      "mutated_line": "options.append(safe_columns[pos] - lower + safe_columns[pos] + upper)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] + upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)",
      "mutated_line": "options.append((safe_columns[pos] - lower + safe_columns[pos]) * upper)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append((safe_columns[pos] - lower + safe_columns[pos]) * upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])",
      "mutated_line": "options.append(lower - safe_columns[pos2] - upper - safe_columns[pos2])",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] - upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])",
      "mutated_line": "options.append((lower - safe_columns[pos2]) * upper - safe_columns[pos2])",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append((lower - safe_columns[pos2]) * upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "mutated_line": "new_a = min(old_a - find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a - find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "mutated_line": "new_a = min(old_a * find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a * find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "mutated_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b - find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b - find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "mutated_line": "new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b * find_shortest(pos_b, row_max, row)) + row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b * find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "mutated_line": "new_b = min(old_a - find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a - find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "mutated_line": "new_b = min(old_a * find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a * find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "mutated_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b - find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b - find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "mutated_line": "new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b * find_shortest(pos_b, row_min, row)) + row_max - row_min",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b * find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)",
      "mutated_line": "options.append(safe_columns[pos] - lower - safe_columns[pos] - upper)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower - safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)",
      "mutated_line": "options.append((safe_columns[pos] - lower) * safe_columns[pos] - upper)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append((safe_columns[pos] - lower) * safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])",
      "mutated_line": "options.append(lower + safe_columns[pos2] + upper - safe_columns[pos2])",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower + safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])",
      "mutated_line": "options.append(lower * safe_columns[pos2] + upper - safe_columns[pos2])",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower * safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)",
      "mutated_line": "options.append(safe_columns[pos] + lower + safe_columns[pos] - upper)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] + lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "options.append(safe_columns[pos] - lower + safe_columns[pos] - upper)",
      "mutated_line": "options.append(safe_columns[pos] * lower + safe_columns[pos] - upper)",
      "code": "import bisect\n\ndef minimum_moves_to_collect_treasures(n, m, k, q, treasures, safe_columns):\n    vals = {}\n    vals[1] = [1, 1]\n    for (r, c) in treasures:\n        if r not in vals:\n            vals[r] = [c, c]\n        else:\n            vals[r][0] = min(vals[r][0], c)\n            vals[r][1] = max(vals[r][1], c)\n    safe_columns.sort()\n\n    def find_shortest(lower, upper, row):\n        if row == 1:\n            return upper - 1\n        if lower > upper:\n            return find_shortest(upper, lower, row)\n        pos = bisect.bisect_left(safe_columns, lower)\n        options = []\n        if pos < len(safe_columns):\n            if safe_columns[pos] <= upper:\n                return upper - lower\n            else:\n                options.append(safe_columns[pos] * lower + safe_columns[pos] - upper)\n        pos2 = bisect.bisect_left(safe_columns, lower) - 1\n        if pos2 >= 0:\n            options.append(lower - safe_columns[pos2] + upper - safe_columns[pos2])\n        return min(options)\n    highest = 1\n    (old_a, old_b) = (0, 0)\n    (pos_a, pos_b) = (1, 1)\n    for row in range(1, n + 1):\n        if row not in vals:\n            continue\n        highest = row\n        (row_min, row_max) = vals[row]\n        new_a = min(old_a + find_shortest(pos_a, row_max, row), old_b + find_shortest(pos_b, row_max, row)) + row_max - row_min\n        new_b = min(old_a + find_shortest(pos_a, row_min, row), old_b + find_shortest(pos_b, row_min, row)) + row_max - row_min\n        (old_a, old_b) = (new_a, new_b)\n        (pos_a, pos_b) = (row_min, row_max)\n    total = highest - 1\n    total += min(old_a, old_b)\n    return total"
    }
  ]
}