{
  "task_id": "taco_8780",
  "entry_point": "bezier_curve_operations",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if curve_type == 'linear':",
      "mutated_line": "if curve_type != 'linear':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type != 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if operation == 'point_at':",
      "mutated_line": "if operation != 'point_at':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation != 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if curve_type == 'linear':",
      "mutated_line": "if curve_type == '':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == '':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(control_points) != 4:",
      "mutated_line": "if len(control_points) == 4:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) == 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif curve_type == 'quadratic':",
      "mutated_line": "elif curve_type != 'quadratic':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type != 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if operation == 'point_at':",
      "mutated_line": "if operation == '':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == '':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "elif operation == 'sub_segment':",
      "mutated_line": "elif operation != 'sub_segment':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation != 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(control_points) != 4:",
      "mutated_line": "if len(control_points) != 5:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 5:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(control_points) != 4:",
      "mutated_line": "if len(control_points) != 3:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 3:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(control_points) != 4:",
      "mutated_line": "if len(control_points) != 0:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 0:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(control_points) != 4:",
      "mutated_line": "if len(control_points) != 1:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 1:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(control_points) != 4:",
      "mutated_line": "if len(control_points) != -4:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != -4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif curve_type == 'quadratic':",
      "mutated_line": "elif curve_type == '':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == '':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if len(control_points) != 6:",
      "mutated_line": "if len(control_points) == 6:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) == 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif curve_type == 'cubic':",
      "mutated_line": "elif curve_type != 'cubic':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type != 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "elif operation == 'sub_segment':",
      "mutated_line": "elif operation == '':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == '':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v - (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v - (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v * ((p[i + 2] - v) * t) for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v * ((p[i + 2] - v) * t) for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "raise ValueError(\"Linear curve requires exactly 4 control points.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(control_points) != 6:",
      "mutated_line": "if len(control_points) != 7:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 7:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(control_points) != 6:",
      "mutated_line": "if len(control_points) != 5:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 5:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(control_points) != 6:",
      "mutated_line": "if len(control_points) != 0:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 0:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(control_points) != 6:",
      "mutated_line": "if len(control_points) != 1:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 1:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if len(control_points) != 6:",
      "mutated_line": "if len(control_points) != -6:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != -6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif curve_type == 'cubic':",
      "mutated_line": "elif curve_type == '':",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == '':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if len(control_points) != 8:",
      "mutated_line": "if len(control_points) == 8:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) == 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError('')"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v) / t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) / t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v + t) for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v + t) for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v) ** t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) ** t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "return tuple(control_points_at(p, t)[-2:])",
      "mutated_line": "return tuple(control_points_at(p, t)[+2:])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[+2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "raise ValueError(\"Quadratic curve requires exactly 6 control points.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(control_points) != 8:",
      "mutated_line": "if len(control_points) != 9:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 9:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(control_points) != 8:",
      "mutated_line": "if len(control_points) != 7:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 7:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(control_points) != 8:",
      "mutated_line": "if len(control_points) != 0:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 0:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(control_points) != 8:",
      "mutated_line": "if len(control_points) != 1:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 1:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if len(control_points) != 8:",
      "mutated_line": "if len(control_points) != -8:",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != -8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError('')\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result.extend(p[:2])",
      "mutated_line": "result.extend(p[:3])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:3])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result.extend(p[:2])",
      "mutated_line": "result.extend(p[:1])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:1])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result.extend(p[:2])",
      "mutated_line": "result.extend(p[:0])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:0])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result.extend(p[:2])",
      "mutated_line": "result.extend(p[:1])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:1])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result.extend(p[:2])",
      "mutated_line": "result.extend(p[:-2])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:-2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] + v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] + v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + p[i + 2] * v * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + p[i + 2] * v * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return tuple(control_points_at(p, t)[-2:])",
      "mutated_line": "return tuple(control_points_at(p, t)[-3:])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-3:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return tuple(control_points_at(p, t)[-2:])",
      "mutated_line": "return tuple(control_points_at(p, t)[-1:])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-1:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return tuple(control_points_at(p, t)[-2:])",
      "mutated_line": "return tuple(control_points_at(p, t)[-0:])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-0:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return tuple(control_points_at(p, t)[-2:])",
      "mutated_line": "return tuple(control_points_at(p, t)[-1:])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-1:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return tuple(control_points_at(p, t)[-2:])",
      "mutated_line": "return tuple(control_points_at(p, t)[--2:])",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[--2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "raise ValueError(\"Cubic curve requires exactly 8 control points.\")",
      "mutated_line": "raise ValueError('')",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i - 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i - 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i * 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i * 2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:+2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:+2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 3] - v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 3] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 1] - v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 1] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 0] - v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 0] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 1] - v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 1] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + -2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + -2] - v) * t for (i, v) in enumerate(p[:-2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-3])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-3])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-1])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-1])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-0])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-0])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-1])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-1])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:-2])]",
      "mutated_line": "p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:--2])]",
      "code": "def bezier_curve_operations(curve_type, control_points, operation, t):\n\n    def control_points_at(p, t):\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i + 2] - v) * t for (i, v) in enumerate(p[:--2])]\n        return result\n\n    def point_at(p, t):\n        return tuple(control_points_at(p, t)[-2:])\n\n    def sub_segment(p, t):\n        return control_points_at(p, t)\n    if curve_type == 'linear':\n        if len(control_points) != 4:\n            raise ValueError('Linear curve requires exactly 4 control points.')\n    elif curve_type == 'quadratic':\n        if len(control_points) != 6:\n            raise ValueError('Quadratic curve requires exactly 6 control points.')\n    elif curve_type == 'cubic':\n        if len(control_points) != 8:\n            raise ValueError('Cubic curve requires exactly 8 control points.')\n    else:\n        raise ValueError(\"Invalid curve type. Supported types are 'linear', 'quadratic', and 'cubic'.\")\n    if operation == 'point_at':\n        return point_at(control_points, t)\n    elif operation == 'sub_segment':\n        return sub_segment(control_points, t)\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'point_at' and 'sub_segment'.\")"
    }
  ]
}