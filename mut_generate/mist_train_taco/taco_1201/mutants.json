{
  "task_id": "taco_1201",
  "entry_point": "calculate_max_sweetness",
  "mutant_count": 102,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if K > nn:",
      "mutated_line": "if K >= nn:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K >= nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if K > nn:",
      "mutated_line": "if K <= nn:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K <= nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if K > nn:",
      "mutated_line": "if K != nn:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K != nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = 64",
      "mutated_line": "b = 65",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 65\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = 64",
      "mutated_line": "b = 63",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 63\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = 64",
      "mutated_line": "b = 0",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 0\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = 64",
      "mutated_line": "b = 1",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 1\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = 64",
      "mutated_line": "b = -64",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = -64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bm = 0",
      "mutated_line": "bm = 1",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 1\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bm = 0",
      "mutated_line": "bm = -1",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = -1\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bm = 0",
      "mutated_line": "bm = 1",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 1\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while b > -1:",
      "mutated_line": "while b >= -1:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b >= -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while b > -1:",
      "mutated_line": "while b <= -1:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b <= -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while b > -1:",
      "mutated_line": "while b != -1:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b != -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b += 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, nn):",
      "mutated_line": "for i in range(2, nn):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(2, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, nn):",
      "mutated_line": "for i in range(0, nn):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(0, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, nn):",
      "mutated_line": "for i in range(0, nn):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(0, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, nn):",
      "mutated_line": "for i in range(-1, nn):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(-1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[False] * K for __ in range(nn)]",
      "mutated_line": "dp = [[False] / K for __ in range(nn)]",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] / K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[False] * K for __ in range(nn)]",
      "mutated_line": "dp = [[False] + K for __ in range(nn)]",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] + K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp = [[False] * K for __ in range(nn)]",
      "mutated_line": "dp = [[False] ** K for __ in range(nn)]",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] ** K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "while b > -1:",
      "mutated_line": "while b > +1:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > +1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "bm = bm | 1 << b",
      "mutated_line": "bm = bm & 1 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm & 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "bm = bm | 1 << b",
      "mutated_line": "bm = bm ^ 1 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm ^ 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "bm -= 1 << b",
      "mutated_line": "bm += 1 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm += 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 2\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 0\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 0\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= -1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(1)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(-1)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(1)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p_sum = [slices[0]]",
      "mutated_line": "p_sum = [slices[1]]",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[1]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p_sum = [slices[0]]",
      "mutated_line": "p_sum = [slices[-1]]",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[-1]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p_sum = [slices[0]]",
      "mutated_line": "p_sum = [slices[1]]",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[1]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "p_sum.append(slices[i] + p_sum[-1])",
      "mutated_line": "p_sum.append(slices[i] - p_sum[-1])",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] - p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "p_sum.append(slices[i] + p_sum[-1])",
      "mutated_line": "p_sum.append(slices[i] * p_sum[-1])",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] * p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while b > -1:",
      "mutated_line": "while b > -2:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -2:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while b > -1:",
      "mutated_line": "while b > -0:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -0:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while b > -1:",
      "mutated_line": "while b > -0:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -0:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while b > -1:",
      "mutated_line": "while b > --1:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > --1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "dp[cn][0] = p_sum[cn] & bm == bm",
      "mutated_line": "dp[cn][0] = p_sum[cn] & bm != bm",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm != bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp = [[False] * K for __ in range(nn)]",
      "mutated_line": "dp = [[True] * K for __ in range(nn)]",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[True] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bm = bm | 1 << b",
      "mutated_line": "bm = bm | 2 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 2 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bm = bm | 1 << b",
      "mutated_line": "bm = bm | 0 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 0 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bm = bm | 1 << b",
      "mutated_line": "bm = bm | 0 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 0 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "bm = bm | 1 << b",
      "mutated_line": "bm = bm | -1 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | -1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[cn][0] = p_sum[cn] & bm == bm",
      "mutated_line": "dp[cn][1] = p_sum[cn] & bm == bm",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][1] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[cn][0] = p_sum[cn] & bm == bm",
      "mutated_line": "dp[cn][-1] = p_sum[cn] & bm == bm",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][-1] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[cn][0] = p_sum[cn] & bm == bm",
      "mutated_line": "dp[cn][1] = p_sum[cn] & bm == bm",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][1] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[cn][0] = p_sum[cn] & bm == bm",
      "mutated_line": "dp[cn][0] = p_sum[cn] | bm == bm",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] | bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ck in range(1, K):",
      "mutated_line": "for ck in range(2, K):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(2, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ck in range(1, K):",
      "mutated_line": "for ck in range(0, K):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(0, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ck in range(1, K):",
      "mutated_line": "for ck in range(0, K):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(0, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for ck in range(1, K):",
      "mutated_line": "for ck in range(-1, K):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(-1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp[cn][ck] = False",
      "mutated_line": "dp[cn][ck] = True",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = True\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for ck in range(1, K):",
      "mutated_line": "for ck in range(2, K):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(2, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for ck in range(1, K):",
      "mutated_line": "for ck in range(0, K):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(0, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for ck in range(1, K):",
      "mutated_line": "for ck in range(0, K):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(0, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for ck in range(1, K):",
      "mutated_line": "for ck in range(-1, K):",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(-1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[-1][+1]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][+1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "bm -= 1 << b",
      "mutated_line": "bm -= 2 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 2 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "bm -= 1 << b",
      "mutated_line": "bm -= 0 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 0 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "bm -= 1 << b",
      "mutated_line": "bm -= 0 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 0 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "bm -= 1 << b",
      "mutated_line": "bm -= -1 << b",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= -1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] / x[1], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] / x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] + x[1], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] + x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] ** x[1], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] ** x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "p_sum.append(slices[i] + p_sum[-1])",
      "mutated_line": "p_sum.append(slices[i] + p_sum[+1])",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[+1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] and (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] and (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[+1][-1]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[+1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[-1][-2]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-2]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[-1][-0]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-0]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[-1][-0]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-0]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[-1][--1]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][--1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p_sum.append(slices[i] + p_sum[-1])",
      "mutated_line": "p_sum.append(slices[i] + p_sum[-2])",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-2])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p_sum.append(slices[i] + p_sum[-1])",
      "mutated_line": "p_sum.append(slices[i] + p_sum[-0])",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-0])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p_sum.append(slices[i] + p_sum[-1])",
      "mutated_line": "p_sum.append(slices[i] + p_sum[-0])",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-0])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p_sum.append(slices[i] + p_sum[-1])",
      "mutated_line": "p_sum.append(slices[i] + p_sum[--1])",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[--1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] or p_sum[cn] - p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] or p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[-2][-1]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-2][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[-0][-1]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-0][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[-0][-1]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-0][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if not dp[-1][-1]:",
      "mutated_line": "if not dp[--1][-1]:",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[--1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[1] * x[1], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[1] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[-1] * x[1], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[-1] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[1] * x[1], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[1] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[2], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[2], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[0], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[0], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[0], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[0], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))",
      "mutated_line": "slices = list(filter(lambda x: x, map(lambda x: x[0] * x[-1], zip(A, toppings))))",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[-1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm != bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm != bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck + 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck + 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck * 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck * 1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] | bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] | bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 2] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 2] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 0] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 0] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 0] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 0] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - -1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - -1] and p_sum[cn] - p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] + p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] + p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] - p_sum[pn] & bm == bm)",
      "mutated_line": "dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] * p_sum[pn] & bm == bm)",
      "code": "def calculate_max_sweetness(N, A, Q, queries):\n    results = []\n    for query in queries:\n        (K, toppings) = query\n        slices = list(filter(lambda x: x, map(lambda x: x[0] * x[1], zip(A, toppings))))\n        nn = len(slices)\n        if K > nn:\n            results.append(0)\n            continue\n        b = 64\n        bm = 0\n        p_sum = [slices[0]]\n        for i in range(1, nn):\n            p_sum.append(slices[i] + p_sum[-1])\n        dp = [[False] * K for __ in range(nn)]\n        while b > -1:\n            bm = bm | 1 << b\n            for cn in range(nn):\n                dp[cn][0] = p_sum[cn] & bm == bm\n                for ck in range(1, K):\n                    dp[cn][ck] = False\n            for cn in range(nn):\n                for ck in range(1, K):\n                    for pn in range(cn):\n                        dp[cn][ck] = dp[cn][ck] or (dp[pn][ck - 1] and p_sum[cn] * p_sum[pn] & bm == bm)\n            if not dp[-1][-1]:\n                bm -= 1 << b\n            b -= 1\n        results.append(bm)\n    return results"
    }
  ]
}