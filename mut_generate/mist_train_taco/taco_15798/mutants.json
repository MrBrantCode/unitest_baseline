{
  "task_id": "taco_15798",
  "entry_point": "calculate_minimum_time",
  "mutant_count": 157,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 1\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "time = 0",
      "mutated_line": "time = -1",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = -1\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 1\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v <= time_to_d else time_to_d * a) < w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) < w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v <= time_to_d else time_to_d * a) > w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) > w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v <= time_to_d else time_to_d * a) == w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) == w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) * a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) * a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) // a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) // a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (v1 - v0) / a",
      "mutated_line": "return (v1 - v0) * a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) * a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (v1 - v0) / a",
      "mutated_line": "return (v1 - v0) // a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) // a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return d / v",
      "mutated_line": "return d * v",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d * v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return d / v",
      "mutated_line": "return d // v",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d // v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t - a / 2 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t - a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t * (a / 2 * t ** 2)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t * (a / 2 * t ** 2)\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time_to_d = time_distance(0, a, d)",
      "mutated_line": "time_to_d = time_distance(1, a, d)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(1, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time_to_d = time_distance(0, a, d)",
      "mutated_line": "time_to_d = time_distance(-1, a, d)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(-1, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "time_to_d = time_distance(0, a, d)",
      "mutated_line": "time_to_d = time_distance(1, a, d)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(1, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time_to_v = time_accelerating(0, v, a)",
      "mutated_line": "time_to_v = time_accelerating(1, v, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(1, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time_to_v = time_accelerating(0, v, a)",
      "mutated_line": "time_to_v = time_accelerating(-1, v, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(-1, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "time_to_v = time_accelerating(0, v, a)",
      "mutated_line": "time_to_v = time_accelerating(1, v, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(1, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if acceleration_distance >= l:",
      "mutated_line": "if acceleration_distance > l:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance > l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if acceleration_distance >= l:",
      "mutated_line": "if acceleration_distance < l:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance < l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if acceleration_distance >= l:",
      "mutated_line": "if acceleration_distance == l:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance == l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "time += time_speed(v, l - acceleration_distance)",
      "mutated_line": "time -= time_speed(v, l - acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time -= time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if time_to_v <= time_to_d:",
      "mutated_line": "if time_to_v < time_to_d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v < time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if time_to_v <= time_to_d:",
      "mutated_line": "if time_to_v > time_to_d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v > time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if time_to_v <= time_to_d:",
      "mutated_line": "if time_to_v == time_to_d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v == time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v > time_to_d and acceleration_distance + deceleration_distance > d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d and acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "time += time_speed(v, d - deceleration_distance - acceleration_distance)",
      "mutated_line": "time -= time_speed(v, d - deceleration_distance - acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time -= time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "time += deceleration_time",
      "mutated_line": "time -= deceleration_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time -= deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if acceleration_distance >= l - d:",
      "mutated_line": "if acceleration_distance > l - d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance > l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if acceleration_distance >= l - d:",
      "mutated_line": "if acceleration_distance < l - d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance < l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if acceleration_distance >= l - d:",
      "mutated_line": "if acceleration_distance == l - d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance == l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "time += time_distance(w, a, l - d)",
      "mutated_line": "time -= time_distance(w, a, l - d)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time -= time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "time += acceleration_time",
      "mutated_line": "time -= acceleration_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time -= acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "time += time_speed(v, l - (d + acceleration_distance))",
      "mutated_line": "time -= time_speed(v, l - (d + acceleration_distance))",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time -= time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return round(time, 5)",
      "mutated_line": "return round(time, 6)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 6)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return round(time, 5)",
      "mutated_line": "return round(time, 4)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 4)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return round(time, 5)",
      "mutated_line": "return round(time, 0)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return round(time, 5)",
      "mutated_line": "return round(time, 1)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return round(time, 5)",
      "mutated_line": "return round(time, -5)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, -5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 - (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 - (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return -v0 * (v0 ** 2 + 2 * a * d) ** 0.5 / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return -v0 * (v0 ** 2 + 2 * a * d) ** 0.5 / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (v1 - v0) / a",
      "mutated_line": "return (v1 + v0) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 + v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (v1 - v0) / a",
      "mutated_line": "return v1 * v0 / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return v1 * v0 / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 / t + a / 2 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 / t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 + t + a / 2 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 + t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 ** t + a / 2 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 ** t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 2 / t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 / t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + (a / 2 + t ** 2)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + (a / 2 + t ** 2)\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + (a / 2) ** t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + (a / 2) ** t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v < time_to_d else time_to_d * a) <= w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v < time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v > time_to_d else time_to_d * a) <= w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v > time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v == time_to_d else time_to_d * a) <= w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v == time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v <= time_to_d else time_to_d / a) <= w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d / a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v <= time_to_d else time_to_d + a) <= w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d + a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if (v if time_to_v <= time_to_d else time_to_d * a) <= w:",
      "mutated_line": "if (v if time_to_v <= time_to_d else time_to_d ** a) <= w:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d ** a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(1, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(-1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(-1, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(1, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v >= time_to_d or acceleration_distance + deceleration_distance > d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v >= time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v <= time_to_d or acceleration_distance + deceleration_distance > d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v <= time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v != time_to_d or acceleration_distance + deceleration_distance > d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v != time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance >= d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance >= d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance <= d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance <= d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance != d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance != d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "remaining_distance = d - acceleration_distance",
      "mutated_line": "remaining_distance = d + acceleration_distance",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d + acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "remaining_distance = d - acceleration_distance",
      "mutated_line": "remaining_distance = d * acceleration_distance",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d * acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time - 2 * delta_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time - 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time * (2 * delta_time)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time * (2 * delta_time)\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if acceleration_distance >= l - d:",
      "mutated_line": "if acceleration_distance >= l + d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l + d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if acceleration_distance >= l - d:",
      "mutated_line": "if acceleration_distance >= l * d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l * d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (+v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (+v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d) * 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) * 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d + 0.5)) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d + 0.5)) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a * 2 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a * 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a // 2 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a // 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 2 * (t * 2)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * (t * 2)\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 2 * (t + 2)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * (t + 2)\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "time = time_distance(0, a, l)",
      "mutated_line": "time = time_distance(1, a, l)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(1, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "time = time_distance(0, a, l)",
      "mutated_line": "time = time_distance(-1, a, l)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(-1, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "time = time_distance(0, a, l)",
      "mutated_line": "time = time_distance(1, a, l)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(1, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "time += time_speed(v, l - acceleration_distance)",
      "mutated_line": "time += time_speed(v, l + acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l + acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "time += time_speed(v, l - acceleration_distance)",
      "mutated_line": "time += time_speed(v, l * acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l * acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(1, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(-1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(-1, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(1, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "deceleration_time = time_accelerating(v, w, -a)",
      "mutated_line": "deceleration_time = time_accelerating(v, w, +a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, +a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "deceleration_distance = distance_travelled(v, deceleration_time, -a)",
      "mutated_line": "deceleration_distance = distance_travelled(v, deceleration_time, +a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, +a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v > time_to_d or acceleration_distance - deceleration_distance > d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance - deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:",
      "mutated_line": "if time_to_v > time_to_d or acceleration_distance * deceleration_distance > d:",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance * deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "acceleration_time = time_accelerating(0, w, a)",
      "mutated_line": "acceleration_time = time_accelerating(1, w, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(1, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "acceleration_time = time_accelerating(0, w, a)",
      "mutated_line": "acceleration_time = time_accelerating(-1, w, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(-1, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "acceleration_time = time_accelerating(0, w, a)",
      "mutated_line": "acceleration_time = time_accelerating(1, w, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(1, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(1, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(-1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(-1, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "acceleration_distance = distance_travelled(0, acceleration_time, a)",
      "mutated_line": "acceleration_distance = distance_travelled(1, acceleration_time, a)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(1, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "delta_time = time_distance(w, a, remaining_distance / 2)",
      "mutated_line": "delta_time = time_distance(w, a, remaining_distance * 2)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance * 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "delta_time = time_distance(w, a, remaining_distance / 2)",
      "mutated_line": "delta_time = time_distance(w, a, remaining_distance // 2)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance // 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time + 2 / delta_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 / delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time + (2 + delta_time)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + (2 + delta_time)\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time + 2 ** delta_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 ** delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "time += time_speed(v, d - deceleration_distance - acceleration_distance)",
      "mutated_line": "time += time_speed(v, d - deceleration_distance + acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance + acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "time += time_speed(v, d - deceleration_distance - acceleration_distance)",
      "mutated_line": "time += time_speed(v, (d - deceleration_distance) * acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, (d - deceleration_distance) * acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "time += time_distance(w, a, l - d)",
      "mutated_line": "time += time_distance(w, a, l + d)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l + d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "time += time_distance(w, a, l - d)",
      "mutated_line": "time += time_distance(w, a, l * d)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l * d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "time += time_speed(v, l - (d + acceleration_distance))",
      "mutated_line": "time += time_speed(v, l + (d + acceleration_distance))",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l + (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "time += time_speed(v, l - (d + acceleration_distance))",
      "mutated_line": "time += time_speed(v, l * (d + acceleration_distance))",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l * (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 - 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 - 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 * (2 * a * d)) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 * (2 * a * d)) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 1.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 1.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** -0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** -0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 1) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 1) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** -0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** -0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 3 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 3 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 1 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 1 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 0 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 0 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 1 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 1 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / -2 * t ** 2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / -2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 2 * t ** 3",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 3\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 2 * t ** 1",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 1\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 2 * t ** 0",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 0\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 2 * t ** 1",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 1\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return v0 * t + a / 2 * t ** 2",
      "mutated_line": "return v0 * t + a / 2 * t ** -2",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** -2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "delta_time = time_distance(w, a, remaining_distance / 2)",
      "mutated_line": "delta_time = time_distance(w, a, remaining_distance / 3)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 3)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "delta_time = time_distance(w, a, remaining_distance / 2)",
      "mutated_line": "delta_time = time_distance(w, a, remaining_distance / 1)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 1)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "delta_time = time_distance(w, a, remaining_distance / 2)",
      "mutated_line": "delta_time = time_distance(w, a, remaining_distance / 0)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 0)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "delta_time = time_distance(w, a, remaining_distance / 2)",
      "mutated_line": "delta_time = time_distance(w, a, remaining_distance / 1)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 1)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "delta_time = time_distance(w, a, remaining_distance / 2)",
      "mutated_line": "delta_time = time_distance(w, a, remaining_distance / -2)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / -2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time + 3 * delta_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 3 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time + 1 * delta_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 1 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time + 0 * delta_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 0 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time + 1 * delta_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 1 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "time = acceleration_time + 2 * delta_time",
      "mutated_line": "time = acceleration_time + -2 * delta_time",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + -2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "time += time_speed(v, d - deceleration_distance - acceleration_distance)",
      "mutated_line": "time += time_speed(v, d + deceleration_distance - acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d + deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "time += time_speed(v, d - deceleration_distance - acceleration_distance)",
      "mutated_line": "time += time_speed(v, d * deceleration_distance - acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d * deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "time += time_speed(v, l - (d + acceleration_distance))",
      "mutated_line": "time += time_speed(v, l - (d - acceleration_distance))",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d - acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "time += time_speed(v, l - (d + acceleration_distance))",
      "mutated_line": "time += time_speed(v, l - d * acceleration_distance)",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - d * acceleration_distance)\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 * 2 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 * 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 + 2 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 + 2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 * a / d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 * a / d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + (2 * a + d)) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + (2 * a + d)) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + (2 * a) ** d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + (2 * a) ** d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 3 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 3 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 1 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 1 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 0 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 0 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 1 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 1 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** -2 + 2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** -2 + 2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 / a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 / a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + (2 + a) * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + (2 + a) * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 2 ** a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 2 ** a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 3 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 3 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 1 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 1 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 0 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 0 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + 1 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + 1 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (-v0 + (v0 ** 2 + 2 * a * d) ** 0.5) / a",
      "mutated_line": "return (-v0 + (v0 ** 2 + -2 * a * d) ** 0.5) / a",
      "code": "def calculate_minimum_time(a, v, l, d, w):\n\n    def time_distance(v0, a, d):\n        return (-v0 + (v0 ** 2 + -2 * a * d) ** 0.5) / a\n\n    def time_accelerating(v0, v1, a):\n        return (v1 - v0) / a\n\n    def time_speed(v, d):\n        return d / v\n\n    def distance_travelled(v0, t, a):\n        return v0 * t + a / 2 * t ** 2\n    time = 0\n    time_to_d = time_distance(0, a, d)\n    time_to_v = time_accelerating(0, v, a)\n    if (v if time_to_v <= time_to_d else time_to_d * a) <= w:\n        acceleration_time = time_to_v\n        acceleration_distance = distance_travelled(0, acceleration_time, a)\n        if acceleration_distance >= l:\n            time = time_distance(0, a, l)\n        else:\n            time = acceleration_time\n            time += time_speed(v, l - acceleration_distance)\n    else:\n        if time_to_v <= time_to_d:\n            acceleration_time = time_to_v\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            deceleration_time = time_accelerating(v, w, -a)\n            deceleration_distance = distance_travelled(v, deceleration_time, -a)\n        if time_to_v > time_to_d or acceleration_distance + deceleration_distance > d:\n            acceleration_time = time_accelerating(0, w, a)\n            acceleration_distance = distance_travelled(0, acceleration_time, a)\n            remaining_distance = d - acceleration_distance\n            delta_time = time_distance(w, a, remaining_distance / 2)\n            time = acceleration_time + 2 * delta_time\n        else:\n            time = time_to_v\n            time += time_speed(v, d - deceleration_distance - acceleration_distance)\n            time += deceleration_time\n        acceleration_time = time_accelerating(w, v, a)\n        acceleration_distance = distance_travelled(w, acceleration_time, a)\n        if acceleration_distance >= l - d:\n            time += time_distance(w, a, l - d)\n        else:\n            time += acceleration_time\n            time += time_speed(v, l - (d + acceleration_distance))\n    return round(time, 5)"
    }
  ]
}