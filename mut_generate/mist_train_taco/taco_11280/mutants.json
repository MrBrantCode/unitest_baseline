{
  "task_id": "taco_11280",
  "entry_point": "calculate_minimum_steps",
  "mutant_count": 166,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] / (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] / (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] + (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] + (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] ** (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] ** (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] / (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] / (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] + (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] + (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] ** (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] ** (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 5 - 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 - 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 5 * 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 * 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 5 - 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 - 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 5 * 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 * 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [0]",
      "mutated_line": "res = [1]",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [1]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [0]",
      "mutated_line": "res = [-1]",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [-1]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "res = [0]",
      "mutated_line": "res = [1]",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [1]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] != 1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] != 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] != 1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] != 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] != 1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] != 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] != 1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] != 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if cn != 1:",
      "mutated_line": "if cn == 1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn == 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] -= 2 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] -= 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis_a[i] = 1",
      "mutated_line": "vis_a[i] = 2",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 2\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis_a[i] = 1",
      "mutated_line": "vis_a[i] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 0\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis_a[i] = 1",
      "mutated_line": "vis_a[i] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 0\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis_a[i] = 1",
      "mutated_line": "vis_a[i] = -1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = -1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "vis_b[i] = 1",
      "mutated_line": "vis_b[i] = 2",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 2\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "vis_b[i] = 1",
      "mutated_line": "vis_b[i] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 0\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "vis_b[i] = 1",
      "mutated_line": "vis_b[i] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 0\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "vis_b[i] = 1",
      "mutated_line": "vis_b[i] = -1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = -1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dfs(1, 1, d)",
      "mutated_line": "dfs(2, 1, d)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(2, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dfs(1, 1, d)",
      "mutated_line": "dfs(0, 1, d)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(0, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dfs(1, 1, d)",
      "mutated_line": "dfs(0, 1, d)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(0, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dfs(1, 1, d)",
      "mutated_line": "dfs(-1, 1, d)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(-1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dfs(1, 1, d)",
      "mutated_line": "dfs(1, 2, d)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 2, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dfs(1, 1, d)",
      "mutated_line": "dfs(1, 0, d)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 0, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dfs(1, 1, d)",
      "mutated_line": "dfs(1, 0, d)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 0, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dfs(1, 1, d)",
      "mutated_line": "dfs(1, -1, d)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, -1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return res[0]",
      "mutated_line": "return res[1]",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return res[0]",
      "mutated_line": "return res[-1]",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return res[0]",
      "mutated_line": "return res[1]",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [1] * (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [1] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [-1] * (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [-1] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [1] * (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [1] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 / 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 / 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 + 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 + 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 ** 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 ** 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 5 + 11)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 11)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 5 + 9)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 9)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 5 + 0)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 0)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 5 + 1)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 1)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 5 + -10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + -10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [1] * (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [1] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [-1] * (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [-1] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [1] * (2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [1] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 / 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 / 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 + 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 + 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 ** 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 ** 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 5 + 11)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 11)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 5 + 9)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 9)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 5 + 0)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 0)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 5 + 1)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 1)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 5 + -10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + -10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] == 2:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 2:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 0:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 0:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] == -1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == -1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 2",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 2\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 0\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 0\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - 1 - d)]] = -1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = -1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] == 2:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 2:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 0:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 0:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] == -1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == -1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 2",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 2\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 0\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 0\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - 1 - d)]] = -1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = -1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nn != par:",
      "mutated_line": "if nn == par:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn == par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] == 2:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 2:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 0:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 0:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if vis_a[cn] == 1:",
      "mutated_line": "if vis_a[cn] == -1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == -1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "vis_a[par] = 1",
      "mutated_line": "vis_a[par] = 2",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 2\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "vis_a[par] = 1",
      "mutated_line": "vis_a[par] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 0\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "vis_a[par] = 1",
      "mutated_line": "vis_a[par] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 0\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "vis_a[par] = 1",
      "mutated_line": "vis_a[par] = -1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = -1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] == 2:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 2:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 0:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 0:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if vis_b[cn] == 1:",
      "mutated_line": "if vis_b[cn] == -1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == -1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis_b[par] = 1",
      "mutated_line": "vis_b[par] = 2",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 2\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis_b[par] = 1",
      "mutated_line": "vis_b[par] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 0\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis_b[par] = 1",
      "mutated_line": "vis_b[par] = 0",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 0\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis_b[par] = 1",
      "mutated_line": "vis_b[par] = -1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = -1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cn != 1:",
      "mutated_line": "if cn != 2:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 2:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cn != 1:",
      "mutated_line": "if cn != 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 0:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cn != 1:",
      "mutated_line": "if cn != 0:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 0:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if cn != 1:",
      "mutated_line": "if cn != -1:",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != -1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 2 / (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 / (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 2 + (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 + (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 2 ** (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 ** (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (3 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (3 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (1 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (1 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (0 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (0 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (1 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (1 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (-2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (-2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * (10 * 5) + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * (10 * 5) + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * (10 + 5) + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * (10 + 5) + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (3 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (3 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (1 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (1 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (0 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (0 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (1 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (1 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (-2 * 10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (-2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * (10 * 5) + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * (10 * 5) + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * (10 + 5) + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * (10 + 5) + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[1] += 2 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[1] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[-1] += 2 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[-1] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[1] += 2 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[1] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 3 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 3 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 1 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 1 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 0 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 0 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 1 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 1 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += -2 * (vis_a[cn] + vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += -2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 2 * (vis_a[cn] - vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] - vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "res[0] += 2 * (vis_a[cn] + vis_b[cn])",
      "mutated_line": "res[0] += 2 * (vis_a[cn] * vis_b[cn])",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] * vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 11 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 11 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 9 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 9 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 0 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 0 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 1 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 1 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * -10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * -10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 6 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 6 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 4 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 4 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 0 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 0 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** 1 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 1 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "vis_a = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_a = [0] * (2 * 10 ** -5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** -5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 11 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 11 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 9 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 9 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 0 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 0 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 1 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 1 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * -10 ** 5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * -10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 6 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 6 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 4 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 4 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 0 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 0 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** 1 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 1 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis_b = [0] * (2 * 10 ** 5 + 10)",
      "mutated_line": "vis_b = [0] * (2 * 10 ** -5 + 10)",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** -5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(1, len(path) - 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(1, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(-1, len(path) - 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(-1, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(1, len(path) - 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(1, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - 1 + d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 + d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, (len(path) - 1) * d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, (len(path) - 1) * d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(1, len(path) - 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(1, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(-1, len(path) - 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(-1, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(1, len(path) - 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(1, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - 1 + d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 + d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, (len(path) - 1) * d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, (len(path) - 1) * d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) + 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) + 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) * 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) * 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) + 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) + 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) * 1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) * 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - 2 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 2 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - 0 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 0 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - 0 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 0 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis_b[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_b[path[max(0, len(path) - -1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - -1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - 2 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 2 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - 0 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 0 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - 0 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - 0 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_a[path[max(0, len(path) - 1 - d)]] = 1",
      "mutated_line": "vis_a[path[max(0, len(path) - -1 - d)]] = 1",
      "code": "from collections import defaultdict, deque\n\ndef calculate_minimum_steps(n, d, edges, sequence_a, sequence_b):\n    vis_a = [0] * (2 * 10 ** 5 + 10)\n    vis_b = [0] * (2 * 10 ** 5 + 10)\n    res = [0]\n    path = []\n\n    def dfs(cn, par, d):\n        path.append(cn)\n        if vis_a[cn] == 1:\n            vis_b[path[max(0, len(path) - 1 - d)]] = 1\n        if vis_b[cn] == 1:\n            vis_a[path[max(0, len(path) - -1 - d)]] = 1\n        for nn in g[cn]:\n            if nn != par:\n                dfs(nn, cn, d)\n        path.pop()\n        if vis_a[cn] == 1:\n            vis_a[par] = 1\n        if vis_b[cn] == 1:\n            vis_b[par] = 1\n        if cn != 1:\n            res[0] += 2 * (vis_a[cn] + vis_b[cn])\n    g = defaultdict(list)\n    for (u, v) in edges:\n        g[u].append(v)\n        g[v].append(u)\n    for i in sequence_a:\n        vis_a[i] = 1\n    for i in sequence_b:\n        vis_b[i] = 1\n    dfs(1, 1, d)\n    return res[0]"
    }
  ]
}