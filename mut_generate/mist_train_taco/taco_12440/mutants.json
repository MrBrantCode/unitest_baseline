{
  "task_id": "taco_12440",
  "entry_point": "insert_interval",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[0] <= intervals[i][0]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] <= intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[0] >= intervals[i][0]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] >= intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[0] != intervals[i][0]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] != intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] and new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] and new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "intervals = [ele for ele in intervals if ele != []]",
      "mutated_line": "intervals = [ele for ele in intervals if ele == []]",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele == []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[1] < intervals[i][0]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[1] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[-1] < intervals[i][0]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[-1] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[1] < intervals[i][0]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[1] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[0] < intervals[i][1]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][1]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[0] < intervals[i][-1]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][-1]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if new_interval[0] < intervals[i][0]:",
      "mutated_line": "if new_interval[0] < intervals[i][1]:",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][1]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] >= intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] >= intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] <= intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] <= intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] != intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] != intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] <= intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] <= intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] >= intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] >= intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] != intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] != intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[1] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[1] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[-1] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[-1] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[1] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[1] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][2] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][2] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][0] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][0] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][0] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][0] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][-1] or new_interval[1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][-1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[2] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[2] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[0] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[0] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[0] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[0] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[-1] < intervals[i][0]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[-1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][1]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][1]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][-1]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][-1]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):",
      "mutated_line": "if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][1]):",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][1]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[1], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[1], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[-1], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[-1], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[1], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[1], intervals[i][0]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][1]), max(new_interval[1], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][1]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][-1]), max(new_interval[1], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][-1]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][1]), max(new_interval[1], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][1]), max(new_interval[1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[2], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[2], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[0], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[0], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[0], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[0], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[-1], intervals[i][1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[-1], intervals[i][1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][2]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][2]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][0]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][0]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][0]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][0]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1]))",
      "mutated_line": "new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][-1]))",
      "code": "def insert_interval(intervals, new_interval):\n    \"\"\"\n    Insert a new interval into a list of non-overlapping intervals and merge if necessary.\n\n    Parameters:\n    - intervals (list of tuples): A list of tuples where each tuple represents an interval (start, end).\n    - new_interval (tuple): A tuple representing the new interval to be inserted (start, end).\n\n    Returns:\n    - list of tuples: The updated list of intervals after inserting and merging the new interval.\n    \"\"\"\n    start = len(intervals)\n    for i in range(len(intervals)):\n        if new_interval[0] < intervals[i][0]:\n            start = min(start, i)\n        if not (new_interval[0] > intervals[i][1] or new_interval[1] < intervals[i][0]):\n            new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][-1]))\n            (start, intervals[i]) = (min(i, start), [])\n    intervals = [ele for ele in intervals if ele != []]\n    intervals.insert(start, new_interval)\n    return intervals"
    }
  ]
}