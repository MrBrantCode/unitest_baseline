{
  "task_id": "taco_13388",
  "entry_point": "can_partition_k_subsets",
  "mutant_count": 60,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if rem or max(nums) > target:",
      "mutated_line": "if rem and max(nums) > target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem and max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [0] / n",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] / n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [0] + n",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] + n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [0] ** n",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] ** n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if rem or max(nums) > target:",
      "mutated_line": "if rem or max(nums) >= target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) >= target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if rem or max(nums) > target:",
      "mutated_line": "if rem or max(nums) <= target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) <= target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if rem or max(nums) > target:",
      "mutated_line": "if rem or max(nums) != target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) != target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return True\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k != 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if current_sum == target:",
      "mutated_line": "if current_sum != target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum != target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return True\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dfs(k, 0, 0)",
      "mutated_line": "return dfs(k, 1, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dfs(k, 0, 0)",
      "mutated_line": "return dfs(k, -1, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dfs(k, 0, 0)",
      "mutated_line": "return dfs(k, 1, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dfs(k, 0, 0)",
      "mutated_line": "return dfs(k, 0, 1)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dfs(k, 0, 0)",
      "mutated_line": "return dfs(k, 0, -1)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return dfs(k, 0, 0)",
      "mutated_line": "return dfs(k, 0, 1)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [1] * n",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [1] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [-1] * n",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [-1] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "seen = [0] * n",
      "mutated_line": "seen = [1] * n",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [1] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "nums.sort(reverse=True)",
      "mutated_line": "nums.sort(reverse=False)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=False)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 2:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 0:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 0:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == -1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return False\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if not seen[i] and current_sum + nums[i] <= target:",
      "mutated_line": "if not seen[i] or current_sum + nums[i] <= target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] or current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k + 1, 0, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k + 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k * 1, 0, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k * 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 1, 1, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 1, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 1, -1, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, -1, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 1, 1, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 1, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 1, 0, 1)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 1)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 1, 0, -1)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, -1)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 1, 0, 1)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 1)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not seen[i] and current_sum + nums[i] <= target:",
      "mutated_line": "if not seen[i] and current_sum + nums[i] < target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] < target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not seen[i] and current_sum + nums[i] <= target:",
      "mutated_line": "if not seen[i] and current_sum + nums[i] > target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] > target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if not seen[i] and current_sum + nums[i] <= target:",
      "mutated_line": "if not seen[i] and current_sum + nums[i] == target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] == target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "seen[i] = 1",
      "mutated_line": "seen[i] = 2",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 2\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "seen[i] = 1",
      "mutated_line": "seen[i] = 0",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 0\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "seen[i] = 1",
      "mutated_line": "seen[i] = 0",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 0\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "seen[i] = 1",
      "mutated_line": "seen[i] = -1",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = -1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "seen[i] = 0",
      "mutated_line": "seen[i] = 1",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 1\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "seen[i] = 0",
      "mutated_line": "seen[i] = -1",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = -1\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "seen[i] = 0",
      "mutated_line": "seen[i] = 1",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 1\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 2, 0, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 2, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 0, 0, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 0, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - 0, 0, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 0, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return dfs(k - 1, 0, 0)",
      "mutated_line": "return dfs(k - -1, 0, 0)",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - -1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if not seen[i] and current_sum + nums[i] <= target:",
      "mutated_line": "if not seen[i] and current_sum - nums[i] <= target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum - nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if not seen[i] and current_sum + nums[i] <= target:",
      "mutated_line": "if not seen[i] and current_sum * nums[i] <= target:",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum * nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dfs(k, i + 1, current_sum + nums[i]):",
      "mutated_line": "if dfs(k, i - 1, current_sum + nums[i]):",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i - 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dfs(k, i + 1, current_sum + nums[i]):",
      "mutated_line": "if dfs(k, i * 1, current_sum + nums[i]):",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i * 1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dfs(k, i + 1, current_sum + nums[i]):",
      "mutated_line": "if dfs(k, i + 1, current_sum - nums[i]):",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum - nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if dfs(k, i + 1, current_sum + nums[i]):",
      "mutated_line": "if dfs(k, i + 1, current_sum * nums[i]):",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum * nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 1, current_sum + nums[i]):\n                    return False\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dfs(k, i + 1, current_sum + nums[i]):",
      "mutated_line": "if dfs(k, i + 2, current_sum + nums[i]):",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 2, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dfs(k, i + 1, current_sum + nums[i]):",
      "mutated_line": "if dfs(k, i + 0, current_sum + nums[i]):",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 0, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dfs(k, i + 1, current_sum + nums[i]):",
      "mutated_line": "if dfs(k, i + 0, current_sum + nums[i]):",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + 0, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if dfs(k, i + 1, current_sum + nums[i]):",
      "mutated_line": "if dfs(k, i + -1, current_sum + nums[i]):",
      "code": "def can_partition_k_subsets(nums, k):\n    (target, rem) = divmod(sum(nums), k)\n    if rem or max(nums) > target:\n        return False\n    n = len(nums)\n    seen = [0] * n\n    nums.sort(reverse=True)\n\n    def dfs(k, index, current_sum):\n        if k == 1:\n            return True\n        if current_sum == target:\n            return dfs(k - 1, 0, 0)\n        for i in range(index, n):\n            if not seen[i] and current_sum + nums[i] <= target:\n                seen[i] = 1\n                if dfs(k, i + -1, current_sum + nums[i]):\n                    return True\n                seen[i] = 0\n        return False\n    return dfs(k, 0, 0)"
    }
  ]
}