{
  "task_id": "taco_17858",
  "entry_point": "count_different_integers",
  "mutant_count": 123,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244354\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244352\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "def count_different_integers(N, X, A):\n    MOD = 0\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 1\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "def count_different_integers(N, X, A):\n    MOD = -998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 1\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "v = 0",
      "mutated_line": "v = -1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = -1\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 1\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "X = int(X, 2)",
      "mutated_line": "X = int(X, 3)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 3)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "X = int(X, 2)",
      "mutated_line": "X = int(X, 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 1)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "X = int(X, 2)",
      "mutated_line": "X = int(X, 0)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 0)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "X = int(X, 2)",
      "mutated_line": "X = int(X, 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 1)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "X = int(X, 2)",
      "mutated_line": "X = int(X, -2)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, -2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p2 = [1]",
      "mutated_line": "p2 = [2]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [2]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p2 = [1]",
      "mutated_line": "p2 = [0]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [0]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p2 = [1]",
      "mutated_line": "p2 = [0]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [0]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p2 = [1]",
      "mutated_line": "p2 = [-1]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [-1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for _ in range(5000):",
      "mutated_line": "for _ in range(5001):",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5001):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for _ in range(5000):",
      "mutated_line": "for _ in range(4999):",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(4999):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for _ in range(5000):",
      "mutated_line": "for _ in range(0):",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(0):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for _ in range(5000):",
      "mutated_line": "for _ in range(1):",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(1):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for _ in range(5000):",
      "mutated_line": "for _ in range(-5000):",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(-5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if d < dv:",
      "mutated_line": "if d <= dv:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d <= dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if d < dv:",
      "mutated_line": "if d >= dv:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d >= dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if d < dv:",
      "mutated_line": "if d != dv:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d != dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return dfs(X, 0, dx)",
      "mutated_line": "return dfs(X, 1, dx)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 1, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return dfs(X, 0, dx)",
      "mutated_line": "return dfs(X, -1, dx)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, -1, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return dfs(X, 0, dx)",
      "mutated_line": "return dfs(X, 1, dx)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 1, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "A = [int(ai, 2) for ai in A]",
      "mutated_line": "A = [int(ai, 3) for ai in A]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 3) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "A = [int(ai, 2) for ai in A]",
      "mutated_line": "A = [int(ai, 1) for ai in A]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 1) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "A = [int(ai, 2) for ai in A]",
      "mutated_line": "A = [int(ai, 0) for ai in A]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 0) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "A = [int(ai, 2) for ai in A]",
      "mutated_line": "A = [int(ai, 1) for ai in A]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 1) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "A = [int(ai, 2) for ai in A]",
      "mutated_line": "A = [int(ai, -2) for ai in A]",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, -2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if a < b:",
      "mutated_line": "if a <= b:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a <= b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if a < b:",
      "mutated_line": "if a >= b:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a >= b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if a < b:",
      "mutated_line": "if a != b:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a != b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] * 2 * MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 * MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] * 2 + MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 + MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - 1 | 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 | 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - 1 | 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 | 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if bx and by:",
      "mutated_line": "if bx or by:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx or by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "a ^= b << (a.bit_length() - b.bit_length())",
      "mutated_line": "a ^= b << a.bit_length() + b.bit_length()",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() + b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "a ^= b << (a.bit_length() - b.bit_length())",
      "mutated_line": "a ^= b << a.bit_length() * b.bit_length()",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() * b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] / 2 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] / 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append((p2[-1] + 2) % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append((p2[-1] + 2) % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] ** 2 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] ** 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "return int(x >= y)",
      "mutated_line": "return int(x > y)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x > y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "return int(x >= y)",
      "mutated_line": "return int(x < y)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x < y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "return int(x >= y)",
      "mutated_line": "return int(x == y)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x == y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - 1 & 2",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 2\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - 1 & 0",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 0\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - 1 & 0",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 0\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - 1 & -1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & -1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - 1 & 2",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 2\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - 1 & 0",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 0\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - 1 & 0",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 0\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - 1 & -1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & -1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y, d - 1)) * MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) * MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return p2[d - dv] + dfs(x, y, d - 1) + MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return p2[d - dv] + dfs(x, y, d - 1) + MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "elif not bx and by:",
      "mutated_line": "elif not bx or by:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx or by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] * 3 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 3 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] * 1 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 1 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] * 0 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 0 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] * 1 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 1 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-1] * -2 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * -2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d + 1 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d + 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d * 1 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d * 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d + 1 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d + 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d * 1 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d * 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] - dfs(x, y, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] - dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return p2[d - dv] * dfs(x, y, d - 1) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return p2[d - dv] * dfs(x, y, d - 1) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "elif not by and bx:",
      "mutated_line": "elif not by or bx:",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by or bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[+1] * 2 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[+1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - 2 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 2 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - 0 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 0 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - 0 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 0 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "bx = x >> (d - 1) & 1",
      "mutated_line": "bx = x >> d - -1 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - -1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - 2 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 2 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - 0 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 0 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - 0 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 0 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "by = y >> (d - 1) & 1",
      "mutated_line": "by = y >> d - -1 & 1",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - -1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y | v << d - dv, d - 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y | v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y ^ v << d - dv, d + 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d + 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y ^ v << d - dv, d * 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d * 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) * MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) * MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1) + MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1) + MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-2] * 2 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-2] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-0] * 2 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-0] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[-0] * 2 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-0] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p2.append(p2[-1] * 2 % MOD)",
      "mutated_line": "p2.append(p2[--1] * 2 % MOD)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[--1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d + dv] + dfs(x, y, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d + dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d * dv] + dfs(x, y, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d * dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y, d + 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d + 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y, d * 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d * 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y ^ v << d - dv, d - 2)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 2)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y ^ v << d - dv, d - 0)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 0)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y ^ v << d - dv, d - 0)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 0)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y ^ v << d - dv, d - -1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - -1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] - dfs(x, y ^ v << d - dv, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] - dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return p2[d - dv] * dfs(x, y ^ v << d - dv, d - 1) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return p2[d - dv] * dfs(x, y ^ v << d - dv, d - 1) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return dfs(x, y, d - 1)",
      "mutated_line": "return dfs(x, y, d + 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d + 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "return dfs(x, y, d - 1)",
      "mutated_line": "return dfs(x, y, d * 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d * 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y, d - 2)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 2)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y, d - 0)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 0)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y, d - 0)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 0)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (p2[d - dv] + dfs(x, y, d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y, d - -1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - -1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y ^ v << d + dv, d - 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d + dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return dfs(x, y ^ (v << (d - dv)), d - 1)",
      "mutated_line": "return dfs(x, y ^ v << d * dv, d - 1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d * dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return dfs(x, y, d - 1)",
      "mutated_line": "return dfs(x, y, d - 2)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 2)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return dfs(x, y, d - 1)",
      "mutated_line": "return dfs(x, y, d - 0)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 0)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return dfs(x, y, d - 1)",
      "mutated_line": "return dfs(x, y, d - 0)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 0)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return dfs(x, y, d - 1)",
      "mutated_line": "return dfs(x, y, d - -1)",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - -1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d + dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d + dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d * dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d * dv] + dfs(x, y ^ v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y | v << d - dv, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y | v << d - dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d - dv, d + 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d + 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d - dv, d * 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d * 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 2)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 2)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 0)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 0)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 0)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - 0)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - -1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d - dv, d - -1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d + dv, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d + dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return (p2[d - dv] + dfs(x, y ^ (v << (d - dv)), d - 1)) % MOD",
      "mutated_line": "return (p2[d - dv] + dfs(x, y ^ v << d * dv, d - 1)) % MOD",
      "code": "def count_different_integers(N, X, A):\n    MOD = 998244353\n    X = int(X, 2)\n    A = [int(ai, 2) for ai in A]\n\n    def gcd(a, b):\n        while b:\n            if a < b:\n                (a, b) = (b, a)\n                continue\n            a ^= b << a.bit_length() - b.bit_length()\n        return a\n    v = 0\n    for ai in A:\n        v = gcd(ai, v)\n    p2 = [1]\n    for _ in range(5000):\n        p2.append(p2[-1] * 2 % MOD)\n    dv = v.bit_length()\n    dx = X.bit_length()\n\n    def dfs(x, y, d):\n        if d < dv:\n            return int(x >= y)\n        else:\n            bx = x >> d - 1 & 1\n            by = y >> d - 1 & 1\n            if bx and by:\n                return (p2[d - dv] + dfs(x, y, d - 1)) % MOD\n            elif not bx and by:\n                return dfs(x, y ^ v << d - dv, d - 1)\n            elif not by and bx:\n                return (p2[d - dv] + dfs(x, y ^ v << d * dv, d - 1)) % MOD\n            else:\n                return dfs(x, y, d - 1)\n    return dfs(X, 0, dx)"
    }
  ]
}