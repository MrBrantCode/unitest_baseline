{
  "task_id": "taco_6064",
  "entry_point": "count_valid_submatrices",
  "mutant_count": 179,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 - 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 * 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 1\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = -1\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 1\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return count * 2",
      "mutated_line": "return count / 2",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count / 2"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return count * 2",
      "mutated_line": "return count + 2",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count + 2"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return count * 2",
      "mutated_line": "return count ** 2",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count ** 2"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 * 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 + 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 8\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 6\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 0\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 1\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + -7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return False\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE or ARE >= BRS or ACS <= BCE or (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE or ARE >= BRS or ACS <= BCE or (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return True\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS or ACS >= BCS or ARE <= BRE or (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS or ACS >= BCS or ARE <= BRE or (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS or BCS >= ACS or BRE <= ARE or (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS or BCS >= ACS or BRE <= ARE or (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return False\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return count * 2",
      "mutated_line": "return count * 3",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 3"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return count * 2",
      "mutated_line": "return count * 1",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return count * 2",
      "mutated_line": "return count * 0",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 0"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return count * 2",
      "mutated_line": "return count * 1",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return count * 2",
      "mutated_line": "return count * -2",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * -2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 11 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 9 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 0 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 1 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = -10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 10 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 8 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 0 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 1 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** -9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(ARS, ARE + 1):",
      "mutated_line": "for i in range(ARS, ARE - 1):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE - 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for i in range(ARS, ARE + 1):",
      "mutated_line": "for i in range(ARS, ARE * 1):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE * 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS < BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS < BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS > BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS > BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS == BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS == BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE > BRS and (ACS <= BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE > BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE < BRS and (ACS <= BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE < BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE == BRS and (ACS <= BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE == BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE >= BRS and (ACS < BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS < BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE >= BRS and (ACS > BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS > BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE >= BRS and (ACS == BCE) and (ACE >= BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS == BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE > BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE > BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE < BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE < BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if ARS <= BRE and ARE >= BRS and ACS <= BCE and ACE >= BCS:",
      "mutated_line": "if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE == BCS):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE == BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return False\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS > BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS > BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS < BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS < BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS == BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS == BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS > BCS and (ARE <= BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS > BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS < BCS and (ARE <= BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS < BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS == BCS and (ARE <= BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS == BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS >= BCS and (ARE < BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE < BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS >= BCS and (ARE > BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE > BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS >= BCS and (ARE == BRE) and (ACE <= BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE == BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE < BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE < BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE > BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE > BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if ARS >= BRS and ACS >= BCS and ARE <= BRE and ACE <= BCE:",
      "mutated_line": "if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE == BCE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE == BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return True\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS > ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS > ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS < ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS < ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS == ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS == ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS > ACS and (BRE <= ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS > ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS < ACS and (BRE <= ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS < ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS == ACS and (BRE <= ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS == ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS >= ACS and (BRE < ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE < ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS >= ACS and (BRE > ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE > ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS >= ACS and (BRE == ARE) and (BCE <= ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE == ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE < ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE < ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE > ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE > ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if BRS >= ARS and BCS >= ACS and BRE <= ARE and BCE <= ACE:",
      "mutated_line": "if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE == ACE):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE == ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return True\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if matrix[ARS][ACS] == 0:",
      "mutated_line": "if matrix[ARS][ACS] != 0:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] != 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for y in range(x + 1, len(dp)):",
      "mutated_line": "for y in range(x - 1, len(dp)):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x - 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for y in range(x + 1, len(dp)):",
      "mutated_line": "for y in range(x * 1, len(dp)):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x * 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(ARS, ARE + 1):",
      "mutated_line": "for i in range(ARS, ARE + 2):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 2):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(ARS, ARE + 1):",
      "mutated_line": "for i in range(ARS, ARE + 0):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 0):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(ARS, ARE + 1):",
      "mutated_line": "for i in range(ARS, ARE + 0):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 0):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(ARS, ARE + 1):",
      "mutated_line": "for i in range(ARS, ARE + -1):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + -1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for j in range(ACS, ACE + 1):",
      "mutated_line": "for j in range(ACS, ACE - 1):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE - 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for j in range(ACS, ACE + 1):",
      "mutated_line": "for j in range(ACS, ACE * 1):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE * 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if matrix[i][j] != 1:",
      "mutated_line": "if matrix[i][j] == 1:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] == 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if matrix[ARS][ACS] == 0:",
      "mutated_line": "if matrix[ARS][ACS] == 1:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 1:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if matrix[ARS][ACS] == 0:",
      "mutated_line": "if matrix[ARS][ACS] == -1:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == -1:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if matrix[ARS][ACS] == 0:",
      "mutated_line": "if matrix[ARS][ACS] == 1:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 1:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for y in range(x + 1, len(dp)):",
      "mutated_line": "for y in range(x + 2, len(dp)):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 2, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for y in range(x + 1, len(dp)):",
      "mutated_line": "for y in range(x + 0, len(dp)):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 0, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for y in range(x + 1, len(dp)):",
      "mutated_line": "for y in range(x + 0, len(dp)):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 0, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for y in range(x + 1, len(dp)):",
      "mutated_line": "for y in range(x + -1, len(dp)):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + -1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "count = (count + 1) % MOD",
      "mutated_line": "count = (count + 1) * MOD",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) * MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "count = (count + 1) % MOD",
      "mutated_line": "count = count + 1 + MOD",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = count + 1 + MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(ACS, ACE + 1):",
      "mutated_line": "for j in range(ACS, ACE + 2):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 2):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(ACS, ACE + 1):",
      "mutated_line": "for j in range(ACS, ACE + 0):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 0):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(ACS, ACE + 1):",
      "mutated_line": "for j in range(ACS, ACE + 0):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 0):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(ACS, ACE + 1):",
      "mutated_line": "for j in range(ACS, ACE + -1):",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + -1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if matrix[i][j] != 1:",
      "mutated_line": "if matrix[i][j] != 2:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 2:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if matrix[i][j] != 1:",
      "mutated_line": "if matrix[i][j] != 0:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 0:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if matrix[i][j] != 1:",
      "mutated_line": "if matrix[i][j] != 0:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 0:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if matrix[i][j] != 1:",
      "mutated_line": "if matrix[i][j] != -1:",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != -1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return True\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[-1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[-1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[2], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[2], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[0], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[0], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[0], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[0], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[-1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[-1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[3], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[3], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[1], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[1], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[0], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[0], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[1], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[1], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[-2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[-2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[4], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[4], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[2], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[2], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[0], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[0], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[1], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[1], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[-3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[-3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[1], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[1], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[-1], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[-1], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[1], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[1], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[2], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[2], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[0], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[0], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[0], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[0], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[-1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[-1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[3], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[3], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[1], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[1], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[0], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[0], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[1], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[1], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[-2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[-2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[4])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[4])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[2])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[2])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[0])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[0])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[1])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[1])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[-3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[-3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[-1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[-1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[1], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[2], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[2], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[0], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[0], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[0], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[0], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[-1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[-1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[3], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[3], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[1], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[1], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[0], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[0], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[1], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[1], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[-2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[-2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[4], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[4], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[2], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[2], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[0], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[0], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[1], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[1], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[-3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[-3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[1], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[1], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[-1], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[-1], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[1], matrixB[1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[1], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[2], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[2], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[0], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[0], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[0], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[0], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[-1], matrixB[2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[-1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[3], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[3], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[1], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[1], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[0], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[0], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[1], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[1], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[-2], matrixB[3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[-2], matrixB[3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[4])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[4])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[2])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[2])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[0])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[0])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[1])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[1])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])",
      "mutated_line": "not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[-3])",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[-3])\n            if not_engulfed:\n                count = (count + 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "count = (count + 1) % MOD",
      "mutated_line": "count = (count - 1) % MOD",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count - 1) % MOD\n    return count * 2"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "count = (count + 1) % MOD",
      "mutated_line": "count = count * 1 % MOD",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = count * 1 % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "count = (count + 1) % MOD",
      "mutated_line": "count = (count + 2) % MOD",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 2) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "count = (count + 1) % MOD",
      "mutated_line": "count = (count + 0) % MOD",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 0) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "count = (count + 1) % MOD",
      "mutated_line": "count = (count + 0) % MOD",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + 0) % MOD\n    return count * 2"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "count = (count + 1) % MOD",
      "mutated_line": "count = (count + -1) % MOD",
      "code": "def count_valid_submatrices(matrix, n):\n    MOD = 10 ** 9 + 7\n\n    def check_valid(matrix, ARS, ACS, ARE, ACE):\n        for i in range(ARS, ARE + 1):\n            for j in range(ACS, ACE + 1):\n                if matrix[i][j] != 1:\n                    return False\n        return True\n\n    def check_common(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS <= BRE and ARE >= BRS and (ACS <= BCE) and (ACE >= BCS):\n            return True\n        return False\n\n    def check_not_engulfed(ARS, ACS, ARE, ACE, BRS, BCS, BRE, BCE):\n        if ARS >= BRS and ACS >= BCS and (ARE <= BRE) and (ACE <= BCE):\n            return False\n        if BRS >= ARS and BCS >= ACS and (BRE <= ARE) and (BCE <= ACE):\n            return False\n        return True\n    dp = []\n    count = 0\n    for ARS in range(n):\n        for ACS in range(n):\n            if matrix[ARS][ACS] == 0:\n                continue\n            for ARE in range(ARS, n):\n                for ACE in range(ACS, n):\n                    valid_a = check_valid(matrix, ARS, ACS, ARE, ACE)\n                    if not valid_a:\n                        continue\n                    dp.append([ARS, ACS, ARE, ACE])\n    for x in range(len(dp)):\n        for y in range(x + 1, len(dp)):\n            matrixA = dp[x]\n            matrixB = dp[y]\n            common = check_common(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not common:\n                continue\n            not_engulfed = check_not_engulfed(matrixA[0], matrixA[1], matrixA[2], matrixA[3], matrixB[0], matrixB[1], matrixB[2], matrixB[3])\n            if not_engulfed:\n                count = (count + -1) % MOD\n    return count * 2"
    }
  ]
}