{
  "task_id": "taco_17403",
  "entry_point": "powmod",
  "mutant_count": 209,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = 1",
      "mutated_line": "r = 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 2\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = 1",
      "mutated_line": "r = 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 0\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = 1",
      "mutated_line": "r = 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 0\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = 1",
      "mutated_line": "r = -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = -1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n & 1 != 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 != 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p = 3",
      "mutated_line": "p = 4",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 4\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p = 3",
      "mutated_line": "p = 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 2\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p = 3",
      "mutated_line": "p = 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 0\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p = 3",
      "mutated_line": "p = 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 1\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "p = 3",
      "mutated_line": "p = -3",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = -3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while n > 1:",
      "mutated_line": "while n >= 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n >= 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while n > 1:",
      "mutated_line": "while n <= 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n <= 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while n > 1:",
      "mutated_line": "while n != 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n != 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "p += 2",
      "mutated_line": "p -= 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p -= 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if b & 1:",
      "mutated_line": "if b | 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b | 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a * a % m",
      "mutated_line": "a = a * a * m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a * m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a * a % m",
      "mutated_line": "a = a * a + m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a + m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b >>= 1",
      "mutated_line": "b >>= 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 2\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b >>= 1",
      "mutated_line": "b >>= 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 0\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b >>= 1",
      "mutated_line": "b >>= 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 0\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b >>= 1",
      "mutated_line": "b >>= -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= -1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n | 1 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n | 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n & 1 == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 1:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n & 1 == -1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == -1:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n & 1 == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 1:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "e = 0",
      "mutated_line": "e = 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 1\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "e = 0",
      "mutated_line": "e = -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = -1\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "e = 0",
      "mutated_line": "e = 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 1\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n & 1 != 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 != 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "e += 1",
      "mutated_line": "e -= 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e -= 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n > 1:",
      "mutated_line": "while n > 2:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 2:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n > 1:",
      "mutated_line": "while n > 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 0:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n > 1:",
      "mutated_line": "while n > 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 0:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while n > 1:",
      "mutated_line": "while n > -1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > -1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p >= n:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p >= n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p <= n:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p <= n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if p * p > n:",
      "mutated_line": "if p * p != n:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p != n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if n % p:",
      "mutated_line": "if n * p:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n * p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if n % p:",
      "mutated_line": "if n + p:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n + p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "p += 2",
      "mutated_line": "p -= 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p -= 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "e = 1",
      "mutated_line": "e = 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 2\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "e = 1",
      "mutated_line": "e = 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 0\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "e = 1",
      "mutated_line": "e = 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 0\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "e = 1",
      "mutated_line": "e = -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = -1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p != 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p != 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "e += 1",
      "mutated_line": "e -= 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e -= 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p += 2",
      "mutated_line": "p += 3",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 3\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p += 2",
      "mutated_line": "p += 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 1\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p += 2",
      "mutated_line": "p += 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 0\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p += 2",
      "mutated_line": "p += 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 1\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "p += 2",
      "mutated_line": "p += -2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += -2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "assert e >= 1",
      "mutated_line": "assert e > 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e > 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "assert e >= 1",
      "mutated_line": "assert e < 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e < 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "assert e >= 1",
      "mutated_line": "assert e == 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e == 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ord = p - 1",
      "mutated_line": "ord = p + 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p + 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ord = p - 1",
      "mutated_line": "ord = p * 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p * 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "assert powmod(x, ord, p) == 1",
      "mutated_line": "assert powmod(x, ord, p) != 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) != 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "q *= p",
      "mutated_line": "q /= p",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q /= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b & 1:",
      "mutated_line": "if b & 2:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 2:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b & 1:",
      "mutated_line": "if b & 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 0:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b & 1:",
      "mutated_line": "if b & 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 0:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if b & 1:",
      "mutated_line": "if b & -1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & -1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = r * a % m",
      "mutated_line": "r = r * a * m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a * m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = r * a % m",
      "mutated_line": "r = r * a + m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a + m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a * a % m",
      "mutated_line": "a = a / a % m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a / a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a * a % m",
      "mutated_line": "a = (a + a) % m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = (a + a) % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = a * a % m",
      "mutated_line": "a = a ** a % m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a ** a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n & 2 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 2 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n & 0 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 0 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n & 0 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 0 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n & 1 == 0:",
      "mutated_line": "if n & -1 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & -1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n | 1 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n | 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n & 1 == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 1:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n & 1 == -1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == -1:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n & 1 == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 1:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n >>= 1",
      "mutated_line": "n >>= 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 2\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n >>= 1",
      "mutated_line": "n >>= 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 0\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n >>= 1",
      "mutated_line": "n >>= 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 0\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n >>= 1",
      "mutated_line": "n >>= -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= -1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "e += 1",
      "mutated_line": "e += 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 2\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "e += 1",
      "mutated_line": "e += 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 0\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "e += 1",
      "mutated_line": "e += 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 0\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "e += 1",
      "mutated_line": "e += -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += -1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if p * p > n:",
      "mutated_line": "if p / p > n:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p / p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if p * p > n:",
      "mutated_line": "if p + p > n:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p + p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if p * p > n:",
      "mutated_line": "if p ** p > n:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p ** p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p += 2",
      "mutated_line": "p += 3",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 3\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p += 2",
      "mutated_line": "p += 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 1\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p += 2",
      "mutated_line": "p += 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 0\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p += 2",
      "mutated_line": "p += 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 1\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p += 2",
      "mutated_line": "p += -2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += -2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n * p == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n * p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n + p == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n + p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 1:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == -1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == -1:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while n % p == 0:",
      "mutated_line": "while n % p == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 1:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "e += 1",
      "mutated_line": "e += 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 2\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "e += 1",
      "mutated_line": "e += 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 0\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "e += 1",
      "mutated_line": "e += 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 0\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "e += 1",
      "mutated_line": "e += -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += -1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "r = [(1, 1)]",
      "mutated_line": "r = [(2, 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(2, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "r = [(1, 1)]",
      "mutated_line": "r = [(0, 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(0, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "r = [(1, 1)]",
      "mutated_line": "r = [(0, 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(0, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "r = [(1, 1)]",
      "mutated_line": "r = [(-1, 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(-1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "r = [(1, 1)]",
      "mutated_line": "r = [(1, 2)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 2)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "r = [(1, 1)]",
      "mutated_line": "r = [(1, 0)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 0)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "r = [(1, 1)]",
      "mutated_line": "r = [(1, 0)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 0)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "r = [(1, 1)]",
      "mutated_line": "r = [(1, -1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, -1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "assert e >= 1",
      "mutated_line": "assert e >= 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 2\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "assert e >= 1",
      "mutated_line": "assert e >= 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 0\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "assert e >= 1",
      "mutated_line": "assert e >= 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 0\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "assert e >= 1",
      "mutated_line": "assert e >= -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= -1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ord = p - 1",
      "mutated_line": "ord = p - 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 2\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ord = p - 1",
      "mutated_line": "ord = p - 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 0\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ord = p - 1",
      "mutated_line": "ord = p - 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 0\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ord = p - 1",
      "mutated_line": "ord = p - -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - -1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "assert powmod(x, ord, p) == 1",
      "mutated_line": "assert powmod(x, ord, p) == 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 2\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "assert powmod(x, ord, p) == 1",
      "mutated_line": "assert powmod(x, ord, p) == 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 0\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "assert powmod(x, ord, p) == 1",
      "mutated_line": "assert powmod(x, ord, p) == 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 0\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "assert powmod(x, ord, p) == 1",
      "mutated_line": "assert powmod(x, ord, p) == -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == -1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for (pi, ei) in prime_factors(p - 1):",
      "mutated_line": "for (pi, ei) in prime_factors(p + 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p + 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for (pi, ei) in prime_factors(p - 1):",
      "mutated_line": "for (pi, ei) in prime_factors(p * 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p * 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 0 or powmod(x, ord // pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 or powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(3, e + 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(3, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(1, e + 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(1, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(0, e + 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(0, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(1, e + 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(1, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(-2, e + 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(-2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(2, e - 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e - 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(2, e * 1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e * 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if powmod(x, ord, q) != 1:",
      "mutated_line": "if powmod(x, ord, q) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) == 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "ord *= p",
      "mutated_line": "ord /= p",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord /= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "assert powmod(x, ord, q) == 1",
      "mutated_line": "assert powmod(x, ord, q) != 1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) != 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return sum((y // x for (x, y) in r))",
      "mutated_line": "return sum((y / x for (x, y) in r))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y / x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return sum((y // x for (x, y) in r))",
      "mutated_line": "return sum((y * x for (x, y) in r))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y * x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = r * a % m",
      "mutated_line": "r = r / a % m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r / a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = r * a % m",
      "mutated_line": "r = (r + a) % m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = (r + a) % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "r = r * a % m",
      "mutated_line": "r = r ** a % m",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r ** a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n & 2 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 2 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n & 0 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 0 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n & 0 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 0 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while n & 1 == 0:",
      "mutated_line": "while n & -1 == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & -1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "yield (2, e)",
      "mutated_line": "yield (3, e)",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (3, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "yield (2, e)",
      "mutated_line": "yield (1, e)",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (1, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "yield (2, e)",
      "mutated_line": "yield (0, e)",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (0, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "yield (2, e)",
      "mutated_line": "yield (1, e)",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (1, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "yield (2, e)",
      "mutated_line": "yield (-2, e)",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (-2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for (pi, ei) in prime_factors(p - 1):",
      "mutated_line": "for (pi, ei) in prime_factors(p - 2):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 2):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for (pi, ei) in prime_factors(p - 1):",
      "mutated_line": "for (pi, ei) in prime_factors(p - 0):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 0):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for (pi, ei) in prime_factors(p - 1):",
      "mutated_line": "for (pi, ei) in prime_factors(p - 0):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 0):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for (pi, ei) in prime_factors(p - 1):",
      "mutated_line": "for (pi, ei) in prime_factors(p - -1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - -1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi != 0 and powmod(x, ord // pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi != 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 0 and powmod(x, ord // pi, p) != 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) != 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(2, 1), (ord, p - 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(2, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(0, 1), (ord, p - 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(0, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(0, 1), (ord, p - 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(0, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(-1, 1), (ord, p - 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(-1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 2), (ord, p - 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 2), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 0), (ord, p - 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 0), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 0), (ord, p - 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 0), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, -1), (ord, p - 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, -1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 1), (ord, p + 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p + 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 1), (ord, p * 1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p * 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(2, e + 2):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 2):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(2, e + 0):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 0):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(2, e + 0):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 0):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "for v in range(2, e + 1):",
      "mutated_line": "for v in range(2, e + -1):",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + -1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if powmod(x, ord, q) != 1:",
      "mutated_line": "if powmod(x, ord, q) != 2:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 2:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if powmod(x, ord, q) != 1:",
      "mutated_line": "if powmod(x, ord, q) != 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 0:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if powmod(x, ord, q) != 1:",
      "mutated_line": "if powmod(x, ord, q) != 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 0:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if powmod(x, ord, q) != 1:",
      "mutated_line": "if powmod(x, ord, q) != -1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != -1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "assert powmod(x, ord, q) == 1",
      "mutated_line": "assert powmod(x, ord, q) == 2",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 2\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "assert powmod(x, ord, q) == 1",
      "mutated_line": "assert powmod(x, ord, q) == 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 0\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "assert powmod(x, ord, q) == 1",
      "mutated_line": "assert powmod(x, ord, q) == 0",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 0\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "assert powmod(x, ord, q) == 1",
      "mutated_line": "assert powmod(x, ord, q) == -1",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == -1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "mutated_line": "r = [(a // gcd(a, c) / c, b * d) for (a, b) in r for (c, d) in ords]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) / c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "mutated_line": "r = [(a // gcd(a, c) + c, b * d) for (a, b) in r for (c, d) in ords]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) + c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "mutated_line": "r = [((a // gcd(a, c)) ** c, b * d) for (a, b) in r for (c, d) in ords]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [((a // gcd(a, c)) ** c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "mutated_line": "r = [(a // gcd(a, c) * c, b / d) for (a, b) in r for (c, d) in ords]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b / d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "mutated_line": "r = [(a // gcd(a, c) * c, b + d) for (a, b) in r for (c, d) in ords]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b + d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "mutated_line": "r = [(a // gcd(a, c) * c, b ** d) for (a, b) in r for (c, d) in ords]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b ** d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord * pi == 0 and powmod(x, ord // pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord * pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord + pi == 0 and powmod(x, ord // pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord + pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 1 and powmod(x, ord // pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 1 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == -1 and powmod(x, ord // pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == -1 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 1 and powmod(x, ord // pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 1 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 2:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 2:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 0:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 0:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 0:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == -1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == -1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 1), (ord, p - 2)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 2)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 1), (ord, p - 0)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 0)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 1), (ord, p - 0)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 0)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ords = [(1, 1), (ord, p - 1)]",
      "mutated_line": "ords = [(1, 1), (ord, p - -1)]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - -1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q // p / (p - 1)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p / (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q // p + (p - 1)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p + (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, (q // p) ** (p - 1)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, (q // p) ** (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "mutated_line": "r = [(a / gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a / gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "mutated_line": "r = [(a * gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a * gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 0 and powmod(x, ord / pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord / pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "while ord % pi == 0 and powmod(x, ord // pi, p) == 1:",
      "mutated_line": "while ord % pi == 0 and powmod(x, ord * pi, p) == 1:",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord * pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q / p * (p - 1)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q / p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q * p * (p - 1)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q * p * (p - 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q // p * (p + 1)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p + 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q // p * (p * 1)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p * 1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q // p * (p - 2)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 2)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q // p * (p - 0)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 0)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q // p * (p - 0)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - 0)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "ords.append((ord, q // p * (p - 1)))",
      "mutated_line": "ords.append((ord, q // p * (p - -1)))",
      "code": "from math import gcd\n\ndef powmod(a, b, m):\n    a %= m\n    r = 1\n    while b:\n        if b & 1:\n            r = r * a % m\n        a = a * a % m\n        b >>= 1\n    return r\n\ndef prime_factors(n):\n    if n & 1 == 0:\n        e = 0\n        while n & 1 == 0:\n            n >>= 1\n            e += 1\n        yield (2, e)\n    p = 3\n    while n > 1:\n        if p * p > n:\n            p = n\n        if n % p:\n            p += 2\n            continue\n        e = 1\n        n //= p\n        while n % p == 0:\n            n //= p\n            e += 1\n        yield (p, e)\n        p += 2\n\ndef minimum_traps_needed(m, x):\n    r = [(1, 1)]\n    for (p, e) in prime_factors(m):\n        assert e >= 1\n        ord = p - 1\n        assert powmod(x, ord, p) == 1\n        for (pi, ei) in prime_factors(p - 1):\n            while ord % pi == 0 and powmod(x, ord // pi, p) == 1:\n                ord //= pi\n        ords = [(1, 1), (ord, p - 1)]\n        q = p\n        for v in range(2, e + 1):\n            q *= p\n            if powmod(x, ord, q) != 1:\n                ord *= p\n            assert powmod(x, ord, q) == 1\n            ords.append((ord, q // p * (p - -1)))\n        r = [(a // gcd(a, c) * c, b * d) for (a, b) in r for (c, d) in ords]\n    return sum((y // x for (x, y) in r))"
    }
  ]
}