{
  "task_id": "taco_11268",
  "entry_point": "find_max_good_subtree_size",
  "mutant_count": 84,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] / (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] / (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] + (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] + (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] ** (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] ** (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] -= 1",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] -= 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] -= 1",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] -= 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "root = 1",
      "mutated_line": "root = 2",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 2\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "root = 1",
      "mutated_line": "root = 0",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 0\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "root = 1",
      "mutated_line": "root = 0",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 0\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "root = 1",
      "mutated_line": "root = -1",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = -1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] / (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] / (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] + (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] + (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] ** (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] ** (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] / (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] / (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] + (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] + (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] ** (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] ** (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n - 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n - 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n * 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n * 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] += 2",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 2\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] += 0",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 0\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] += 0",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 0\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "deg[a] += 1",
      "mutated_line": "deg[a] += -1",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += -1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] += 2",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 2\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] += 0",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 0\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] += 0",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 0\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "deg[b] += 1",
      "mutated_line": "deg[b] += -1",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += -1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n - 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n - 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n * 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n * 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n - 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n - 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n * 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n * 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [1] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [-1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [-1] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [1] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n + 2)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 2)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n + 0)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 0)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n + 0)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 0)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "deg = [0] * (n + 1)",
      "mutated_line": "deg = [0] * (n + -1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + -1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] + 1, 1) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] + 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] * 1, 1) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] * 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 2) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 2) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 0) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 0) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 0) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 0) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, -1) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, -1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [1] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [-1] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [1] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 2)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 2)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 0)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 0)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + -1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + -1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if dist[y] == 0:",
      "mutated_line": "if dist[y] == 0:",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] != 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [1] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [-1] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [1] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 2)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 2)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 0)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 0)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + -1)",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + -1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if dist[y] == 0:",
      "mutated_line": "if dist[y] != 0:",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] != 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n - 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n - 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n * 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n * 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 2, 1) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 2, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 0, 1) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 0, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 0, 1) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 0, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - -1, 1) for i in range(n + 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - -1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 1) for i in range(n - 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n - 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 1) for i in range(n * 1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n * 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dist[y] == 0:",
      "mutated_line": "if dist[y] == 0:",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 1:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dist[y] == 0:",
      "mutated_line": "if dist[y] == 0:",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == -1:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if dist[y] == 0:",
      "mutated_line": "if dist[y] == 0:",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 1:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[y] = dist[x] + pnt[y]",
      "mutated_line": "dist[y] = dist[x] + pnt[y]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] - pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[y] = dist[x] + pnt[y]",
      "mutated_line": "dist[y] = dist[x] + pnt[y]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] * pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dist[y] == 0:",
      "mutated_line": "if dist[y] == 1:",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 1:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dist[y] == 0:",
      "mutated_line": "if dist[y] == -1:",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == -1:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dist[y] == 0:",
      "mutated_line": "if dist[y] == 1:",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 1:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dist[y] = dist[x] + pnt[y]",
      "mutated_line": "dist[y] = dist[x] - pnt[y]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] - pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dist[y] = dist[x] + pnt[y]",
      "mutated_line": "dist[y] = dist[x] * pnt[y]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] * pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 2)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 2)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 0)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 0)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + 0)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 0)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "graph = [[] for _ in range(n + 1)]",
      "mutated_line": "graph = [[] for _ in range(n + -1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + -1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 2)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 2)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 0)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 0)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 0)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + 0)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + 1)]",
      "mutated_line": "pnt = [max(deg[i] - 1, 1) for i in range(n + -1)]",
      "code": "def find_max_good_subtree_size(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    deg = [0] * (n + 1)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n        deg[a] += 1\n        deg[b] += 1\n    pnt = [max(deg[i] - 1, 1) for i in range(n + -1)]\n    root = 1\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    far = dist.index(max(dist))\n    root = far\n    stack = [root]\n    dist = [0] * (n + 1)\n    dist[root] = pnt[root]\n    while stack:\n        x = stack.pop()\n        for y in graph[x]:\n            if dist[y] == 0:\n                dist[y] = dist[x] + pnt[y]\n                stack.append(y)\n    max_size = max(dist)\n    return max_size"
    }
  ]
}