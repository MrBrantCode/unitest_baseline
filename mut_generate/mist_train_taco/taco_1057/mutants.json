{
  "task_id": "taco_1057",
  "entry_point": "min_operations_to_symmetric_grid",
  "mutant_count": 177,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 1\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = -1\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 1\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 != 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = 0",
      "mutated_line": "b = 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 1\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = 0",
      "mutated_line": "b = -1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = -1\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = 0",
      "mutated_line": "b = 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 1\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if grid[j][k] == '1':",
      "mutated_line": "if grid[j][k] != '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] != '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "b += 1",
      "mutated_line": "b -= 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b -= 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n - 1 - k][j] != '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] != '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "b += 1",
      "mutated_line": "b -= 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b -= 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n - 1 - k] != '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] != '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "b += 1",
      "mutated_line": "b -= 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b -= 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n - 1 - j] != '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] != '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "b += 1",
      "mutated_line": "b -= 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b -= 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n * 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n + 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 2:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 0:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 0:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == -1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if grid[j][k] == '1':",
      "mutated_line": "if grid[j][k] == '':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b += 1",
      "mutated_line": "b += 2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 2\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 0\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 0\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "b += 1",
      "mutated_line": "b += -1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += -1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n - 1 - k][j] == '':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "b += 1",
      "mutated_line": "b += 2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 2\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 0\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 0\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "b += 1",
      "mutated_line": "b += -1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += -1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n - 1 - k] == '':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b += 1",
      "mutated_line": "b += 2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 2\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 0\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 0\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b += 1",
      "mutated_line": "b += -1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += -1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n - 1 - j] == '':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b += 1",
      "mutated_line": "b += 2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 2\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 0\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 0\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b += 1",
      "mutated_line": "b += -1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += -1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 3 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 1 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 0 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 1 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % -2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n - 1 + k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 + k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][(n - 1) * k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][(n - 1) * k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n - 1 + j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 + j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][(n - 1) * j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][(n - 1) * j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 1) * 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) * 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 1) // 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) // 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 and b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 and b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans -= 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(int(n / 2)):",
      "mutated_line": "for j in range(int(n * 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n * 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for j in range(int(n / 2)):",
      "mutated_line": "for j in range(int(n // 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n // 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 and b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 and b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans -= 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n - 1 + k][j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 + k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[(n - 1) * k][j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[(n - 1) * k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 + j][n - 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 + j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[(n - 1) * j][n - 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[(n - 1) * j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n + 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n + 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n * 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n * 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n + 1 - j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n + 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n * 1 - j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n * 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n - 1) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n - 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int(n * 1 / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int(n * 1 / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 1) / 3)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 3)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 1) / 1)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 1)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 1) / 0)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 0)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 1) / 1)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 1)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 1) / -2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / -2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 1) * 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) * 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 1) // 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) // 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b != 1 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b != 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b != 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b != 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 2\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 0\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 0\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += -1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b != 2:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b != 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "ans += 2",
      "mutated_line": "ans -= 2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans -= 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(int(n / 2)):",
      "mutated_line": "for j in range(int(n / 3)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 3)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(int(n / 2)):",
      "mutated_line": "for j in range(int(n / 1)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 1)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(int(n / 2)):",
      "mutated_line": "for j in range(int(n / 0)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 0)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(int(n / 2)):",
      "mutated_line": "for j in range(int(n / 1)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 1)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for j in range(int(n / 2)):",
      "mutated_line": "for j in range(int(n / -2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / -2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for k in range(int(n / 2)):",
      "mutated_line": "for k in range(int(n * 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n * 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for k in range(int(n / 2)):",
      "mutated_line": "for k in range(int(n // 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n // 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b != 1 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b != 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b != 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b != 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 2\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 0\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 0\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += -1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b != 2:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b != 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "ans += 2",
      "mutated_line": "ans -= 2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans -= 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n + 1 - k][j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n + 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n * 1 - k][j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n * 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n + 1 - j][n - 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n + 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n * 1 - j][n - 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n * 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n - 2 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 2 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n - 0 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 0 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n - 0 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 0 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 1 - j][n - -1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - -1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n - 2 - j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 2 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n - 0 - j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 0 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n - 0 - j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 0 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if grid[k][n - 1 - j] == '1':",
      "mutated_line": "if grid[k][n - -1 - j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - -1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 2) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 2) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 0) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 0) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + 0) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 0) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for j in range(int((n + 1) / 2)):",
      "mutated_line": "for j in range(int((n + -1) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + -1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n + 1) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n + 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int(n * 1 / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int(n * 1 / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 1) / 3)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 3)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 1) / 1)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 1)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 1) / 0)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 0)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 1) / 1)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 1)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 1) / -2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / -2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 2 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 2 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 0 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 0 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 0 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 0 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == -1 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == -1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == 4:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 4:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == 2:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 2:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == 0:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 0:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 1:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == -3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == -3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 3:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 1:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == 0:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 0:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 1:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == -2:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == -2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 2",
      "mutated_line": "ans += 3",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 3\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 2",
      "mutated_line": "ans += 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 1\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 2",
      "mutated_line": "ans += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 0\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 2",
      "mutated_line": "ans += 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 1\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 2",
      "mutated_line": "ans += -2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += -2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(int(n / 2)):",
      "mutated_line": "for k in range(int(n / 3)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 3)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(int(n / 2)):",
      "mutated_line": "for k in range(int(n / 1)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 1)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(int(n / 2)):",
      "mutated_line": "for k in range(int(n / 0)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 0)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(int(n / 2)):",
      "mutated_line": "for k in range(int(n / 1)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 1)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for k in range(int(n / 2)):",
      "mutated_line": "for k in range(int(n / -2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / -2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 2 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 2 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 0 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 0 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 0 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 0 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == -1 or b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == -1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == 4:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 4:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == 2:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 2:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == 0:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 0:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 1:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if b == 1 or b == 3:",
      "mutated_line": "if b == 1 or b == -3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == -3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == 3:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 3:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 1:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == 0:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 0:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == 1:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 1:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "elif b == 2:",
      "mutated_line": "elif b == -2:",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == -2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 2",
      "mutated_line": "ans += 3",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 3\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 2",
      "mutated_line": "ans += 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 2",
      "mutated_line": "ans += 0",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 2",
      "mutated_line": "ans += 1",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 2",
      "mutated_line": "ans += -2",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += -2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n - 2 - k][j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 2 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n - 0 - k][j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 0 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n - 0 - k][j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 0 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if grid[n - 1 - k][j] == '1':",
      "mutated_line": "if grid[n - -1 - k][j] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - -1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 2 - j][n - 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 2 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 0 - j][n - 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 0 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - 0 - j][n - 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 0 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if grid[n - 1 - j][n - 1 - k] == '1':",
      "mutated_line": "if grid[n - -1 - j][n - 1 - k] == '1':",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - -1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 2) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 2) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 0) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 0) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - 0) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - 0) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(int((n - 1) / 2)):",
      "mutated_line": "for k in range(int((n - -1) / 2)):",
      "code": "def min_operations_to_symmetric_grid(grid, n):\n    \"\"\"\n    Calculate the minimum number of operations needed to make the grid look the same\n    under 0°, 90°, 180°, and 270° rotations.\n\n    Parameters:\n    - grid (list of str): A list of strings where each string represents a row in the grid.\n    - n (int): The size of the grid (number of rows and columns).\n\n    Returns:\n    - int: The minimum number of operations needed.\n    \"\"\"\n\n    def count_flips(j, k):\n        b = 0\n        if grid[j][k] == '1':\n            b += 1\n        if grid[n - 1 - k][j] == '1':\n            b += 1\n        if grid[n - 1 - j][n - 1 - k] == '1':\n            b += 1\n        if grid[k][n - 1 - j] == '1':\n            b += 1\n        return b\n    ans = 0\n    if n % 2 == 1:\n        for j in range(int((n + 1) / 2)):\n            for k in range(int((n - -1) / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    else:\n        for j in range(int(n / 2)):\n            for k in range(int(n / 2)):\n                b = count_flips(j, k)\n                if b == 1 or b == 3:\n                    ans += 1\n                elif b == 2:\n                    ans += 2\n    return ans"
    }
  ]
}