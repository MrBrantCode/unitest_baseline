{
  "task_id": "taco_4379",
  "entry_point": "can_fall_through_ice",
  "mutant_count": 171,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "have = 0",
      "mutated_line": "have = 1",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 1\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "have = 0",
      "mutated_line": "have = -1",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = -1\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "have = 0",
      "mutated_line": "have = 1",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 1\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ok = False",
      "mutated_line": "ok = True",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = True\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if start == end:",
      "mutated_line": "if start != end:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start != end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return ''"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [+1, 0, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [+1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 1, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, -1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, -1, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 1, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 2, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 2, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 0, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 0, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 0, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 0, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, -1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, -1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 1, 1, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 1, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 1, -1, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, -1, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 1, 1, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 1, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 1, 0, +1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, +1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis = [[False] * m for _ in range(n)]",
      "mutated_line": "vis = [[False] / m for _ in range(n)]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] / m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis = [[False] * m for _ in range(n)]",
      "mutated_line": "vis = [[False] + m for _ in range(n)]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] + m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis = [[False] * m for _ in range(n)]",
      "mutated_line": "vis = [[False] ** m for _ in range(n)]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] ** m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] + 1, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] + 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] * 1, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] * 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[1] + 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] + 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[1] * 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] * 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] + 1, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] + 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] * 1, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] * 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[1] + 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] + 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[1] * 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] * 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(5):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(5):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(3):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(3):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(0):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(0):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(1):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(1):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(-4):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(-4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "x = end[0] + dir[d]",
      "mutated_line": "x = end[0] - dir[d]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] - dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "x = end[0] + dir[d]",
      "mutated_line": "x = end[0] * dir[d]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] * dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[1] - dir[d + 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] - dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[1] * dir[d + 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] * dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (x, y) == start:",
      "mutated_line": "if (x, y) != start:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) != start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n or 0 <= y < m or cave[x][y] != 'X':",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n or 0 <= y < m or cave[x][y] != 'X':\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "have += 1",
      "mutated_line": "have -= 1",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have -= 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "vis[i][j] = True",
      "mutated_line": "vis[i][j] = False",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = False\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if (i, j) == end:",
      "mutated_line": "if (i, j) != end:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) != end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-2, 0, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-2, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-0, 0, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-0, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-0, 0, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-0, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [--1, 0, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [--1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 1, 0, -2]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -2]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 1, 0, -0]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -0]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 1, 0, -0]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -0]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dir = [-1, 0, 1, 0, -1]",
      "mutated_line": "dir = [-1, 0, 1, 0, --1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, --1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 2, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 2, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 0, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 0, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 0, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 0, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - -1, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - -1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[1] - 2)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 2)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[1] - 0)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 0)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[1] - 0)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 0)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[1] - -1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - -1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 2, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 2, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 0, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 0, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 0, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 0, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - -1, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - -1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[1] - 2)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 2)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[1] - 0)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 0)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[1] - 0)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 0)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[1] - -1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - -1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ok = True",
      "mutated_line": "ok = False",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = False\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 < x < n and 0 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 < x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 > x < n and 0 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 > x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 == x < n and 0 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 == x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n and 0 < y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 < y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n and 0 > y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 > y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n and 0 == y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 == y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n and 0 <= y < m and (cave[x][y] == 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] == 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "have += 1",
      "mutated_line": "have += 2",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 2\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "have += 1",
      "mutated_line": "have += 0",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 0\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "have += 1",
      "mutated_line": "have += 0",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 0\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "have += 1",
      "mutated_line": "have += -1",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += -1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return 'YES' if have > 0 else 'NO'",
      "mutated_line": "return 'YES' if have >= 0 else 'NO'",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have >= 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return 'YES' if have > 0 else 'NO'",
      "mutated_line": "return 'YES' if have <= 0 else 'NO'",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have <= 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return 'YES' if have > 0 else 'NO'",
      "mutated_line": "return 'YES' if have != 0 else 'NO'",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have != 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'YES' if have > 0 else 'NO'",
      "mutated_line": "return '' if have > 0 else 'NO'",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return '' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'YES' if have > 0 else 'NO'",
      "mutated_line": "return 'YES' if have > 0 else ''",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else ''\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if have >= 2:",
      "mutated_line": "if have > 2:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have > 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if have >= 2:",
      "mutated_line": "if have < 2:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have < 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if have >= 2:",
      "mutated_line": "if have == 2:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have == 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(5):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(5):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(3):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(3):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(0):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(0):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(1):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(1):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for d in range(4):",
      "mutated_line": "for d in range(-4):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(-4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "x = i + dir[d]",
      "mutated_line": "x = i - dir[d]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i - dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "x = i + dir[d]",
      "mutated_line": "x = i * dir[d]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i * dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "y = j + dir[d + 1]",
      "mutated_line": "y = j - dir[d + 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j - dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "y = j + dir[d + 1]",
      "mutated_line": "y = j * dir[d + 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j * dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 <= x < n or 0 <= y < m or (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n or 0 <= y < m or (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis = [[False] * m for _ in range(n)]",
      "mutated_line": "vis = [[True] * m for _ in range(n)]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[True] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[1] - 1, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[1] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[-1] - 1, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[-1] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[1] - 1, start[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[1] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[2] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[2] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[0] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[0] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[0] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[0] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "start = (start[0] - 1, start[1] - 1)",
      "mutated_line": "start = (start[0] - 1, start[-1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[-1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[1] - 1, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[1] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[-1] - 1, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[-1] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[1] - 1, end[1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[1] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[2] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[2] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[0] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[0] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[0] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[0] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "end = (end[0] - 1, end[1] - 1)",
      "mutated_line": "end = (end[0] - 1, end[-1] - 1)",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[-1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x = end[0] + dir[d]",
      "mutated_line": "x = end[1] + dir[d]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[1] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x = end[0] + dir[d]",
      "mutated_line": "x = end[-1] + dir[d]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[-1] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x = end[0] + dir[d]",
      "mutated_line": "x = end[1] + dir[d]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[1] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[2] + dir[d + 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[2] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[0] + dir[d + 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[0] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[0] + dir[d + 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[0] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[-1] + dir[d + 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[-1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[1] + dir[d - 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d - 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[1] + dir[d * 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d * 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 1 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 1 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if -1 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if -1 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 1 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 1 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n and 1 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 1 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n and -1 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and -1 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n and 1 <= y < m and (cave[x][y] != 'X'):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 1 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= x < n and 0 <= y < m and cave[x][y] != 'X':",
      "mutated_line": "if 0 <= x < n and 0 <= y < m and (cave[x][y] != ''):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != ''):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'YES' if have > 0 else 'NO'",
      "mutated_line": "return 'YES' if have > 1 else 'NO'",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 1 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'YES' if have > 0 else 'NO'",
      "mutated_line": "return 'YES' if have > -1 else 'NO'",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > -1 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 'YES' if have > 0 else 'NO'",
      "mutated_line": "return 'YES' if have > 1 else 'NO'",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 1 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if have >= 2:",
      "mutated_line": "if have >= 3:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 3:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if have >= 2:",
      "mutated_line": "if have >= 1:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 1:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if have >= 2:",
      "mutated_line": "if have >= 0:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 0:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if have >= 2:",
      "mutated_line": "if have >= 1:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 1:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if have >= 2:",
      "mutated_line": "if have >= -2:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= -2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 'YES'",
      "mutated_line": "return ''",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return ''\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "elif have == 1 and ok:",
      "mutated_line": "elif have == 1 or ok:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 or ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 < x < n and 0 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 < x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 > x < n and 0 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 > x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 == x < n and 0 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 == x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 <= x < n and 0 < y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 < y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 <= x < n and 0 > y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 > y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 <= x < n and 0 == y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 == y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if cave[x][y] != 'X':",
      "mutated_line": "if cave[x][y] == 'X':",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] == 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[1] + dir[d + 2]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 2]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[1] + dir[d + 0]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 0]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[1] + dir[d + 0]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 0]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "y = end[1] + dir[d + 1]",
      "mutated_line": "y = end[1] + dir[d + -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + -1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif have == 1 and ok:",
      "mutated_line": "elif have != 1 and ok:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have != 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 'YES'",
      "mutated_line": "return ''",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return ''\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return ''\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "y = j + dir[d + 1]",
      "mutated_line": "y = j + dir[d - 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d - 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "y = j + dir[d + 1]",
      "mutated_line": "y = j + dir[d * 1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d * 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 1 <= x < n and 0 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 1 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if -1 <= x < n and 0 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if -1 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 1 <= x < n and 0 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 1 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 <= x < n and 1 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 1 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 <= x < n and -1 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and -1 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= x < n and 0 <= y < m and not vis[x][y]:",
      "mutated_line": "if 0 <= x < n and 1 <= y < m and (not vis[x][y]):",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 1 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if cave[x][y] != 'X':",
      "mutated_line": "if cave[x][y] != '':",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != '':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif (x, y) == end:",
      "mutated_line": "elif (x, y) != end:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) != end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif have == 1 and ok:",
      "mutated_line": "elif have == 2 and ok:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 2 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif have == 1 and ok:",
      "mutated_line": "elif have == 0 and ok:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 0 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif have == 1 and ok:",
      "mutated_line": "elif have == 0 and ok:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 0 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif have == 1 and ok:",
      "mutated_line": "elif have == -1 and ok:",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == -1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "y = j + dir[d + 1]",
      "mutated_line": "y = j + dir[d + 2]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 2]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "y = j + dir[d + 1]",
      "mutated_line": "y = j + dir[d + 0]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 0]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "y = j + dir[d + 1]",
      "mutated_line": "y = j + dir[d + 0]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 0]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "y = j + dir[d + 1]",
      "mutated_line": "y = j + dir[d + -1]",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + -1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return 'YES'\n    return 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return 'YES'",
      "mutated_line": "return ''",
      "code": "from collections import deque\n\ndef can_fall_through_ice(n, m, cave, start, end):\n    dir = [-1, 0, 1, 0, -1]\n    vis = [[False] * m for _ in range(n)]\n    start = (start[0] - 1, start[1] - 1)\n    end = (end[0] - 1, end[1] - 1)\n    have = 0\n    ok = False\n    for d in range(4):\n        x = end[0] + dir[d]\n        y = end[1] + dir[d + 1]\n        if (x, y) == start:\n            ok = True\n        if 0 <= x < n and 0 <= y < m and (cave[x][y] != 'X'):\n            have += 1\n    if start == end:\n        return 'YES' if have > 0 else 'NO'\n    q = deque([start])\n    while q:\n        (i, j) = q.pop()\n        if vis[i][j]:\n            continue\n        vis[i][j] = True\n        if (i, j) == end:\n            if have >= 2:\n                return 'YES'\n            elif have == 1 and ok:\n                return 'YES'\n            else:\n                return 'NO'\n        for d in range(4):\n            x = i + dir[d]\n            y = j + dir[d + 1]\n            if 0 <= x < n and 0 <= y < m and (not vis[x][y]):\n                if cave[x][y] != 'X':\n                    q.append((x, y))\n                elif (x, y) == end:\n                    return ''\n    return 'NO'"
    }
  ]
}