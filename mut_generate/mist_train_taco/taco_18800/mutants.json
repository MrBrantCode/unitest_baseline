{
  "task_id": "taco_18800",
  "entry_point": "calculate_minimum_alphabet_cost",
  "mutant_count": 136,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_0 < c_1:",
      "mutated_line": "if c_0 <= c_1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 <= c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_0 < c_1:",
      "mutated_line": "if c_0 >= c_1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 >= c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if c_0 < c_1:",
      "mutated_line": "if c_0 != c_1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 != c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if c_1 == 0:",
      "mutated_line": "if c_1 != 0:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 != 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "remain = n - 1",
      "mutated_line": "remain = n + 1",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n + 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "remain = n - 1",
      "mutated_line": "remain = n * 1",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n * 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 1\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = -1\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 1\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while False:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "ans += u * v",
      "mutated_line": "ans -= u * v",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans -= u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "remain -= v",
      "mutated_line": "remain += v",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain += v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c_1 == 0:",
      "mutated_line": "if c_1 == 1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 1:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c_1 == 0:",
      "mutated_line": "if c_1 == -1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == -1:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if c_1 == 0:",
      "mutated_line": "if c_1 == 1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 1:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return (n - 1) / c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) / c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return n - 1 + c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return n - 1 + c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return (n - 1) ** c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) ** c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[1] / 20005]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] / 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[1] + 20005]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] + 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[1] ** 20005]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] ** 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(20004):",
      "mutated_line": "for i in range(20005):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20005):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(20004):",
      "mutated_line": "for i in range(20003):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20003):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(20004):",
      "mutated_line": "for i in range(0):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(0):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(20004):",
      "mutated_line": "for i in range(1):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(1):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(20004):",
      "mutated_line": "for i in range(-20004):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(-20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(pascal[a]) > b:",
      "mutated_line": "if len(pascal[a]) >= b:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) >= b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(pascal[a]) > b:",
      "mutated_line": "if len(pascal[a]) <= b:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) <= b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(pascal[a]) > b:",
      "mutated_line": "if len(pascal[a]) != b:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) != b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if b == 0:",
      "mutated_line": "if b != 0:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b != 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if b == 1:",
      "mutated_line": "if b != 1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b != 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 100000005",
      "mutated_line": "return 100000006",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000006\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 100000005",
      "mutated_line": "return 100000004",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000004\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 100000005",
      "mutated_line": "return 0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 0\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 100000005",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 1\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return 100000005",
      "mutated_line": "return -100000005",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return -100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "remain = n - 1",
      "mutated_line": "remain = n - 2",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 2\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "remain = n - 1",
      "mutated_line": "remain = n - 0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 0\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "remain = n - 1",
      "mutated_line": "remain = n - 0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 0\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "remain = n - 1",
      "mutated_line": "remain = n - -1",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - -1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "while possible and possible[0][0] == u:",
      "mutated_line": "while possible or possible[0][0] == u:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible or possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "v += possible[0][1]",
      "mutated_line": "v -= possible[0][1]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v -= possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if remain <= v:",
      "mutated_line": "if remain < v:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain < v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if remain <= v:",
      "mutated_line": "if remain > v:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain > v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if remain <= v:",
      "mutated_line": "if remain == v:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain == v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "ans += u * remain",
      "mutated_line": "ans -= u * remain",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans -= u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += u * v",
      "mutated_line": "ans += u / v",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u / v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += u * v",
      "mutated_line": "ans += u + v",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u + v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "ans += u * v",
      "mutated_line": "ans += u ** v",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u ** v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return (n + 1) * c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n + 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return n * 1 * c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return n * 1 * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[1] * 20006]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20006]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[1] * 20004]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20004]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[1] * 0]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 0]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[1] * 1]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 1]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[1] * -20005]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * -20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "newrow = [1]",
      "mutated_line": "newrow = [2]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [2]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "newrow = [1]",
      "mutated_line": "newrow = [0]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [0]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "newrow = [1]",
      "mutated_line": "newrow = [0]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [0]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "newrow = [1]",
      "mutated_line": "newrow = [-1]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [-1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(2, 20005):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(2, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(0, 20005):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(0, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(0, 20005):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(0, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(-1, 20005):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(-1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(1, 20006):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20006):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(1, 20004):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20004):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(1, 0):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 0):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(1, 1):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 1):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, 20005):",
      "mutated_line": "for j in range(1, -20005):",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, -20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if newrow[-1] > n:",
      "mutated_line": "if newrow[-1] >= n:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] >= n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if newrow[-1] > n:",
      "mutated_line": "if newrow[-1] <= n:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] <= n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if newrow[-1] > n:",
      "mutated_line": "if newrow[-1] != n:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] != n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if b == 0:",
      "mutated_line": "if b == 1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 1:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if b == 0:",
      "mutated_line": "if b == -1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == -1:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if b == 0:",
      "mutated_line": "if b == 1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 1:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 2\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 0\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 0\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return -1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 2:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 2:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 0:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 0:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if b == 1:",
      "mutated_line": "if b == 0:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 0:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if b == 1:",
      "mutated_line": "if b == -1:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == -1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "possible = [[c_0 + c_1, 1]]",
      "mutated_line": "possible = [[c_0 - c_1, 1]]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 - c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "possible = [[c_0 + c_1, 1]]",
      "mutated_line": "possible = [[c_0 * c_1, 1]]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 * c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "possible = [[c_0 + c_1, 1]]",
      "mutated_line": "possible = [[c_0 + c_1, 2]]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 2]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "possible = [[c_0 + c_1, 1]]",
      "mutated_line": "possible = [[c_0 + c_1, 0]]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 0]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "possible = [[c_0 + c_1, 1]]",
      "mutated_line": "possible = [[c_0 + c_1, 0]]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 0]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "possible = [[c_0 + c_1, 1]]",
      "mutated_line": "possible = [[c_0 + c_1, -1]]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, -1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "while possible and possible[0][0] == u:",
      "mutated_line": "while possible and possible[0][0] != u:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] != u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans += u * remain",
      "mutated_line": "ans += u / remain",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u / remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans += u * remain",
      "mutated_line": "ans += u + remain",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u + remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "ans += u * remain",
      "mutated_line": "ans += u ** remain",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u ** remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return (n - 2) * c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 2) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return (n - 0) * c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 0) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return (n - 0) * c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 0) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return (n - 1) * c_0",
      "mutated_line": "return (n - -1) * c_0",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - -1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[2] * 20005]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[2] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[0] * 20005]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[0] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[0] * 20005]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[0] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "pascal = [[1] * 20005]",
      "mutated_line": "pascal = [[-1] * 20005]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[-1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-1] - pascal[-1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] - pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-1] * pascal[-1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] * pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v += possible[0][1]",
      "mutated_line": "v += possible[0][2]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][2]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v += possible[0][1]",
      "mutated_line": "v += possible[0][0]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][0]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v += possible[0][1]",
      "mutated_line": "v += possible[0][0]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][0]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v += possible[0][1]",
      "mutated_line": "v += possible[0][-1]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][-1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "heapq.heappush(possible, [u + c_0, v])",
      "mutated_line": "heapq.heappush(possible, [u - c_0, v])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u - c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "heapq.heappush(possible, [u + c_0, v])",
      "mutated_line": "heapq.heappush(possible, [u * c_0, v])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u * c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "heapq.heappush(possible, [u + c_1, v])",
      "mutated_line": "heapq.heappush(possible, [u - c_1, v])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u - c_1, v])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "heapq.heappush(possible, [u + c_1, v])",
      "mutated_line": "heapq.heappush(possible, [u * c_1, v])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u * c_1, v])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if newrow[-1] > n:",
      "mutated_line": "if newrow[+1] > n:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[+1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while possible and possible[0][0] == u:",
      "mutated_line": "while possible and possible[0][1] == u:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][1] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while possible and possible[0][0] == u:",
      "mutated_line": "while possible and possible[0][-1] == u:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][-1] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while possible and possible[0][0] == u:",
      "mutated_line": "while possible and possible[0][1] == u:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][1] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v += possible[0][1]",
      "mutated_line": "v += possible[1][1]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[1][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v += possible[0][1]",
      "mutated_line": "v += possible[-1][1]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[-1][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "v += possible[0][1]",
      "mutated_line": "v += possible[1][1]",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[1][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[+1] + pascal[-1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[+1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if newrow[-1] > n:",
      "mutated_line": "if newrow[-2] > n:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-2] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if newrow[-1] > n:",
      "mutated_line": "if newrow[-0] > n:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-0] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if newrow[-1] > n:",
      "mutated_line": "if newrow[-0] > n:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-0] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if newrow[-1] > n:",
      "mutated_line": "if newrow[--1] > n:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[--1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while possible and possible[0][0] == u:",
      "mutated_line": "while possible and possible[1][0] == u:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[1][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while possible and possible[0][0] == u:",
      "mutated_line": "while possible and possible[-1][0] == u:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[-1][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while possible and possible[0][0] == u:",
      "mutated_line": "while possible and possible[1][0] == u:",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[1][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-2] + pascal[-1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-2] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-0] + pascal[-1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-0] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-0] + pascal[-1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-0] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[--1] + pascal[-1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[--1] + pascal[-1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-1] + pascal[+1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[+1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-1] + pascal[-2][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-2][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-1] + pascal[-0][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-0][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-1] + pascal[-0][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[-0][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "newrow.append(newrow[-1] + pascal[-1][j])",
      "mutated_line": "newrow.append(newrow[-1] + pascal[--1][j])",
      "code": "def calculate_minimum_alphabet_cost(n, c_0, c_1):\n    \"\"\"\n    Calculate the minimum possible total cost of encoding an alphabet with n letters,\n    where each letter is represented by a sequence of '0' and '1', and no letter's\n    sequence is a prefix of another letter's sequence. The costs for '0' and '1'\n    are given by c_0 and c_1 respectively.\n\n    Parameters:\n    - n (int): The number of letters in the alphabet.\n    - c_0 (int): The cost of each '0' in the alphabet.\n    - c_1 (int): The cost of each '1' in the alphabet.\n\n    Returns:\n    - int: The minimum possible total cost of the whole alphabet.\n    \"\"\"\n    if c_0 < c_1:\n        (c_0, c_1) = (c_1, c_0)\n    if c_1 == 0:\n        return (n - 1) * c_0\n    pascal = [[1] * 20005]\n    for i in range(20004):\n        newrow = [1]\n        for j in range(1, 20005):\n            newrow.append(newrow[-1] + pascal[--1][j])\n            if newrow[-1] > n:\n                break\n        pascal.append(newrow)\n\n    def getcom(a, b):\n        if len(pascal[a]) > b:\n            return pascal[a][b]\n        if b == 0:\n            return 1\n        if b == 1:\n            return a\n        return 100000005\n    remain = n - 1\n    ans = 0\n    possible = [[c_0 + c_1, 1]]\n    while True:\n        (u, v) = heapq.heappop(possible)\n        while possible and possible[0][0] == u:\n            v += possible[0][1]\n            heapq.heappop(possible)\n        if remain <= v:\n            ans += u * remain\n            break\n        ans += u * v\n        remain -= v\n        heapq.heappush(possible, [u + c_0, v])\n        heapq.heappush(possible, [u + c_1, v])\n    return ans"
    }
  ]
}