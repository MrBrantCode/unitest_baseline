{
  "task_id": "taco_17593",
  "entry_point": "max_knapsack_value",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] / (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] / (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] + (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] + (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] ** (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] ** (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 1\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = -1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = -1\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 1\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ms[i] -= c",
      "mutated_line": "ms[i] += c",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] += c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 1\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = -1\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 1\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] * (V - 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V - 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] * (V * 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V * 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[1] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[-1] = 0",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[-1] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[1] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vs = [item[0] for item in items]",
      "mutated_line": "vs = [item[1] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[1] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vs = [item[0] for item in items]",
      "mutated_line": "vs = [item[-1] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[-1] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vs = [item[0] for item in items]",
      "mutated_line": "vs = [item[1] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[1] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ws = [item[1] for item in items]",
      "mutated_line": "ws = [item[2] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[2] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ws = [item[1] for item in items]",
      "mutated_line": "ws = [item[0] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[0] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ws = [item[1] for item in items]",
      "mutated_line": "ws = [item[0] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[0] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ws = [item[1] for item in items]",
      "mutated_line": "ws = [item[-1] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[-1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ms = [item[2] for item in items]",
      "mutated_line": "ms = [item[3] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[3] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ms = [item[2] for item in items]",
      "mutated_line": "ms = [item[1] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[1] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ms = [item[2] for item in items]",
      "mutated_line": "ms = [item[0] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[0] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ms = [item[2] for item in items]",
      "mutated_line": "ms = [item[1] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[1] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ms = [item[2] for item in items]",
      "mutated_line": "ms = [item[-2] for item in items]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[-2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))",
      "mutated_line": "V = sum((v / min(V0, m) for (v, m) in zip(vs, ms)))",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v / min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))",
      "mutated_line": "V = sum((v + min(V0, m) for (v, m) in zip(vs, ms)))",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v + min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))",
      "mutated_line": "V = sum((v ** min(V0, m) for (v, m) in zip(vs, ms)))",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v ** min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W - 1] * (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W - 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W * 1] * (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W * 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] * (V + 2)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 2)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] * (V + 0)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 0)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] * (V + 0)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 0)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 1] * (V + -1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + -1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "yield 0",
      "mutated_line": "yield 1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 1\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "yield 0",
      "mutated_line": "yield -1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield -1\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "yield 0",
      "mutated_line": "yield 1",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 1\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(V + 1):",
      "mutated_line": "for i in range(V - 1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V - 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for i in range(V + 1):",
      "mutated_line": "for i in range(V * 1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V * 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if dp[i] > W:",
      "mutated_line": "if dp[i] >= W:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] >= W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if dp[i] > W:",
      "mutated_line": "if dp[i] <= W:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] <= W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if dp[i] > W:",
      "mutated_line": "if dp[i] != W:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] != W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rest = W - dp[i]",
      "mutated_line": "rest = W + dp[i]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W + dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "rest = W - dp[i]",
      "mutated_line": "rest = W * dp[i]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W * dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "r += m * v",
      "mutated_line": "r -= m * v",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r -= m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "rest -= m * w",
      "mutated_line": "rest += m * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest += m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 2] * (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 2] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 0] * (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 0] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + 0] * (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 0] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dp = [W + 1] * (V + 1)",
      "mutated_line": "dp = [W + -1] * (V + 1)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + -1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V - k) // v - 1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v - 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V - k) // v * 1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v * 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k + j * v] + j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] + j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k + j * v] * (j * w)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] * (j * w)\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que or a <= que[-1][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que or a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k + j * v] = b - j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b - j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k + j * v] = b * (j * w)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b * (j * w)\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if que and p <= j - c:",
      "mutated_line": "if que or p <= j - c:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que or p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "I.sort(key=lambda x: ws[x] / vs[x])",
      "mutated_line": "I.sort(key=lambda x: ws[x] * vs[x])",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] * vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "I.sort(key=lambda x: ws[x] / vs[x])",
      "mutated_line": "I.sort(key=lambda x: ws[x] // vs[x])",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] // vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(V + 1):",
      "mutated_line": "for i in range(V + 2):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 2):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(V + 1):",
      "mutated_line": "for i in range(V + 0):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 0):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(V + 1):",
      "mutated_line": "for i in range(V + 0):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 0):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for i in range(V + 1):",
      "mutated_line": "for i in range(V + -1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + -1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "r += m * v",
      "mutated_line": "r += m / v",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m / v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "r += m * v",
      "mutated_line": "r += m + v",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m + v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "r += m * v",
      "mutated_line": "r += m ** v",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m ** v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "rest -= m * w",
      "mutated_line": "rest -= m / w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m / w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "rest -= m * w",
      "mutated_line": "rest -= m + w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m + w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "rest -= m * w",
      "mutated_line": "rest -= m ** w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m ** w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V - k) / v + 1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) / v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V - k) * v + 1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) * v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V - k) // v + 2):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 2):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V - k) // v + 0):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 0):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V - k) // v + 0):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 0):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V - k) // v + -1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + -1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k + j * v] - j / w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j / w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k + j * v] - (j + w)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - (j + w)\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k + j * v] - j ** w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j ** w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a < que[-1][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a < que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a > que[-1][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a > que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a == que[-1][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a == que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(p, b) = que[0]",
      "mutated_line": "(p, b) = que[1]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[1]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(p, b) = que[0]",
      "mutated_line": "(p, b) = que[-1]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[-1]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(p, b) = que[0]",
      "mutated_line": "(p, b) = que[1]",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[1]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k - j * v] = b + j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k - j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k * (j * v)] = b + j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k * (j * v)] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k + j * v] = b + j / w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j / w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k + j * v] = b + (j + w)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + (j + w)\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k + j * v] = b + j ** w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j ** w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if que and p <= j - c:",
      "mutated_line": "if que and p < j - c:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p < j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if que and p <= j - c:",
      "mutated_line": "if que and p > j - c:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p > j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if que and p <= j - c:",
      "mutated_line": "if que and p == j - c:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p == j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "m = min(m, rest // w)",
      "mutated_line": "m = min(m, rest / w)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest / w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "m = min(m, rest // w)",
      "mutated_line": "m = min(m, rest * w)",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest * w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range((V + k) // v + 1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V + k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range((V - k) // v + 1):",
      "mutated_line": "for j in range(V * k // v + 1):",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range(V * k // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k - j * v] - j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k - j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k * (j * v)] - j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k * (j * v)] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k + j / v] = b + j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j / v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k + (j + v)] = b + j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + (j + v)] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[k + j * v] = b + j * w",
      "mutated_line": "dp[k + j ** v] = b + j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j ** v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if que and p <= j - c:",
      "mutated_line": "if que and p <= j + c:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j + c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if que and p <= j - c:",
      "mutated_line": "if que and p <= j * c:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j * c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k + j / v] - j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j / v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k + (j + v)] - j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + (j + v)] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "a = dp[k + j * v] - j * w",
      "mutated_line": "a = dp[k + j ** v] - j * w",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j ** v] - j * w\n                while que and a <= que[-1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[-1][2]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][2]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[-1][0]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][0]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[-1][0]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][0]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[-1][-1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-1][-1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[+1][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[+1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[-2][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-2][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[-0][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-0][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[-0][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[-0][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while que and a <= que[-1][1]:",
      "mutated_line": "while que and a <= que[--1][1]:",
      "code": "import sys\nfrom collections import deque\n\ndef max_knapsack_value(N, W, items):\n    vs = [item[0] for item in items]\n    ws = [item[1] for item in items]\n    ms = [item[2] for item in items]\n    V0 = max(vs)\n    V = sum((v * min(V0, m) for (v, m) in zip(vs, ms)))\n    dp = [W + 1] * (V + 1)\n    dp[0] = 0\n    for i in range(N):\n        v = vs[i]\n        w = ws[i]\n        m = ms[i]\n        c = min(V0, m)\n        ms[i] -= c\n        for k in range(v):\n            que = deque()\n            push = que.append\n            popf = que.popleft\n            popb = que.pop\n            for j in range((V - k) // v + 1):\n                a = dp[k + j * v] - j * w\n                while que and a <= que[--1][1]:\n                    popb()\n                push((j, a))\n                (p, b) = que[0]\n                dp[k + j * v] = b + j * w\n                if que and p <= j - c:\n                    popf()\n    I = list(range(N))\n    I.sort(key=lambda x: ws[x] / vs[x])\n    S = [(vs[i], ws[i], ms[i]) for i in I]\n    ans = 0\n\n    def greedy():\n        yield 0\n        for i in range(V + 1):\n            if dp[i] > W:\n                continue\n            rest = W - dp[i]\n            r = i\n            for (v, w, m) in S:\n                m = min(m, rest // w)\n                r += m * v\n                rest -= m * w\n            yield r\n    return max(greedy())"
    }
  ]
}