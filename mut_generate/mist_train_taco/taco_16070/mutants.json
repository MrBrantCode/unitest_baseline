{
  "task_id": "taco_16070",
  "entry_point": "calculate_reviews",
  "mutant_count": 146,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 1\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "p = 0",
      "mutated_line": "p = -1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = -1\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 1\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] / (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] / (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] + (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] + (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] ** (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] ** (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] / (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] / (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] + (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] + (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] ** (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] ** (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] / (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] / (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] + (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] + (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] ** (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] ** (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "root = 0",
      "mutated_line": "root = 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 1\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "root = 0",
      "mutated_line": "root = -1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = -1\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "root = 0",
      "mutated_line": "root = 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 1\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 1\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = -1\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 1\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "memo[x] = 0",
      "mutated_line": "memo[x] = 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 1\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "memo[x] = 0",
      "mutated_line": "memo[x] = -1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = -1\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "memo[x] = 0",
      "mutated_line": "memo[x] = 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 1\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = True\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "while memo[i] >= memo[j] and not found:",
      "mutated_line": "while memo[i] >= memo[j] or not found:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] or not found:\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if superior_list[i] == 0:",
      "mutated_line": "if superior_list[i] != 0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] != 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if memo[x] - memo[y] > 0:",
      "mutated_line": "if memo[x] - memo[y] >= 0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] >= 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if memo[x] - memo[y] > 0:",
      "mutated_line": "if memo[x] - memo[y] <= 0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] <= 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if memo[x] - memo[y] > 0:",
      "mutated_line": "if memo[x] - memo[y] != 0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] != 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] * (n - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n - 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] * (n * 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n * 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] * (n - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n - 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] * (n * 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n * 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] * (n - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n - 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] * (n * 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n * 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b[top] = True",
      "mutated_line": "b[top] = False",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = False\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while memo[i] >= memo[j] and not found:",
      "mutated_line": "while memo[i] > memo[j] and (not found):",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] > memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while memo[i] >= memo[j] and not found:",
      "mutated_line": "while memo[i] < memo[j] and (not found):",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] < memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while memo[i] >= memo[j] and not found:",
      "mutated_line": "while memo[i] == memo[j] and (not found):",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] == memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if j == component_id[i]:",
      "mutated_line": "if j != component_id[i]:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j != component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if superior_list[i] == 0:",
      "mutated_line": "if superior_list[i] == 1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 1:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if superior_list[i] == 0:",
      "mutated_line": "if superior_list[i] == -1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == -1:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if superior_list[i] == 0:",
      "mutated_line": "if superior_list[i] == 1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 1:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "p = i + 1",
      "mutated_line": "p = i - 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i - 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "p = i + 1",
      "mutated_line": "p = i * 1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i * 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "G[superior_list[i]].append(i + 1)",
      "mutated_line": "G[superior_list[i]].append(i - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i - 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "G[superior_list[i]].append(i + 1)",
      "mutated_line": "G[superior_list[i]].append(i * 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i * 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if memo[x] - memo[y] > 0:",
      "mutated_line": "if memo[x] + memo[y] > 0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] + memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if memo[x] - memo[y] > 0:",
      "mutated_line": "if memo[x] * memo[y] > 0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] * memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if memo[x] - memo[y] > 0:",
      "mutated_line": "if memo[x] - memo[y] > 1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 1:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if memo[x] - memo[y] > 0:",
      "mutated_line": "if memo[x] - memo[y] > -1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > -1:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if memo[x] - memo[y] > 0:",
      "mutated_line": "if memo[x] - memo[y] > 1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 1:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if root == n - 1:",
      "mutated_line": "if root != n - 1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root != n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [True] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [True] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] * (n + 2)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 2)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] * (n + 0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 0)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] * (n + 0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 0)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)",
      "mutated_line": "b = [False] * (n + -1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + -1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [+2] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [+2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] * (n + 2)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 2)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] * (n + 0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 0)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] * (n + 0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 0)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-2] * (n + -1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + -1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [+2] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [+2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] * (n + 2)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 2)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] * (n + 0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 0)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] * (n + 0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 0)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-2] * (n + -1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + -1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if memo[j] == -2:",
      "mutated_line": "if memo[j] != -2:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] != -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = False\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n - 1)]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n - 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n * 1)]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n * 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p = i + 1",
      "mutated_line": "p = i + 2",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 2\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p = i + 1",
      "mutated_line": "p = i + 0",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 0\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p = i + 1",
      "mutated_line": "p = i + 0",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 0\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p = i + 1",
      "mutated_line": "p = i + -1",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + -1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "G[superior_list[i]].append(i + 1)",
      "mutated_line": "G[superior_list[i]].append(i + 2)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 2)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "G[superior_list[i]].append(i + 1)",
      "mutated_line": "G[superior_list[i]].append(i + 0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 0)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "G[superior_list[i]].append(i + 1)",
      "mutated_line": "G[superior_list[i]].append(i + 0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 0)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "G[superior_list[i]].append(i + 1)",
      "mutated_line": "G[superior_list[i]].append(i + -1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + -1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if root == n - 1:",
      "mutated_line": "if root == n + 1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n + 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "if root == n - 1:",
      "mutated_line": "if root == n * 1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n * 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(+1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-3] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-3] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-1] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-1] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-0] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-0] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [-1] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-1] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [-2] * (n + 1)",
      "mutated_line": "memo = [--2] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [--2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-3] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-3] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-1] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-1] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-0] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-0] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [-1] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-1] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "component_id = [-2] * (n + 1)",
      "mutated_line": "component_id = [--2] * (n + 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [--2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "if memo[j] == -2:",
      "mutated_line": "if memo[j] == +2:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == +2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo[j] = 1 + memo[top]",
      "mutated_line": "memo[j] = 1 - memo[top]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 - memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo[j] = 1 + memo[top]",
      "mutated_line": "memo[j] = 1 * memo[top]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 * memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if root < memo[j]:",
      "mutated_line": "if root <= memo[j]:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root <= memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if root < memo[j]:",
      "mutated_line": "if root >= memo[j]:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root >= memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if root < memo[j]:",
      "mutated_line": "if root != memo[j]:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root != memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "b[j] = True",
      "mutated_line": "b[j] = False",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = False\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n + 2)]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 2)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n + 0)]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 0)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n + 0)]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 0)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n + -1)]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + -1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "G[i + 1].append(superior_list[i])",
      "mutated_line": "G[i - 1].append(superior_list[i])",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i - 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "G[i + 1].append(superior_list[i])",
      "mutated_line": "G[i * 1].append(superior_list[i])",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i * 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if root == n - 1:",
      "mutated_line": "if root == n - 2:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 2:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if root == n - 1:",
      "mutated_line": "if root == n - 0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 0:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if root == n - 1:",
      "mutated_line": "if root == n - 0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 0:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if root == n - 1:",
      "mutated_line": "if root == n - -1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - -1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(memo[x] - memo[y] - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] + 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(memo[x] - memo[y] - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append((memo[x] - memo[y]) * 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(--1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if memo[j] == -2:",
      "mutated_line": "if memo[j] == -3:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -3:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if memo[j] == -2:",
      "mutated_line": "if memo[j] == -1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -1:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if memo[j] == -2:",
      "mutated_line": "if memo[j] == -0:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -0:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if memo[j] == -2:",
      "mutated_line": "if memo[j] == -1:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -1:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if memo[j] == -2:",
      "mutated_line": "if memo[j] == --2:",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == --2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo[j] = 1 + memo[top]",
      "mutated_line": "memo[j] = 2 + memo[top]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 2 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo[j] = 1 + memo[top]",
      "mutated_line": "memo[j] = 0 + memo[top]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 0 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo[j] = 1 + memo[top]",
      "mutated_line": "memo[j] = 0 + memo[top]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 0 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo[j] = 1 + memo[top]",
      "mutated_line": "memo[j] = -1 + memo[top]",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = -1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "G[i + 1].append(superior_list[i])",
      "mutated_line": "G[i + 2].append(superior_list[i])",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 2].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "G[i + 1].append(superior_list[i])",
      "mutated_line": "G[i + 0].append(superior_list[i])",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 0].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "G[i + 1].append(superior_list[i])",
      "mutated_line": "G[i + 0].append(superior_list[i])",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 0].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "G[i + 1].append(superior_list[i])",
      "mutated_line": "G[i + -1].append(superior_list[i])",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + -1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(memo[x] - memo[y] - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] + memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(memo[x] - memo[y] - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] * memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(memo[x] - memo[y] - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 2)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(memo[x] - memo[y] - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 0)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(memo[x] - memo[y] - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 0)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(memo[x] - memo[y] - 1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - -1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] + 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append((memo[x] - memo[y]) * 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(+1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] + memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] * memo[y] - 1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 2)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 0)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 0)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "results.append(memo[x] - memo[y] - 1)",
      "mutated_line": "results.append(-1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - -1)\n            else:\n                results.append(-1)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-2)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-0)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(-0)\n        else:\n            results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "def calculate_reviews(n, superior_list, queries):\n\n    def bfs(x):\n        b = [False] * (n + 1)\n        memo = [-2] * (n + 1)\n        component_id = [-2] * (n + 1)\n        root = 0\n        c = 0\n        q = []\n        q.append(x)\n        component_id[x] = c\n        memo[x] = 0\n        while q:\n            top = q.pop()\n            b[top] = True\n            for j in G[top]:\n                if memo[j] == -2:\n                    memo[j] = 1 + memo[top]\n                    if root < memo[j]:\n                        root = memo[j]\n                    b[j] = True\n                    q.append(j)\n                    component_id[j] = top\n        return (memo, component_id, root)\n\n    def trail(i, j, memo, component_id):\n        found = False\n        while memo[i] >= memo[j] and (not found):\n            if j == component_id[i]:\n                found = True\n            i = component_id[i]\n        return found\n    G = [[] for _ in range(n + 1)]\n    p = 0\n    for i in range(n):\n        if superior_list[i] == 0:\n            p = i + 1\n        G[i + 1].append(superior_list[i])\n        G[superior_list[i]].append(i + 1)\n    (memo, component_id, root) = bfs(p)\n    results = []\n    for (x, y) in queries:\n        if memo[x] - memo[y] > 0:\n            if root == n - 1:\n                results.append(memo[x] - memo[y] - 1)\n            elif trail(x, y, memo, component_id):\n                results.append(memo[x] - memo[y] - 1)\n            else:\n                results.append(--1)\n        else:\n            results.append(-1)\n    return results"
    }
  ]
}