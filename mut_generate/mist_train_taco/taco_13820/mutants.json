{
  "task_id": "taco_13820",
  "entry_point": "count_possible_walls",
  "mutant_count": 107,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "ans += mod - 1",
      "mutated_line": "ans -= mod - 1",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans -= mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 6 - 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 - 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 6 * 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 * 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 2\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 0\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 0\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = -1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans += mod - 1",
      "mutated_line": "ans += mod + 1",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod + 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans += mod - 1",
      "mutated_line": "ans += mod * 1",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod * 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 * 6 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 * 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 + 6 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 + 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 6 + 4",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 4\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 6 + 2",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 2\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 6 + 0",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 0\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 6 + 1",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 1\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 6 + -3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + -3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [1, 1]",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [1, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [-1, 1]",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [-1, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [1, 1]",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [1, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 2]",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 2]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 0]",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 0]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 0]",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 0]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, -1]",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, -1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(3, max(n, C) + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(3, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(1, max(n, C) + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(1, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(0, max(n, C) + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(0, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(1, max(n, C) + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(1, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(-2, max(n, C) + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(-2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(2, max(n, C) - 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) - 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(2, max(n, C) * 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) * 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(2, n + C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(2, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(0, n + C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(0, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(0, n + C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(0, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(-1, n + C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(-1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(1, n + C - 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C - 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(1, (n + C) * 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, (n + C) * 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = ans * i % mod",
      "mutated_line": "ans = ans * i * mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i * mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = ans * i % mod",
      "mutated_line": "ans = ans * i + mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i + mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(2, C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(2, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(0, C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(0, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(0, C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(0, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(-1, C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(-1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C - 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C - 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C * 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C * 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = ans * inv[i] * mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] * mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = ans * inv[i] + mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] + mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(2, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(0, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(0, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(-1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n - 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n * 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = ans * inv[i] * mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] * mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = ans * inv[i] + mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] + mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += mod - 1",
      "mutated_line": "ans += mod - 2",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 2\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += mod - 1",
      "mutated_line": "ans += mod - 0",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 0\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += mod - 1",
      "mutated_line": "ans += mod - 0",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 0\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += mod - 1",
      "mutated_line": "ans += mod - -1",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - -1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 11 ** 6 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 11 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 9 ** 6 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 9 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 0 ** 6 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 0 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 1 ** 6 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 1 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = -10 ** 6 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = -10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 7 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 7 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 5 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 5 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 0 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 0 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** 1 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 1 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mod = 10 ** 6 + 3",
      "mutated_line": "mod = 10 ** -6 + 3",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** -6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(2, max(n, C) + 2):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 2):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(2, max(n, C) + 0):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 0):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(2, max(n, C) + 0):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 0):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(2, max(n, C) + 1):",
      "mutated_line": "for i in range(2, max(n, C) + -1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + -1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod % i] * (mod - mod // i) * mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) * mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod % i] * (mod - mod // i) + mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) + mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(1, n - C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n - C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(1, n * C + 1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n * C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(1, n + C + 2):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 2):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(1, n + C + 0):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 0):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(1, n + C + 0):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 0):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + C + 1):",
      "mutated_line": "for i in range(1, n + C + -1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + -1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = ans * i % mod",
      "mutated_line": "ans = ans / i % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans / i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = ans * i % mod",
      "mutated_line": "ans = (ans + i) % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = (ans + i) % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = ans * i % mod",
      "mutated_line": "ans = ans ** i % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans ** i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C + 2):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 2):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C + 0):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 0):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C + 0):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 0):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for i in range(1, C + 1):",
      "mutated_line": "for i in range(1, C + -1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + -1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = ans / inv[i] % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans / inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = (ans + inv[i]) % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = (ans + inv[i]) % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = ans ** inv[i] % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans ** inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 2):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 0):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 0):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + -1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = ans / inv[i] % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans / inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = (ans + inv[i]) % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = (ans + inv[i]) % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ans = ans * inv[i] % mod",
      "mutated_line": "ans = ans ** inv[i] % mod",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans ** inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod % i] / (mod - mod // i) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] / (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append((inv[mod % i] + (mod - mod // i)) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append((inv[mod % i] + (mod - mod // i)) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod % i] ** (mod - mod // i) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] ** (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod % i] * (mod + mod // i) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod + mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod % i] * (mod * (mod // i)) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod * (mod // i)) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod * i] * (mod - mod // i) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod * i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod + i] * (mod - mod // i) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod + i] * (mod - mod // i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod % i] * (mod - mod / i) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod / i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv.append(inv[mod % i] * (mod - mod // i) % mod)",
      "mutated_line": "inv.append(inv[mod % i] * (mod - mod * i) % mod)",
      "code": "def count_possible_walls(n: int, C: int) -> int:\n    \"\"\"\n    Calculate the number of different walls that can be constructed with up to n bricks and width C,\n    modulo 10^6 + 3.\n\n    Parameters:\n    n (int): The maximum number of bricks available.\n    C (int): The width of the wall.\n\n    Returns:\n    int: The number of different walls modulo 10^6 + 3.\n    \"\"\"\n    mod = 10 ** 6 + 3\n    inv = [0, 1]\n    for i in range(2, max(n, C) + 1):\n        inv.append(inv[mod % i] * (mod - mod * i) % mod)\n    ans = 1\n    for i in range(1, n + C + 1):\n        ans = ans * i % mod\n    for i in range(1, C + 1):\n        ans = ans * inv[i] % mod\n    for i in range(1, n + 1):\n        ans = ans * inv[i] % mod\n    ans += mod - 1\n    ans %= mod\n    return ans"
    }
  ]
}