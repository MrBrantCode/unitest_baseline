{
  "task_id": "taco_613",
  "entry_point": "construct_sequence",
  "mutant_count": 113,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if K == 0:",
      "mutated_line": "if K != 0:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K != 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if K == 0:",
      "mutated_line": "if K == 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 1:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if K == 0:",
      "mutated_line": "if K == -1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == -1:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if K == 0:",
      "mutated_line": "if K == 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 1:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 ** M and M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M and M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i / 2 for i in range(2 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i / 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i * 2 for i in range(2 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i * 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K > 2 ** M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K > 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K < 2 ** M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K < 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K == 2 ** M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K == 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 ** M or M < 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M < 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 ** M or M > 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M > 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 ** M or M == 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M == 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return +1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return a + b",
      "mutated_line": "return a - b",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a - b"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return a + b",
      "mutated_line": "return a * b",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a * b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 3 for i in range(2 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 3 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 1 for i in range(2 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 1 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 0 for i in range(2 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 0 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 1 for i in range(2 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 1 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // -2 for i in range(2 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // -2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 * M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 * M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 + M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 + M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 ** M or M <= 2:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 2:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 ** M or M <= 0:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 0:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 ** M or M <= 0:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 0:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 2 ** M or M <= -1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= -1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -2\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -0\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -0\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return --1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(2 ** M):",
      "mutated_line": "for i in range(2 * M):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 * M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(2 ** M):",
      "mutated_line": "for i in range(2 + M):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 + M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i != K:",
      "mutated_line": "if i == K:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i == K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(2, 2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(2, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(0, 2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(0, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(0, 2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(0, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(-1, 2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(-1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M + 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M + 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M * 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M * 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(2, 2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(2, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(0, 2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(0, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(0, 2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(0, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(-1, 2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(-1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M + 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M + 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M * 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M * 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(2 * (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 * (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(2 + (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 + (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 3 ** M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 3 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 1 ** M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 1 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 0 ** M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 0 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= 1 ** M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 1 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "elif K >= 2 ** M or M <= 1:",
      "mutated_line": "elif K >= -2 ** M or M <= 1:",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= -2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2 ** M):",
      "mutated_line": "for i in range(3 ** M):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(3 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2 ** M):",
      "mutated_line": "for i in range(1 ** M):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(1 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2 ** M):",
      "mutated_line": "for i in range(0 ** M):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(0 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2 ** M):",
      "mutated_line": "for i in range(1 ** M):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(1 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(2 ** M):",
      "mutated_line": "for i in range(-2 ** M):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(-2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "a = [nums[0], K, nums[0]]",
      "mutated_line": "a = [nums[1], K, nums[0]]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[1], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "a = [nums[0], K, nums[0]]",
      "mutated_line": "a = [nums[-1], K, nums[0]]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[-1], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "a = [nums[0], K, nums[0]]",
      "mutated_line": "a = [nums[1], K, nums[0]]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[1], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "a = [nums[0], K, nums[0]]",
      "mutated_line": "a = [nums[0], K, nums[1]]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[1]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "a = [nums[0], K, nums[0]]",
      "mutated_line": "a = [nums[0], K, nums[-1]]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[-1]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "a = [nums[0], K, nums[0]]",
      "mutated_line": "a = [nums[0], K, nums[1]]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[1]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 * M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 * M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 + M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 + M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M - 2):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 2):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M - 0):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 0):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M - 0):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 0):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M - -1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - -1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 * M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 * M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 + M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 + M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M - 2):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 2):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M - 0):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 0):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M - 0):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 0):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 2 ** M - -1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - -1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(3 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(3 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(1 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(1 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(0 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(0 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(1 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(1 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(-2 ** (M + 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(-2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(2 ** (M - 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M - 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(2 ** (M * 1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M * 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 3 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 3 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 1 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 1 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 0 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 0 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 1 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 1 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, -2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, -2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 3 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 3 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 1 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 1 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 0 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 0 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, 1 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 1 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, 2 ** M - 1):",
      "mutated_line": "for i in range(1, -2 ** M - 1):",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, -2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 ** M - 1 + i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 + i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[(2 ** M - 1) * i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[(2 ** M - 1) * i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(2 ** (M + 2))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 2))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(2 ** (M + 0))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 0))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(2 ** (M + 0))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 0))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return [i // 2 for i in range(2 ** (M + 1))]",
      "mutated_line": "return [i // 2 for i in range(2 ** (M + -1))]",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + -1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 ** M + 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M + 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 ** M * 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M * 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 * M - 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 * M - 1 - i])\n        return a + b"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 + M - 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 + M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 ** M - 2 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 2 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 ** M - 0 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 0 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 ** M - 0 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - 0 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[2 ** M - -1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[2 ** M - -1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[3 ** M - 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[3 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[1 ** M - 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[1 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[0 ** M - 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[0 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[1 ** M - 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[1 ** M - 1 - i])\n        return a + b"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b.append(nums[2 ** M - 1 - i])",
      "mutated_line": "b.append(nums[-2 ** M - 1 - i])",
      "code": "def construct_sequence(M: int, K: int) -> list:\n    \"\"\"\n    Constructs a sequence a of length 2^(M + 1) that satisfies the given conditions, if such a sequence exists.\n\n    Parameters:\n    - M (int): The exponent used to determine the range of integers in the sequence.\n    - K (int): The value used to check the XOR condition.\n\n    Returns:\n    - list: A list representing the sequence a if it exists, or -1 if no such sequence exists.\n    \"\"\"\n    if K == 0:\n        return [i // 2 for i in range(2 ** (M + 1))]\n    elif K >= 2 ** M or M <= 1:\n        return -1\n    else:\n        nums = []\n        for i in range(2 ** M):\n            if i != K:\n                nums.append(i)\n        a = [nums[0], K, nums[0]]\n        b = []\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[i])\n        b.append(K)\n        for i in range(1, 2 ** M - 1):\n            b.append(nums[-2 ** M - 1 - i])\n        return a + b"
    }
  ]
}