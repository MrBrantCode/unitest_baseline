{
  "task_id": "taco_780",
  "entry_point": "max_union_segments_after_removal",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 1\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = -1\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 1\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] / (n + 1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] / (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] + (n + 1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] + (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] ** (n + 1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] ** (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if max(seq) == 1:",
      "mutated_line": "if max(seq) != 1:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) != 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] * (n - 1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n - 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] * (n * 1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n * 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if p == 0:",
      "mutated_line": "if p != 0:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p != 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if max(seq) == 1:",
      "mutated_line": "if max(seq) == 2:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 2:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if max(seq) == 1:",
      "mutated_line": "if max(seq) == 0:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 0:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if max(seq) == 1:",
      "mutated_line": "if max(seq) == 0:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 0:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if max(seq) == 1:",
      "mutated_line": "if max(seq) == -1:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == -1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return ans - 1",
      "mutated_line": "return ans + 1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans + 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return ans - 1",
      "mutated_line": "return ans * 1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans * 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return ans + max(increase)",
      "mutated_line": "return ans - max(increase)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans - max(increase)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return ans + max(increase)",
      "mutated_line": "return ans * max(increase)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans * max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [1] * (n + 1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [1] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [-1] * (n + 1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [-1] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [1] * (n + 1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [1] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] * (n + 2)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 2)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] * (n + 0)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 0)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] * (n + 0)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 0)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "increase = [0] * (n + 1)",
      "mutated_line": "increase = [0] * (n + -1)",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + -1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0:",
      "mutated_line": "if p == 1:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 1:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0:",
      "mutated_line": "if p == -1:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == -1:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if p == 0:",
      "mutated_line": "if p == 1:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 1:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 or seq[-2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 or seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "increase[next(iter(active))] += 1",
      "mutated_line": "increase[next(iter(active))] -= 1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] -= 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if len(active) == 0:",
      "mutated_line": "if len(active) != 0:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) != 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans -= 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans - 1",
      "mutated_line": "return ans - 2",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 2\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans - 1",
      "mutated_line": "return ans - 0",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 0\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans - 1",
      "mutated_line": "return ans - 0",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 0\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return ans - 1",
      "mutated_line": "return ans - -1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - -1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "seg.append((l, 0, i))",
      "mutated_line": "seg.append((l, 1, i))",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 1, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "seg.append((l, 0, i))",
      "mutated_line": "seg.append((l, -1, i))",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, -1, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "seg.append((l, 0, i))",
      "mutated_line": "seg.append((l, 1, i))",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 1, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "seg.append((r, 1, i))",
      "mutated_line": "seg.append((r, 2, i))",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 2, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "seg.append((r, 1, i))",
      "mutated_line": "seg.append((r, 0, i))",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 0, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "seg.append((r, 1, i))",
      "mutated_line": "seg.append((r, 0, i))",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 0, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "seg.append((r, 1, i))",
      "mutated_line": "seg.append((r, -1, i))",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, -1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) >= 1 and seq[-2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) >= 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) <= 1 and seq[-2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) <= 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) != 1 and seq[-2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) != 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] != [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] != [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "increase[next(iter(active))] += 1",
      "mutated_line": "increase[next(iter(active))] += 2",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 2\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "increase[next(iter(active))] += 1",
      "mutated_line": "increase[next(iter(active))] += 0",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 0\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "increase[next(iter(active))] += 1",
      "mutated_line": "increase[next(iter(active))] += 0",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 0\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "increase[next(iter(active))] += 1",
      "mutated_line": "increase[next(iter(active))] += -1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += -1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if len(active) == 0:",
      "mutated_line": "if len(active) == 1:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 1:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if len(active) == 0:",
      "mutated_line": "if len(active) == -1:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == -1:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if len(active) == 0:",
      "mutated_line": "if len(active) == 1:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 1:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 2\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 0\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 0\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += -1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 2 and seq[-2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 2 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 0 and seq[-2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 0 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 0 and seq[-2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 0 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > -1 and seq[-2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > -1 and seq[-2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [3, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [3, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [1, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [1, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [0, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [0, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [1, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [1, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [-2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [-2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [2, 2]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 2]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [2, 0]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 0]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [2, 0]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, 0]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-2:] == [2, -1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-2:] == [2, -1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[+2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[+2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-3:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-3:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-1:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-1:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-0:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-0:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[-1:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[-1:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(seq) > 1 and seq[-2:] == [2, 1]:",
      "mutated_line": "if len(seq) > 1 and seq[--2:] == [2, 1]:",
      "code": "def max_union_segments_after_removal(segments):\n    \"\"\"\n    Calculate the maximum number of segments in the union of n-1 segments after removing one segment.\n\n    Parameters:\n    segments (list of tuples): A list of segments where each segment is represented as a tuple (l, r).\n\n    Returns:\n    int: The maximum number of segments in the union of n-1 segments after removing one segment.\n    \"\"\"\n    n = len(segments)\n    seg = []\n    for i in range(n):\n        (l, r) = segments[i]\n        seg.append((l, 0, i))\n        seg.append((r, 1, i))\n    seg.sort()\n    ans = 0\n    seq = []\n    active = set()\n    increase = [0] * (n + 1)\n    for (pos, p, i) in seg:\n        if p == 0:\n            if len(seq) > 1 and seq[--2:] == [2, 1]:\n                increase[next(iter(active))] += 1\n            active.add(i)\n        else:\n            active.remove(i)\n            if len(active) == 0:\n                ans += 1\n        seq.append(len(active))\n    if max(seq) == 1:\n        return ans - 1\n    else:\n        return ans + max(increase)"
    }
  ]
}