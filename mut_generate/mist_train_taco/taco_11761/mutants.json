{
  "task_id": "taco_11761",
  "entry_point": "adjust_min_cost_path",
  "mutant_count": 124,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 or m == 0 or c == 0:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 or m == 0 or c == 0:\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 * 18",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 * 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 + 18",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 + 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][0] = 1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 1\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][0] = -1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = -1\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][0] = 1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 1\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return -1  # In case no valid solution is found, though the problem guarantees one.",
      "mutated_line": "return +1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n != 0 and m == 0 and (c == 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n != 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 and m != 0 and (c == 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m != 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 and m == 0 and (c != 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c != 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 1\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return -1\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 1\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 11 ** 18",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 11 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 9 ** 18",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 9 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 0 ** 18",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 0 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 1 ** 18",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 1 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = -10 ** 18",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = -10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 19",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 19\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 17",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 17\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 0\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 1\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** -18",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** -18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] / (n + 1) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] / (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] + (n + 1) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] + (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] ** (n + 1) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] ** (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][1] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][1] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][-1] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][-1] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[0][1] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][1] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if dist[v][k] < cost:",
      "mutated_line": "if dist[v][k] <= cost:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] <= cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if dist[v][k] < cost:",
      "mutated_line": "if dist[v][k] >= cost:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] >= cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if dist[v][k] < cost:",
      "mutated_line": "if dist[v][k] != cost:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] != cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for k in range(n + 1):",
      "mutated_line": "for k in range(n - 1):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n - 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for k in range(n + 1):",
      "mutated_line": "for k in range(n * 1):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n * 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n - 1][k] < c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] < c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n - 1][k] > c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] > c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n - 1][k] == c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] == c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1  # In case no valid solution is found, though the problem guarantees one.",
      "mutated_line": "return -2",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1  # In case no valid solution is found, though the problem guarantees one.",
      "mutated_line": "return -0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1  # In case no valid solution is found, though the problem guarantees one.",
      "mutated_line": "return -0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1  # In case no valid solution is found, though the problem guarantees one.",
      "mutated_line": "return --1",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 1 and m == 0 and (c == 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 1 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == -1 and m == 0 and (c == 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == -1 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 1 and m == 0 and (c == 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 1 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 and m == 1 and (c == 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 1 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 and m == -1 and (c == 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == -1 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 and m == 1 and (c == 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 1 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 and m == 0 and (c == 1):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 1):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 and m == 0 and (c == -1):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == -1):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n == 0 and m == 0 and c == 0:",
      "mutated_line": "if n == 0 and m == 0 and (c == 1):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 1):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] * (n - 1) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n - 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] * (n * 1) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n * 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(1, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(1, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(-1, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(-1, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(1, 0, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(1, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(0, 1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 1, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(0, -1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, -1, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(0, 1, 0)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 1, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(0, 0, 1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 1)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(0, 0, -1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, -1)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "que = [(0, 0, 0)]",
      "mutated_line": "que = [(0, 0, 1)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 1)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[1][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[1][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[-1][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[-1][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dist[0][0] = 0",
      "mutated_line": "dist[1][0] = 0",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[1][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cost + d < dist[w][k]:",
      "mutated_line": "if cost + d <= dist[w][k]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d <= dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cost + d < dist[w][k]:",
      "mutated_line": "if cost + d >= dist[w][k]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d >= dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cost + d < dist[w][k]:",
      "mutated_line": "if cost + d != dist[w][k]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d != dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n or cost < dist[w][k + 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n or cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(n + 1):",
      "mutated_line": "for k in range(n + 2):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 2):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(n + 1):",
      "mutated_line": "for k in range(n + 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 0):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(n + 1):",
      "mutated_line": "for k in range(n + 0):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 0):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for k in range(n + 1):",
      "mutated_line": "for k in range(n + -1):",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + -1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 1].append((t + 1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t + 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 1].append((t * 1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t * 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] * (n + 2) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 2) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] * (n + 0) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 0) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] * (n + 0) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 0) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [[INF] * (n + 1) for _ in range(n)]",
      "mutated_line": "dist = [[INF] * (n + -1) for _ in range(n)]",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + -1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if cost + d < dist[w][k]:",
      "mutated_line": "if cost - d < dist[w][k]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost - d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if cost + d < dist[w][k]:",
      "mutated_line": "if cost * d < dist[w][k]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost * d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[w][k] = cost + d",
      "mutated_line": "dist[w][k] = cost - d",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost - d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist[w][k] = cost + d",
      "mutated_line": "dist[w][k] = cost * d",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost * d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k <= n and cost < dist[w][k + 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k <= n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k >= n and cost < dist[w][k + 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k >= n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k != n and cost < dist[w][k + 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k != n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost <= dist[w][k + 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost <= dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost >= dist[w][k + 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost >= dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost != dist[w][k + 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost != dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f + 1].append((t - 1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f + 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f * 1].append((t - 1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f * 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 1].append((t - 2, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 2, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 1].append((t - 0, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 0, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 1].append((t - 0, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 0, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 1].append((t - -1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - -1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[w][k + 1] = cost",
      "mutated_line": "dist[w][k - 1] = cost",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k - 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist[w][k + 1] = cost",
      "mutated_line": "dist[w][k * 1] = cost",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k * 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n + 1][k] <= c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n + 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n * 1][k] <= c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n * 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 2].append((t - 1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 2].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 0].append((t - 1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 0].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - 0].append((t - 1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 0].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[f - 1].append((t - 1, cost))",
      "mutated_line": "G[f - -1].append((t - 1, cost))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - -1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "heappush(que, (cost + d, w, k))",
      "mutated_line": "heappush(que, (cost - d, w, k))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost - d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "heappush(que, (cost + d, w, k))",
      "mutated_line": "heappush(que, (cost * d, w, k))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost * d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost < dist[w][k - 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k - 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost < dist[w][k * 1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k * 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[w][k + 1] = cost",
      "mutated_line": "dist[w][k + 2] = cost",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 2] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[w][k + 1] = cost",
      "mutated_line": "dist[w][k + 0] = cost",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 0] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[w][k + 1] = cost",
      "mutated_line": "dist[w][k + 0] = cost",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 0] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist[w][k + 1] = cost",
      "mutated_line": "dist[w][k + -1] = cost",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + -1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heappush(que, (cost, w, k + 1))",
      "mutated_line": "heappush(que, (cost, w, k - 1))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k - 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heappush(que, (cost, w, k + 1))",
      "mutated_line": "heappush(que, (cost, w, k * 1))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k * 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n - 2][k] <= c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 2][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n - 0][k] <= c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 0][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n - 0][k] <= c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 0][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if dist[n - 1][k] <= c:",
      "mutated_line": "if dist[n - -1][k] <= c:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - -1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost < dist[w][k + 2]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 2]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost < dist[w][k + 0]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 0]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost < dist[w][k + 0]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 0]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if k < n and cost < dist[w][k + 1]:",
      "mutated_line": "if k < n and cost < dist[w][k + -1]:",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + -1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heappush(que, (cost, w, k + 1))",
      "mutated_line": "heappush(que, (cost, w, k + 2))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 2))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heappush(que, (cost, w, k + 1))",
      "mutated_line": "heappush(que, (cost, w, k + 0))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 0))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heappush(que, (cost, w, k + 1))",
      "mutated_line": "heappush(que, (cost, w, k + 0))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + 0))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heappush(que, (cost, w, k + 1))",
      "mutated_line": "heappush(que, (cost, w, k + -1))",
      "code": "import sys\nfrom heapq import heappush, heappop\n\ndef adjust_min_cost_path(n, m, c, edges):\n    if n == 0 and m == 0 and (c == 0):\n        return 0\n    G = [[] for _ in range(n)]\n    for (f, t, cost) in edges:\n        G[f - 1].append((t - 1, cost))\n    INF = 10 ** 18\n    dist = [[INF] * (n + 1) for _ in range(n)]\n    que = [(0, 0, 0)]\n    dist[0][0] = 0\n    while que:\n        (cost, v, k) = heappop(que)\n        if dist[v][k] < cost:\n            continue\n        for (w, d) in G[v]:\n            if cost + d < dist[w][k]:\n                dist[w][k] = cost + d\n                heappush(que, (cost + d, w, k))\n            if k < n and cost < dist[w][k + 1]:\n                dist[w][k + 1] = cost\n                heappush(que, (cost, w, k + -1))\n    for k in range(n + 1):\n        if dist[n - 1][k] <= c:\n            return k\n    return -1"
    }
  ]
}