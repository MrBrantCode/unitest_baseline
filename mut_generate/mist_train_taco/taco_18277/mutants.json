{
  "task_id": "taco_18277",
  "entry_point": "calculate_minimum_nimbdas",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "prefix_sums = [0] * N",
      "mutated_line": "prefix_sums = [0] / N",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] / N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "prefix_sums = [0] * N",
      "mutated_line": "prefix_sums = [0] + N",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] + N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "prefix_sums = [0] * N",
      "mutated_line": "prefix_sums = [0] ** N",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] ** N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] - (prefix_sums[i - 1] if i > 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] - (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] * (prefix_sums[i - 1] if i > 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] * (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prefix_sums = [0] * N",
      "mutated_line": "prefix_sums = [1] * N",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [1] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prefix_sums = [0] * N",
      "mutated_line": "prefix_sums = [-1] * N",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [-1] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prefix_sums = [0] * N",
      "mutated_line": "prefix_sums = [1] * N",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [1] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "houses_to_pay = math.ceil(N / (K + 1))",
      "mutated_line": "houses_to_pay = math.ceil(N * (K + 1))",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N * (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "houses_to_pay = math.ceil(N / (K + 1))",
      "mutated_line": "houses_to_pay = math.ceil(N // (K + 1))",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N // (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i >= 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i >= 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i <= 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i <= 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i != 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i != 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 1)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 1)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else -1)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else -1)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 1)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 1)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "houses_to_pay = math.ceil(N / (K + 1))",
      "mutated_line": "houses_to_pay = math.ceil(N / (K - 1))",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K - 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "houses_to_pay = math.ceil(N / (K + 1))",
      "mutated_line": "houses_to_pay = math.ceil(N / (K * 1))",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K * 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "result.append(prefix_sums[houses_to_pay - 1])",
      "mutated_line": "result.append(prefix_sums[houses_to_pay + 1])",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay + 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "result.append(prefix_sums[houses_to_pay - 1])",
      "mutated_line": "result.append(prefix_sums[houses_to_pay * 1])",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay * 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 1 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 1 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > -1 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > -1 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 1 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 1 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i + 1] if i > 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i + 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i * 1] if i > 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i * 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "houses_to_pay = math.ceil(N / (K + 1))",
      "mutated_line": "houses_to_pay = math.ceil(N / (K + 2))",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 2))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "houses_to_pay = math.ceil(N / (K + 1))",
      "mutated_line": "houses_to_pay = math.ceil(N / (K + 0))",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 0))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "houses_to_pay = math.ceil(N / (K + 1))",
      "mutated_line": "houses_to_pay = math.ceil(N / (K + 0))",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 0))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "houses_to_pay = math.ceil(N / (K + 1))",
      "mutated_line": "houses_to_pay = math.ceil(N / (K + -1))",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + -1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result.append(prefix_sums[houses_to_pay - 1])",
      "mutated_line": "result.append(prefix_sums[houses_to_pay - 2])",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 2])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result.append(prefix_sums[houses_to_pay - 1])",
      "mutated_line": "result.append(prefix_sums[houses_to_pay - 0])",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result.append(prefix_sums[houses_to_pay - 1])",
      "mutated_line": "result.append(prefix_sums[houses_to_pay - 0])",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 0])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "result.append(prefix_sums[houses_to_pay - 1])",
      "mutated_line": "result.append(prefix_sums[houses_to_pay - -1])",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - -1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 2] if i > 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 2] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 0] if i > 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 0] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 0] if i > 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 0] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - 1] if i > 0 else 0)",
      "mutated_line": "prefix_sums[i] = A_sorted[i] + (prefix_sums[i - -1] if i > 0 else 0)",
      "code": "import math\n\ndef calculate_minimum_nimbdas(N, A, Q, K_values):\n    A_sorted = sorted(A)\n    prefix_sums = [0] * N\n    for i in range(N):\n        prefix_sums[i] = A_sorted[i] + (prefix_sums[i - -1] if i > 0 else 0)\n    result = []\n    for K in K_values:\n        houses_to_pay = math.ceil(N / (K + 1))\n        result.append(prefix_sums[houses_to_pay - 1])\n    return result"
    }
  ]
}