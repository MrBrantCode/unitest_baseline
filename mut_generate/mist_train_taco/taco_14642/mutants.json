{
  "task_id": "taco_14642",
  "entry_point": "generate_longest_happy_string",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 or b == 0 or c == 0:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 or b == 0 or c == 0:\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "res = ''",
      "mutated_line": "res = 'MUTATED'",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = 'MUTATED'\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prev_val = 0",
      "mutated_line": "prev_val = 1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 1\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prev_val = 0",
      "mutated_line": "prev_val = -1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = -1\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prev_val = 0",
      "mutated_line": "prev_val = 1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 1\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prev_char = ''",
      "mutated_line": "prev_char = 'MUTATED'",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = 'MUTATED'\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a != 0 and b == 0 and (c == 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a != 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 and b != 0 and (c == 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b != 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 and b == 0 and (c != 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c != 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return ''",
      "mutated_line": "return 'MUTATED'",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return 'MUTATED'\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if prev_val < 0:",
      "mutated_line": "if prev_val <= 0:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val <= 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if prev_val < 0:",
      "mutated_line": "if prev_val >= 0:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val >= 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if prev_val < 0:",
      "mutated_line": "if prev_val != 0:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val != 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if abs(v) >= 2:",
      "mutated_line": "if abs(v) > 2:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) > 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if abs(v) >= 2:",
      "mutated_line": "if abs(v) < 2:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) < 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if abs(v) >= 2:",
      "mutated_line": "if abs(v) == 2:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) == 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 1 and b == 0 and (c == 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 1 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == -1 and b == 0 and (c == 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == -1 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 1 and b == 0 and (c == 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 1 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 and b == 1 and (c == 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 1 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 and b == -1 and (c == 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == -1 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 and b == 1 and (c == 0):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 1 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 and b == 0 and (c == 1):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 1):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 and b == 0 and (c == -1):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == -1):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a == 0 and b == 0 and c == 0:",
      "mutated_line": "if a == 0 and b == 0 and (c == 1):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 1):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]",
      "mutated_line": "heap = [(+a, 'a'), (-b, 'b'), (-c, 'c')]",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(+a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]",
      "mutated_line": "heap = [(-a, ''), (-b, 'b'), (-c, 'c')]",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, ''), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]",
      "mutated_line": "heap = [(-a, 'a'), (+b, 'b'), (-c, 'c')]",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (+b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]",
      "mutated_line": "heap = [(-a, 'a'), (-b, ''), (-c, 'c')]",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, ''), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]",
      "mutated_line": "heap = [(-a, 'a'), (-b, 'b'), (+c, 'c')]",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (+c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]",
      "mutated_line": "heap = [(-a, 'a'), (-b, 'b'), (-c, '')]",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, '')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if prev_val < 0:",
      "mutated_line": "if prev_val < 1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 1:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if prev_val < 0:",
      "mutated_line": "if prev_val < -1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < -1:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if prev_val < 0:",
      "mutated_line": "if prev_val < 1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 1:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if abs(v) >= 2:",
      "mutated_line": "if abs(v) >= 3:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 3:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if abs(v) >= 2:",
      "mutated_line": "if abs(v) >= 1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 1:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if abs(v) >= 2:",
      "mutated_line": "if abs(v) >= 0:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 0:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if abs(v) >= 2:",
      "mutated_line": "if abs(v) >= 1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 1:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if abs(v) >= 2:",
      "mutated_line": "if abs(v) >= -2:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= -2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if abs(v) > abs(prev_val):",
      "mutated_line": "if abs(v) >= abs(prev_val):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) >= abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if abs(v) > abs(prev_val):",
      "mutated_line": "if abs(v) <= abs(prev_val):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) <= abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if abs(v) > abs(prev_val):",
      "mutated_line": "if abs(v) != abs(prev_val):",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) != abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res -= char * 2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res -= char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "v += 2",
      "mutated_line": "v -= 2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v -= 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "res += char",
      "mutated_line": "res -= char",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res -= char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "v += 1",
      "mutated_line": "v -= 1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v -= 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif abs(v) == 1:",
      "mutated_line": "elif abs(v) != 1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) != 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "res += char",
      "mutated_line": "res -= char",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res -= char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "v += 1",
      "mutated_line": "v -= 1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v -= 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res += char / 2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char / 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res += char + 2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char + 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res += char ** 2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char ** 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v += 2",
      "mutated_line": "v += 3",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 3\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v += 2",
      "mutated_line": "v += 1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 1\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v += 2",
      "mutated_line": "v += 0",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 0\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v += 2",
      "mutated_line": "v += 1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 1\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "v += 2",
      "mutated_line": "v += -2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += -2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v += 1",
      "mutated_line": "v += 2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 2\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v += 1",
      "mutated_line": "v += 0",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 0\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v += 1",
      "mutated_line": "v += 0",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 0\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v += 1",
      "mutated_line": "v += -1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += -1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif abs(v) == 1:",
      "mutated_line": "elif abs(v) == 2:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 2:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif abs(v) == 1:",
      "mutated_line": "elif abs(v) == 0:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 0:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif abs(v) == 1:",
      "mutated_line": "elif abs(v) == 0:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 0:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif abs(v) == 1:",
      "mutated_line": "elif abs(v) == -1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == -1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v += 1",
      "mutated_line": "v += 2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 2\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v += 1",
      "mutated_line": "v += 0",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 0\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v += 1",
      "mutated_line": "v += 0",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 0\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "v += 1",
      "mutated_line": "v += -1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += -1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif abs(v) == 0:",
      "mutated_line": "elif abs(v) != 0:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) != 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res += char * 3",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 3\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res += char * 1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 1\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res += char * 0",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 0\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res += char * 1",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 1\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "res += char * 2",
      "mutated_line": "res += char * -2",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * -2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 0:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif abs(v) == 0:",
      "mutated_line": "elif abs(v) == 1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 1:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif abs(v) == 0:",
      "mutated_line": "elif abs(v) == -1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == -1:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif abs(v) == 0:",
      "mutated_line": "elif abs(v) == 1:",
      "code": "import heapq\n\ndef generate_longest_happy_string(a: int, b: int, c: int) -> str:\n    if a == 0 and b == 0 and (c == 0):\n        return ''\n    res = ''\n    heap = [(-a, 'a'), (-b, 'b'), (-c, 'c')]\n    heapq.heapify(heap)\n    prev_val = 0\n    prev_char = ''\n    while heap:\n        (v, char) = heapq.heappop(heap)\n        if prev_val < 0:\n            heapq.heappush(heap, (prev_val, prev_char))\n        if abs(v) >= 2:\n            if abs(v) > abs(prev_val):\n                res += char * 2\n                v += 2\n            else:\n                res += char\n                v += 1\n        elif abs(v) == 1:\n            res += char\n            v += 1\n        elif abs(v) == 1:\n            break\n        prev_val = v\n        prev_char = char\n    return res"
    }
  ]
}