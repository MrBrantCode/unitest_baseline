{
  "task_id": "taco_12629",
  "entry_point": "count_remaining_robot_sets",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244354\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244352\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 0\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 1\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = -998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 * 7)",
      "code": "import sys\nsys.setrecursionlimit(10 * 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 + 7)",
      "code": "import sys\nsys.setrecursionlimit(10 + 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "self.counter[x] += 1",
      "mutated_line": "self.counter[x] -= 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] -= 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "self.counter[x] -= 1",
      "mutated_line": "self.counter[x] += 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] += 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 2\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 0\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 0\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = -1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "ans *= dfs(v)",
      "mutated_line": "ans /= dfs(v)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans /= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(11 ** 7)",
      "code": "import sys\nsys.setrecursionlimit(11 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(9 ** 7)",
      "code": "import sys\nsys.setrecursionlimit(9 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(0 ** 7)",
      "code": "import sys\nsys.setrecursionlimit(0 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(1 ** 7)",
      "code": "import sys\nsys.setrecursionlimit(1 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(-10 ** 7)",
      "code": "import sys\nsys.setrecursionlimit(-10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** 8)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 8)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** 6)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** 0)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 0)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** 1)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 1)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(10 ** 7)",
      "mutated_line": "sys.setrecursionlimit(10 ** -7)",
      "code": "import sys\nsys.setrecursionlimit(10 ** -7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.counter[x] += 1",
      "mutated_line": "self.counter[x] += 2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 2\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.counter[x] += 1",
      "mutated_line": "self.counter[x] += 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 0\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.counter[x] += 1",
      "mutated_line": "self.counter[x] += 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 0\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "self.counter[x] += 1",
      "mutated_line": "self.counter[x] += -1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += -1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.counter[x] -= 1",
      "mutated_line": "self.counter[x] -= 2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 2\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.counter[x] -= 1",
      "mutated_line": "self.counter[x] -= 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 0\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.counter[x] -= 1",
      "mutated_line": "self.counter[x] -= 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 0\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "self.counter[x] -= 1",
      "mutated_line": "self.counter[x] -= -1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= -1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue or self.counter[-self.maxQue[0]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue or self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "while self.minQue and self.counter[self.minQue[0]] == 0:",
      "mutated_line": "while self.minQue or self.counter[self.minQue[0]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue or self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 2\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 0\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 0\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = -1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "res *= dfs(to)",
      "mutated_line": "res /= dfs(to)",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res /= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return res + 1",
      "mutated_line": "return res - 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res - 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return res + 1",
      "mutated_line": "return res * 1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res * 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N + 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N * 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, +1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, +1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() or st.min()[0] < x + d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() or st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue and self.counter[-self.maxQue[0]] != 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] != 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return -self.maxQue[0] if self.maxQue else None",
      "mutated_line": "return +self.maxQue[0] if self.maxQue else None",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return +self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while self.minQue and self.counter[self.minQue[0]] == 0:",
      "mutated_line": "while self.minQue and self.counter[self.minQue[0]] != 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] != 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return res + 1",
      "mutated_line": "return res + 2",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 2\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return res + 1",
      "mutated_line": "return res + 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 0\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return res + 1",
      "mutated_line": "return res + 0",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 0\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return res + 1",
      "mutated_line": "return res + -1",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + -1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 2, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 0, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 0, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - -1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -2, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -0, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -0, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, --1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -2):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -0):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -0):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "(x, d) = robots[i]",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, --1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() and st.min()[0] <= x + d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] <= x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() and st.min()[0] >= x + d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] >= x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() and st.min()[0] != x + d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] != x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 1:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue and self.counter[-self.maxQue[0]] == -1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == -1:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 1:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while self.minQue and self.counter[self.minQue[0]] == 0:",
      "mutated_line": "while self.minQue and self.counter[self.minQue[0]] == 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 1:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while self.minQue and self.counter[self.minQue[0]] == 0:",
      "mutated_line": "while self.minQue and self.counter[self.minQue[0]] == -1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == -1:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while self.minQue and self.counter[self.minQue[0]] == 0:",
      "mutated_line": "while self.minQue and self.counter[self.minQue[0]] == 1:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 1:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return self.minQue[0] if self.minQue else None",
      "mutated_line": "return self.minQue[1] if self.minQue else None",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[1] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return self.minQue[0] if self.minQue else None",
      "mutated_line": "return self.minQue[-1] if self.minQue else None",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[-1] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return self.minQue[0] if self.minQue else None",
      "mutated_line": "return self.minQue[1] if self.minQue else None",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[1] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() and st.min()[0] < x - d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x - d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() and st.min()[0] < x * d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x * d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue and self.counter[+self.maxQue[0]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[+self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -self.maxQue[0] if self.maxQue else None",
      "mutated_line": "return -self.maxQue[1] if self.maxQue else None",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[1] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -self.maxQue[0] if self.maxQue else None",
      "mutated_line": "return -self.maxQue[-1] if self.maxQue else None",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[-1] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return -self.maxQue[0] if self.maxQue else None",
      "mutated_line": "return -self.maxQue[1] if self.maxQue else None",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[1] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() and st.min()[1] < x + d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[1] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() and st.min()[-1] < x + d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[-1] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "while st.min() and st.min()[0] < x + d:",
      "mutated_line": "while st.min() and st.min()[1] < x + d:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[1] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "to_edge[i].append(st.min()[1])",
      "mutated_line": "to_edge[i].append(st.min()[2])",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[2])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "to_edge[i].append(st.min()[1])",
      "mutated_line": "to_edge[i].append(st.min()[0])",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[0])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "to_edge[i].append(st.min()[1])",
      "mutated_line": "to_edge[i].append(st.min()[0])",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[0])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "to_edge[i].append(st.min()[1])",
      "mutated_line": "to_edge[i].append(st.min()[-1])",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[-1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while self.minQue and self.counter[self.minQue[0]] == 0:",
      "mutated_line": "while self.minQue and self.counter[self.minQue[1]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[1]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while self.minQue and self.counter[self.minQue[0]] == 0:",
      "mutated_line": "while self.minQue and self.counter[self.minQue[-1]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[-1]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while self.minQue and self.counter[self.minQue[0]] == 0:",
      "mutated_line": "while self.minQue and self.counter[self.minQue[1]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[0]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[1]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue and self.counter[-self.maxQue[1]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[1]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue and self.counter[-self.maxQue[-1]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[-1]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while self.maxQue and self.counter[-self.maxQue[0]] == 0:",
      "mutated_line": "while self.maxQue and self.counter[-self.maxQue[1]] == 0:",
      "code": "import sys\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappush, heappop\nfrom collections import Counter\nMOD = 998244353\n\nclass HeapSet:\n\n    def __init__(self):\n        self.minQue = []\n        self.maxQue = []\n        self.counter = Counter()\n\n    def insert(self, x):\n        heappush(self.minQue, x)\n        self.counter[x] += 1\n\n    def erase(self, x):\n        self.counter[x] -= 1\n\n    def max(self):\n        while self.maxQue and self.counter[-self.maxQue[1]] == 0:\n            heappop(self.maxQue)\n        return -self.maxQue[0] if self.maxQue else None\n\n    def min(self):\n        while self.minQue and self.counter[self.minQue[0]] == 0:\n            heappop(self.minQue)\n        return self.minQue[0] if self.minQue else None\n\ndef count_remaining_robot_sets(N, robots):\n\n    def dfs(v):\n        res = 1\n        for to in to_edge[v]:\n            res *= dfs(to)\n            res %= MOD\n        return res + 1\n    robots.sort()\n    st = HeapSet()\n    to_edge = [[] for _ in range(N)]\n    for i in range(N - 1, -1, -1):\n        (x, d) = robots[i]\n        while st.min() and st.min()[0] < x + d:\n            to_edge[i].append(st.min()[1])\n            st.erase(st.min())\n        st.insert((x, i))\n    ans = 1\n    for (x, v) in st.minQue:\n        ans *= dfs(v)\n        ans %= MOD\n    return ans"
    }
  ]
}