{
  "task_id": "taco_13941",
  "entry_point": "max_chocolates",
  "mutant_count": 106,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 and j1 >= m and (j2 < 0) and (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 and j1 >= m and (j2 < 0) and (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i == n - 1:",
      "mutated_line": "if i != n - 1:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i != n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if dp[i][j1][j2] != -1:",
      "mutated_line": "if dp[i][j1][j2] == -1:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] == -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "maxi = -sys.maxsize",
      "mutated_line": "maxi = +sys.maxsize",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = +sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(1, 0, c - 1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(1, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(-1, 0, c - 1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(-1, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(1, 0, c - 1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(1, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, 1, c - 1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 1, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, -1, c - 1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, -1, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, 1, c - 1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 1, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, 0, c + 1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c + 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, 0, c * 1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c * 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 <= 0 or j1 >= m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 <= 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 >= 0 or j1 >= m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 >= 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 != 0 or j1 >= m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 != 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 > m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 > m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 < m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 < m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 == m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 == m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 <= 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 <= 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 >= 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 >= 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 != 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 != 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 < 0 or (j2 > m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 > m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 < 0 or (j2 < m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 < m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 < 0 or (j2 == m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 == m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i == n - 1:",
      "mutated_line": "if i == n + 1:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n + 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if i == n - 1:",
      "mutated_line": "if i == n * 1:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n * 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if j1 == j2:",
      "mutated_line": "if j1 != j2:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 != j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if dp[i][j1][j2] != -1:",
      "mutated_line": "if dp[i][j1][j2] != +1:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != +1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(+1, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(+1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(-1, 3):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 3):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(-1, 1):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 1):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(-1, 0):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 0):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(-1, 1):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 1):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(-1, -2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, -2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, 0, c - 2, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 2, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, 0, c - 0, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 0, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, 0, c - 0, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 0, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return max_choco_util(0, 0, c - 1, r, c, grid, dp)",
      "mutated_line": "return max_choco_util(0, 0, c - -1, r, c, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - -1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 1 or j1 >= m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 1 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < -1 or j1 >= m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < -1 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 1 or j1 >= m or j2 < 0 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 1 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 < 1 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 1 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 < -1 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < -1 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j1 < 0 or j1 >= m or j2 < 0 or j2 >= m:",
      "mutated_line": "if j1 < 0 or j1 >= m or j2 < 1 or (j2 >= m):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 1 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "return int(-1000000000.0)",
      "mutated_line": "return int(+1000000000.0)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(+1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i == n - 1:",
      "mutated_line": "if i == n - 2:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 2:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i == n - 1:",
      "mutated_line": "if i == n - 0:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 0:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i == n - 1:",
      "mutated_line": "if i == n - 0:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 0:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if i == n - 1:",
      "mutated_line": "if i == n - -1:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - -1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return grid[i][j1] + grid[i][j2]",
      "mutated_line": "return grid[i][j1] - grid[i][j2]",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] - grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return grid[i][j1] + grid[i][j2]",
      "mutated_line": "return grid[i][j1] * grid[i][j2]",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] * grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp[i][j1][j2] != -1:",
      "mutated_line": "if dp[i][j1][j2] != -2:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -2:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp[i][j1][j2] != -1:",
      "mutated_line": "if dp[i][j1][j2] != -0:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -0:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp[i][j1][j2] != -1:",
      "mutated_line": "if dp[i][j1][j2] != -0:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -0:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if dp[i][j1][j2] != -1:",
      "mutated_line": "if dp[i][j1][j2] != --1:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != --1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(-2, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-2, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(-0, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-0, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(-0, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-0, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for di in range(-1, 2):",
      "mutated_line": "for di in range(--1, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(--1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(+1, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(+1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(-1, 3):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 3):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(-1, 1):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 1):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(-1, 0):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 0):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(-1, 1):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 1):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(-1, -2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, -2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if j1 == j2:",
      "mutated_line": "if j1 != j2:",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 != j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "mutated_line": "dp = [[[+1 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[+1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(-1000000000.0)",
      "mutated_line": "return int(-1000000001.0)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000001.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(-1000000000.0)",
      "mutated_line": "return int(-999999999.0)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-999999999.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(-1000000000.0)",
      "mutated_line": "return int(-0)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(-1000000000.0)",
      "mutated_line": "return int(-1)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return int(-1000000000.0)",
      "mutated_line": "return int(--1000000000.0)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(--1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(-2, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-2, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(-0, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-0, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(-0, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-0, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for dj in range(-1, 2):",
      "mutated_line": "for dj in range(--1, 2):",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(--1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] - max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] - max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] * max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] * max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] - max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] - max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = (grid[i][j1] + grid[i][j2]) * max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = (grid[i][j1] + grid[i][j2]) * max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "mutated_line": "dp = [[[-2 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-2 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "mutated_line": "dp = [[[-0 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-0 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "mutated_line": "dp = [[[-0 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-0 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "mutated_line": "dp = [[[--1 for _ in range(c)] for _ in range(c)] for _ in range(r)]",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[--1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] - grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] - grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] * grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] * grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i - 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i - 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i * 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i * 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 - di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 - di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 * di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 * di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 - dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 - dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 * dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 * dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i - 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i - 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i * 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i * 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 - di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 - di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 * di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 * di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 - dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 - dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 * dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 * dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i + 2, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 2, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i + 0, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 0, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i + 0, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 0, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + max_choco_util(i + -1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + -1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 2, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 2, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 0, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 0, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 0, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 0, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)",
      "mutated_line": "ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + -1, j1 + di, j2 + dj, n, m, grid, dp)",
      "code": "import sys\n\ndef max_chocolates(r, c, grid):\n    dp = [[[-1 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n    return max_choco_util(0, 0, c - 1, r, c, grid, dp)\n\ndef max_choco_util(i, j1, j2, n, m, grid, dp):\n    if j1 < 0 or j1 >= m or j2 < 0 or (j2 >= m):\n        return int(-1000000000.0)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    maxi = -sys.maxsize\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            if j1 == j2:\n                ans = grid[i][j1] + max_choco_util(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + max_choco_util(i + -1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    dp[i][j1][j2] = maxi\n    return maxi"
    }
  ]
}