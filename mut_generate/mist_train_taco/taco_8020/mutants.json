{
  "task_id": "taco_8020",
  "entry_point": "find_shortest_path",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 * 18",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 * 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 + 18",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 + 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 11 ** 18",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 11 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 9 ** 18",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 9 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 0 ** 18",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 0 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 1 ** 18",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 1 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = -10 ** 18",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = -10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 19",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 19\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 17",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 17\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 0",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 0\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** 1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 1\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 18",
      "mutated_line": "INF = 10 ** -18",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** -18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] / n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] / n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] + n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] + n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] ** n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] ** n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] / n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] / n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] + n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] + n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] ** n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] ** n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 1\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = -1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = -1\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 1\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parent = [-1] * n",
      "mutated_line": "parent = [-1] / n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] / n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parent = [-1] * n",
      "mutated_line": "parent = [-1] + n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] + n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "parent = [-1] * n",
      "mutated_line": "parent = [-1] ** n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] ** n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if dist[n - 1] == INF:",
      "mutated_line": "if dist[n - 1] != INF:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] != INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "curr = n - 1",
      "mutated_line": "curr = n + 1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n + 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "curr = n - 1",
      "mutated_line": "curr = n * 1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n * 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "while curr != -1:",
      "mutated_line": "while curr == -1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr == -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[1] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[-1] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[-1] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[1] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "vis[u] = True",
      "mutated_line": "vis[u] = False",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = False\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return '-1'",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return ''\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "curr = n - 1",
      "mutated_line": "curr = n - 2",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 2\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "curr = n - 1",
      "mutated_line": "curr = n - 0",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 0\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "curr = n - 1",
      "mutated_line": "curr = n - 0",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 0\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "curr = n - 1",
      "mutated_line": "curr = n - -1",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - -1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "UOI",
      "lineno": 46,
      "original_line": "while curr != -1:",
      "mutated_line": "while curr != +1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != +1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u + 1, v - 1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u + 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u * 1, v - 1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u * 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 1, v + 1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v + 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 1, v * 1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v * 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [True] * n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [True] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_queue = [(0, 0)]",
      "mutated_line": "min_queue = [(1, 0)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(1, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_queue = [(0, 0)]",
      "mutated_line": "min_queue = [(-1, 0)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(-1, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_queue = [(0, 0)]",
      "mutated_line": "min_queue = [(1, 0)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(1, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_queue = [(0, 0)]",
      "mutated_line": "min_queue = [(0, 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 1)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_queue = [(0, 0)]",
      "mutated_line": "min_queue = [(0, -1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, -1)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "min_queue = [(0, 0)]",
      "mutated_line": "min_queue = [(0, 1)]",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 1)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "parent = [-1] * n",
      "mutated_line": "parent = [+1] * n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [+1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if d2 + d < dist[v]:",
      "mutated_line": "if d2 + d <= dist[v]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d <= dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if d2 + d < dist[v]:",
      "mutated_line": "if d2 + d >= dist[v]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d >= dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if d2 + d < dist[v]:",
      "mutated_line": "if d2 + d != dist[v]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d != dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if dist[n - 1] == INF:",
      "mutated_line": "if dist[n + 1] == INF:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n + 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if dist[n - 1] == INF:",
      "mutated_line": "if dist[n * 1] == INF:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n * 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "while curr != -1:",
      "mutated_line": "while curr != -2:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -2:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "while curr != -1:",
      "mutated_line": "while curr != -0:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -0:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "while curr != -1:",
      "mutated_line": "while curr != -0:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -0:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "while curr != -1:",
      "mutated_line": "while curr != --1:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != --1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path.append(curr + 1)",
      "mutated_line": "path.append(curr - 1)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr - 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "path.append(curr + 1)",
      "mutated_line": "path.append(curr * 1)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr * 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return ' '.join((str(i) for i in path))",
      "mutated_line": "return ''.join((str(i) for i in path))",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ''.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 2, v - 1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 2, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 0, v - 1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 0, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 0, v - 1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 0, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - -1, v - 1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - -1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 1, v - 2, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 2, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 1, v - 0, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 0, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 1, v - 0, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 0, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "graph.add_edge(u - 1, v - 1, w)",
      "mutated_line": "graph.add_edge(u - 1, v - -1, w)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - -1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parent = [-1] * n",
      "mutated_line": "parent = [-2] * n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-2] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parent = [-1] * n",
      "mutated_line": "parent = [-0] * n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-0] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parent = [-1] * n",
      "mutated_line": "parent = [-0] * n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-0] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "parent = [-1] * n",
      "mutated_line": "parent = [--1] * n",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [--1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if d2 + d < dist[v]:",
      "mutated_line": "if d2 - d < dist[v]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 - d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if d2 + d < dist[v]:",
      "mutated_line": "if d2 * d < dist[v]:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 * d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dist[v] = d2 + d",
      "mutated_line": "dist[v] = d2 - d",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 - d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dist[v] = d2 + d",
      "mutated_line": "dist[v] = d2 * d",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 * d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dist[n - 1] == INF:",
      "mutated_line": "if dist[n - 2] == INF:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 2] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dist[n - 1] == INF:",
      "mutated_line": "if dist[n - 0] == INF:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 0] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dist[n - 1] == INF:",
      "mutated_line": "if dist[n - 0] == INF:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 0] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dist[n - 1] == INF:",
      "mutated_line": "if dist[n - -1] == INF:",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - -1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path.append(curr + 1)",
      "mutated_line": "path.append(curr + 2)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 2)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path.append(curr + 1)",
      "mutated_line": "path.append(curr + 0)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 0)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path.append(curr + 1)",
      "mutated_line": "path.append(curr + 0)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + 0)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "path.append(curr + 1)",
      "mutated_line": "path.append(curr + -1)",
      "code": "from collections import defaultdict\nfrom heapq import heappush, heapify, heappop\nINF = 10 ** 18\n\nclass Graph:\n\n    def __init__(self):\n        self.adj_list = defaultdict(list)\n\n    def add_edge(self, src, dest, cost):\n        self.adj_list[src].append((dest, cost))\n        self.adj_list[dest].append((src, cost))\n\ndef find_shortest_path(n, m, edges):\n    graph = Graph()\n    for (u, v, w) in edges:\n        graph.add_edge(u - 1, v - 1, w)\n    dist = [INF] * n\n    vis = [False] * n\n    dist[0] = 0\n    min_queue = [(0, 0)]\n    heapify(min_queue)\n    parent = [-1] * n\n    while min_queue:\n        (d, u) = heappop(min_queue)\n        if vis[u]:\n            continue\n        vis[u] = True\n        for (v, d2) in graph.adj_list[u]:\n            if d2 + d < dist[v]:\n                dist[v] = d2 + d\n                heappush(min_queue, (dist[v], v))\n                parent[v] = u\n    if dist[n - 1] == INF:\n        return '-1'\n    path = []\n    curr = n - 1\n    while curr != -1:\n        path.append(curr + -1)\n        curr = parent[curr]\n    path.reverse()\n    return ' '.join((str(i) for i in path))"
    }
  ]
}