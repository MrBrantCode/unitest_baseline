{
  "task_id": "taco_12754",
  "entry_point": "calculate_expected_inversions",
  "mutant_count": 63,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "fr -= 1  # Convert to 0-based index",
      "mutated_line": "fr += 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr += 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "to -= 1  # Convert to 0-based index",
      "mutated_line": "to += 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to += 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0.0",
      "mutated_line": "ans = 1.0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 1.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0.0",
      "mutated_line": "ans = -1.0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = -1.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0.0",
      "mutated_line": "ans = 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "fr -= 1  # Convert to 0-based index",
      "mutated_line": "fr -= 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 2\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "fr -= 1  # Convert to 0-based index",
      "mutated_line": "fr -= 0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 0\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "fr -= 1  # Convert to 0-based index",
      "mutated_line": "fr -= 0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 0\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "fr -= 1  # Convert to 0-based index",
      "mutated_line": "fr -= -1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= -1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "to -= 1  # Convert to 0-based index",
      "mutated_line": "to -= 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 2\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "to -= 1  # Convert to 0-based index",
      "mutated_line": "to -= 0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 0\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "to -= 1  # Convert to 0-based index",
      "mutated_line": "to -= 0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 0\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "to -= 1  # Convert to 0-based index",
      "mutated_line": "to -= -1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= -1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) * 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) * 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) // 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) // 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "ans += dp[i][j]",
      "mutated_line": "ans -= dp[i][j]",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans -= dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0.0 for _ in range(n)] for __ in range(n)]",
      "mutated_line": "dp = [[1.0 for _ in range(n)] for __ in range(n)]",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[1.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0.0 for _ in range(n)] for __ in range(n)]",
      "mutated_line": "dp = [[-1.0 for _ in range(n)] for __ in range(n)]",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[-1.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp = [[0.0 for _ in range(n)] for __ in range(n)]",
      "mutated_line": "dp = [[1 for _ in range(n)] for __ in range(n)]",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[1 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if permutation[i] > permutation[j]:",
      "mutated_line": "if permutation[i] >= permutation[j]:",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] >= permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if permutation[i] > permutation[j]:",
      "mutated_line": "if permutation[i] <= permutation[j]:",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] <= permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if permutation[i] > permutation[j]:",
      "mutated_line": "if permutation[i] != permutation[j]:",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] != permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "fr, to = moves.pop(0)",
      "mutated_line": "(fr, to) = moves.pop(1)",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(1)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "fr, to = moves.pop(0)",
      "mutated_line": "(fr, to) = moves.pop(-1)",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(-1)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "fr, to = moves.pop(0)",
      "mutated_line": "(fr, to) = moves.pop(1)",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(1)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if i != fr and i != to:",
      "mutated_line": "if i != fr or i != to:",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr or i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] - dp[to][fr]) / 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] - dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = dp[fr][to] * dp[to][fr] / 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = dp[fr][to] * dp[to][fr] / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 3",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 3\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 1\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 0\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 1\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2",
      "mutated_line": "dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / -2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / -2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i - 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i * 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[i][j] = 1.0",
      "mutated_line": "dp[i][j] = 2.0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 2.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[i][j] = 1.0",
      "mutated_line": "dp[i][j] = 0.0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 0.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[i][j] = 1.0",
      "mutated_line": "dp[i][j] = 0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dp[i][j] = 1.0",
      "mutated_line": "dp[i][j] = -1.0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = -1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i != fr and i != to:",
      "mutated_line": "if i == fr and i != to:",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i == fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i != fr and i != to:",
      "mutated_line": "if i != fr and i == to:",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i == to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) * 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) * 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) // 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) // 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) * 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) * 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) // 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) // 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 2, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 0, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 0, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + -1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] - dp[i][to]) / 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] - dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = dp[i][fr] * dp[i][to] / 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = dp[i][fr] * dp[i][to] / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 3",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 3\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 1\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 0\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 1\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2",
      "mutated_line": "dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / -2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / -2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] - dp[to][i]) / 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] - dp[to][i]) / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = dp[fr][i] * dp[to][i] / 2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = dp[fr][i] * dp[to][i] / 2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 3",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 3\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 1\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 0",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 0\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 1",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 1\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2",
      "mutated_line": "dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / -2",
      "code": "def calculate_expected_inversions(n, m, permutation, moves):\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if permutation[i] > permutation[j]:\n                dp[i][j] = 1.0\n    for _ in range(m):\n        (fr, to) = moves.pop(0)\n        fr -= 1\n        to -= 1\n        for i in range(n):\n            if i != fr and i != to:\n                dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2\n                dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / -2\n        dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += dp[i][j]\n    return ans"
    }
  ]
}