{
  "task_id": "taco_18169",
  "entry_point": "find_k_closest_elements",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if arr[i] == x:",
      "mutated_line": "if arr[i] != x:",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] != x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) < k:",
      "mutated_line": "if len(max_heap) <= k:",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) <= k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) < k:",
      "mutated_line": "if len(max_heap) >= k:",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) >= k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(max_heap) < k:",
      "mutated_line": "if len(max_heap) != k:",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) != k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff and (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff and (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "(diff, val) = (-abs(arr[i] - x), -arr[i])",
      "mutated_line": "(diff, val) = (+abs(arr[i] - x), -arr[i])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (+abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "(diff, val) = (-abs(arr[i] - x), -arr[i])",
      "mutated_line": "(diff, val) = (-abs(arr[i] - x), +arr[i])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), +arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(diff, val) = max_heap[0]",
      "mutated_line": "(diff, val) = max_heap[1]",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[1]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(diff, val) = max_heap[0]",
      "mutated_line": "(diff, val) = max_heap[-1]",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[-1]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(diff, val) = max_heap[0]",
      "mutated_line": "(diff, val) = max_heap[1]",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[1]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) <= -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) <= -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) >= -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) >= -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) != -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) != -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff or arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff or arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "ans.append((-val, -diff))",
      "mutated_line": "ans.append((+val, -diff))",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((+val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "ans.append((-val, -diff))",
      "mutated_line": "ans.append((-val, +diff))",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, +diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < +diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < +diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) != -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) != -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] >= -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] >= -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] <= -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] <= -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] != -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] != -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "(diff, val) = (-abs(arr[i] - x), -arr[i])",
      "mutated_line": "(diff, val) = (+abs(arr[i] - x), -arr[i])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (+abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "(diff, val) = (-abs(arr[i] - x), -arr[i])",
      "mutated_line": "(diff, val) = (-abs(arr[i] - x), +arr[i])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), +arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans.sort(key=lambda x: x[1])",
      "mutated_line": "ans.sort(key=lambda x: x[2])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[2])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans.sort(key=lambda x: x[1])",
      "mutated_line": "ans.sort(key=lambda x: x[0])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[0])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans.sort(key=lambda x: x[1])",
      "mutated_line": "ans.sort(key=lambda x: x[0])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[0])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans.sort(key=lambda x: x[1])",
      "mutated_line": "ans.sort(key=lambda x: x[-1])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[-1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(diff, val) = (-abs(arr[i] - x), -arr[i])",
      "mutated_line": "(diff, val) = (-abs(arr[i] + x), -arr[i])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] + x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "(diff, val) = (-abs(arr[i] - x), -arr[i])",
      "mutated_line": "(diff, val) = (-abs(arr[i] * x), -arr[i])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] * x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] + x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] + x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] * x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] * x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == +diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == +diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > +val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > +val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] + x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] + x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):",
      "mutated_line": "if abs(arr[i] - x) < -diff or (abs(arr[i] * x) == -diff and arr[i] > -val):",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] * x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] - x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(diff, val) = (-abs(arr[i] - x), -arr[i])",
      "mutated_line": "(diff, val) = (-abs(arr[i] + x), -arr[i])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] + x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(diff, val) = (-abs(arr[i] - x), -arr[i])",
      "mutated_line": "(diff, val) = (-abs(arr[i] * x), -arr[i])",
      "code": "import heapq\n\ndef find_k_closest_elements(arr, k, x):\n    max_heap = []\n    n = len(arr)\n    for i in range(n):\n        if arr[i] == x:\n            continue\n        if len(max_heap) < k:\n            (diff, val) = (-abs(arr[i] - x), -arr[i])\n            heapq.heappush(max_heap, (diff, val))\n        else:\n            (diff, val) = max_heap[0]\n            if abs(arr[i] - x) < -diff or (abs(arr[i] - x) == -diff and arr[i] > -val):\n                (diff, val) = (-abs(arr[i] * x), -arr[i])\n                heapq.heappop(max_heap)\n                heapq.heappush(max_heap, (diff, val))\n    ans = []\n    while max_heap:\n        (diff, val) = heapq.heappop(max_heap)\n        ans.append((-val, -diff))\n    ans.sort(key=lambda x: x[1])\n    ans = [x for (x, _) in ans]\n    return ans"
    }
  ]
}