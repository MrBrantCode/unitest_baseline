{
  "task_id": "taco_15702",
  "entry_point": "find_lexicographically_minimal_permutation",
  "mutant_count": 84,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(st) != n // 2:",
      "mutated_line": "if len(st) == n // 2:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) == n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if len(st) != n // 2:",
      "mutated_line": "if len(st) != n / 2:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n / 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if len(st) != n // 2:",
      "mutated_line": "if len(st) != n * 2:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n * 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 + 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 + 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 * 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 * 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, +1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, +1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, +1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, +1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-1]) + 1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) + 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-1]) * 1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) * 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if j == -1:",
      "mutated_line": "if j != -1:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j != -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(st) != n // 2:",
      "mutated_line": "if len(st) != n // 3:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 3:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(st) != n // 2:",
      "mutated_line": "if len(st) != n // 1:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 1:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(st) != n // 2:",
      "mutated_line": "if len(st) != n // 0:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 0:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(st) != n // 2:",
      "mutated_line": "if len(st) != n // 1:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 1:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(st) != n // 2:",
      "mutated_line": "if len(st) != n // -2:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // -2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(+1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(1, n + 1) if i in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n / 2 - 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n / 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n * 2 - 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n * 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 2, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 2, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 0, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 0, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 0, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 0, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - -1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - -1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -2, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -2, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -0, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -0, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -0, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -0, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, --1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, --1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, -2):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -2):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, -0):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -0):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, -0):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -0):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 2 - 1, -1, --1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, --1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-1]) - 2",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 2\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-1]) - 0",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 0\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-1]) - 0",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 0\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-1]) - -1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - -1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "if j == -1:",
      "mutated_line": "if j == +1:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == +1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "ans = -1",
      "mutated_line": "ans = +1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = +1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "del b[-1]",
      "mutated_line": "del b[+1]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[+1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-2)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-0)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-0)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(--1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(2, n + 1) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(2, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(0, n + 1) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(0, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(0, n + 1) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(0, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(-1, n + 1) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(-1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(1, n - 1) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n - 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(1, n * 1) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n * 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 3 - 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 3 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 1 - 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 1 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 0 - 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 0 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // 1 - 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 1 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(n // 2 - 1, -1, -1):",
      "mutated_line": "for i in range(n // -2 - 1, -1, -1):",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // -2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j == -1:",
      "mutated_line": "if j == -2:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -2:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j == -1:",
      "mutated_line": "if j == -0:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -0:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j == -1:",
      "mutated_line": "if j == -0:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -0:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if j == -1:",
      "mutated_line": "if j == --1:",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == --1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans = -1",
      "mutated_line": "ans = -2",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -2\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans = -1",
      "mutated_line": "ans = -0",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -0\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans = -1",
      "mutated_line": "ans = -0",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -0\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans = -1",
      "mutated_line": "ans = --1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = --1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "del b[-1]",
      "mutated_line": "del b[-2]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-2]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "del b[-1]",
      "mutated_line": "del b[-0]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-0]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "del b[-1]",
      "mutated_line": "del b[-0]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-0]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "del b[-1]",
      "mutated_line": "del b[--1]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[--1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(1, n + 2) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 2) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(1, n + 0) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 0) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(1, n + 0) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 0) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = [i for i in range(1, n + 1) if i not in st]",
      "mutated_line": "res = [i for i in range(1, n + -1) if i not in st]",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + -1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[+1]) - 1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[+1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "ans.extend((b[-1], res[j]))",
      "mutated_line": "ans.extend((b[+1], res[j]))",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[+1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "results.append(ans[::-1])",
      "mutated_line": "results.append(ans[::+1])",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::+1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-2]) - 1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-2]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-0]) - 1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-0]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[-0]) - 1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-0]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "j = bs(res, b[-1]) - 1",
      "mutated_line": "j = bs(res, b[--1]) - 1",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[--1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans.extend((b[-1], res[j]))",
      "mutated_line": "ans.extend((b[-2], res[j]))",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-2], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans.extend((b[-1], res[j]))",
      "mutated_line": "ans.extend((b[-0], res[j]))",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-0], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans.extend((b[-1], res[j]))",
      "mutated_line": "ans.extend((b[-0], res[j]))",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-0], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans.extend((b[-1], res[j]))",
      "mutated_line": "ans.extend((b[--1], res[j]))",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[--1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "results.append(ans[::-1])",
      "mutated_line": "results.append(ans[::-2])",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "results.append(ans[::-1])",
      "mutated_line": "results.append(ans[::-0])",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-0])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "results.append(ans[::-1])",
      "mutated_line": "results.append(ans[::-0])",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::-0])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "results.append(ans[::-1])",
      "mutated_line": "results.append(ans[::--1])",
      "code": "def find_lexicographically_minimal_permutation(t, test_cases):\n    from bisect import bisect_right as bs\n    results = []\n    for case in test_cases:\n        (n, b) = case\n        st = set(b)\n        if len(st) != n // 2:\n            results.append(-1)\n            continue\n        res = [i for i in range(1, n + 1) if i not in st]\n        ans = []\n        for i in range(n // 2 - 1, -1, -1):\n            j = bs(res, b[-1]) - 1\n            if j == -1:\n                ans = -1\n                break\n            ans.extend((b[-1], res[j]))\n            del b[-1]\n            del res[j]\n        if isinstance(ans, int):\n            results.append(ans)\n        else:\n            results.append(ans[::--1])\n    return results"
    }
  ]
}