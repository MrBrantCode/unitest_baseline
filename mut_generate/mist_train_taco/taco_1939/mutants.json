{
  "task_id": "taco_1939",
  "entry_point": "min_points_to_form_square",
  "mutant_count": 222,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "answered = False",
      "mutated_line": "answered = True",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = True\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 1\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result = 0",
      "mutated_line": "result = -1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = -1\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "result = 0",
      "mutated_line": "result = 1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 1\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n != 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if n >= 4:",
      "mutated_line": "if n > 4:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n > 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if n >= 4:",
      "mutated_line": "if n < 4:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n < 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if n >= 4:",
      "mutated_line": "if n == 4:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n == 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered or n >= 3:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered or n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered or n >= 2:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered or n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 1:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == -1:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 1:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 4",
      "mutated_line": "return 5",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 5\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 4",
      "mutated_line": "return 3",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 3\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 4",
      "mutated_line": "return 0",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 0\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 4",
      "mutated_line": "return 1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 1\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 4",
      "mutated_line": "return -4",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return -4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n >= 4:",
      "mutated_line": "if n >= 5:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 5:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n >= 4:",
      "mutated_line": "if n >= 3:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n >= 4:",
      "mutated_line": "if n >= 0:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 0:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n >= 4:",
      "mutated_line": "if n >= 1:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 1:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if n >= 4:",
      "mutated_line": "if n >= -4:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= -4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered and n > 3:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n > 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered and n < 3:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n < 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered and n == 3:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n == 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered and n > 2:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n > 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered and n < 2:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n < 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered and n == 2:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n == 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return 3",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 3\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 1\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return 0",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 0\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 1\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 2",
      "mutated_line": "return -2",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return -2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 3",
      "mutated_line": "return 4",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 4\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 3",
      "mutated_line": "return 2",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 2\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 3",
      "mutated_line": "return 0",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 0\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 3",
      "mutated_line": "return 1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 1\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return 3",
      "mutated_line": "return -3",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return -3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered and n >= 4:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered and n >= 2:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 2:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered and n >= 0:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 0:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered and n >= 1:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 1:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if not answered and n >= 3:",
      "mutated_line": "if not answered and n >= -3:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= -3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered and n >= 3:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 3:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered and n >= 1:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 1:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered and n >= 0:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 0:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered and n >= 1:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 1:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not answered and n >= 2:",
      "mutated_line": "if not answered and n >= -2:",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= -2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i - 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i * 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if ((p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points) and ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if ((p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points) and ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i - 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i * 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points and ((p_b[0] + dy, p_b[1] - dx) in set_points) and ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points and ((p_b[0] + dy, p_b[1] - dx) in set_points) and ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 2, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 0, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 0, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + -1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] + p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] + p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] * p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] * p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] + p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] + p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] * p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] * p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if ((p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points) or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if ((p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points) or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return -1\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "answered = True",
      "mutated_line": "answered = False",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = False\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 2, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 0, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 0, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + -1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] + p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] + p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] * p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] * p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] + p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] + p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] * p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] * p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) not in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) not in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) not in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) not in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) not in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) not in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) not in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) not in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 2\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return -1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "answered = True",
      "mutated_line": "answered = False",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = False\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) not in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) not in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) not in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) not in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) not in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) not in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) not in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) not in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[1] - p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[1] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[-1] - p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[-1] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[1] - p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[1] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[1], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[1], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[-1], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[-1], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[1], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[1], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[2] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[2] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[0] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[0] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[0] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[0] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[-1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[-1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[2])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[2])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[0])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[0])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[0])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[0])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[-1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[-1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[1] - p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[1] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[-1] - p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[-1] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[1] - p_b[0], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[1] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[1], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[1], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[-1], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[-1], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[1], p_a[1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[1], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[2] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[2] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[0] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[0] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[0] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[0] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[-1] - p_b[1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[-1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[2])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[2])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[0])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[0])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[0])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[0])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])",
      "mutated_line": "(dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[-1])",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[-1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] + dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] + dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] * dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] * dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] - dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] - dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] * dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] * dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx + dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx + dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or ((p_b[0] + dx) * dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or ((p_b[0] + dx) * dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx - dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx - dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, (p_b[1] + dx) * dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, (p_b[1] + dx) * dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] - dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] - dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] * dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] * dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] + dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] + dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] * dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] * dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx - dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx - dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or (((p_b[0] + dx) * dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or (((p_b[0] + dx) * dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx - dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx - dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, (p_b[1] - dx) * dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, (p_b[1] - dx) * dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] + dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] + dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] * dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] * dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] - dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] - dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] * dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] * dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx + dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx + dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and ((p_b[0] + dx) * dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and ((p_b[0] + dx) * dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx - dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx - dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, (p_b[1] + dx) * dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, (p_b[1] + dx) * dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] - dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] - dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] * dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] * dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] + dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] + dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] * dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] * dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx - dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx - dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and ((p_b[0] + dx) * dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and ((p_b[0] + dx) * dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx - dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx - dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, (p_b[1] - dx) * dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, (p_b[1] - dx) * dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] - dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] - dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] * dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] * dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] - dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] - dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] * dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] * dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] - dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] - dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] * dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] * dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] + dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] + dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] * dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] * dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] - dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] - dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] * dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] * dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] - dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] - dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] * dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] * dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] - dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] - dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] * dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] * dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] + dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] + dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] * dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] * dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[1] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[1] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[-1] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[-1] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[1] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[1] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[2] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[2] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[0] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[0] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[0] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[0] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[-1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[-1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[1] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[1] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[-1] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[-1] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[1] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[1] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[2] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[2] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[0] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[0] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[0] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[0] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[-1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[-1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[1] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[1] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[-1] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[-1] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[1] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[1] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[2] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[2] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[0] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[0] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[0] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[0] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[-1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[-1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[1] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[1] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[-1] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[-1] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[1] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[1] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[2] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[2] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[0] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[0] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[0] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[0] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[-1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[-1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[1] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[1] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[-1] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[-1] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[1] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[1] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[2] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[2] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[0] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[0] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[0] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[0] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[-1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[-1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[1] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[1] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[-1] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[-1] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[1] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[1] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[2] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[2] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[0] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[0] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[0] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[0] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[-1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[-1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[1] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[1] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[-1] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[-1] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[1] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[1] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[2] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[2] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[0] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[0] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[0] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[0] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or \\",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[-1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[-1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[1] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[1] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[-1] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[-1] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[1] + dx + dy, p_b[1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[1] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[2] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[2] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[0] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[0] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[0] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[0] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points:",
      "mutated_line": "if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[-1] - dx + dy) in set_points):",
      "code": "def min_points_to_form_square(points):\n    set_points = set(points)\n    n = len(points)\n    answered = False\n    result = 0\n    if n == 0:\n        return 4\n    if n >= 4:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[-1] - dx + dy) in set_points):\n                    return 0\n                    answered = True\n    if not answered and n >= 3:\n        for i in range(n):\n            for j in range(i + 1, n):\n                (p_a, p_b) = (points[i], points[j])\n                (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n                if (p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or (p_b[0] + dy, p_b[1] - dx) in set_points or ((p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                    return 1\n                    answered = True\n    if not answered and n >= 2:\n        return 2\n    if not answered:\n        return 3\n    return result"
    }
  ]
}