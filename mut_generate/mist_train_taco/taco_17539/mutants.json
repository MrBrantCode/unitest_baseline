{
  "task_id": "taco_17539",
  "entry_point": "calculate_max_coverage",
  "mutant_count": 226,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K += W // 2 + 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K += W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K <= W // 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K <= W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K >= W // 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K >= W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K != W // 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K != W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 2 - 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 - 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 2 * 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 * 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 1\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = -1\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 1\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "r += c",
      "mutated_line": "r -= c",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r -= c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 2 != 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 != 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 2 != 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 != 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K < W / 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W / 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K < W * 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W * 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return +1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W / 2 + 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W / 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W * 2 + 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W * 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 2 + 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 2\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 2 + 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 0\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 2 + 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 0\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 2 + -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + -1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 1\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = 0",
      "mutated_line": "a = -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = -1\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 1\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 10 * 9",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 * 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 10 + 9",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 + 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "prv = -1",
      "mutated_line": "prv = +1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = +1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv <= W // 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv <= W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv >= W // 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv >= W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv != W // 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv != W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) + K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) + K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max(((W // 2 + 1) * (H // 2) + max(r - K, 0)) * K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max(((W // 2 + 1) * (H // 2) + max(r - K, 0)) * K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 1)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, -1)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 1)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y * 2 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y * 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y + 2 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y + 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 2 == 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 2:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 2 == 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 0:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 2 == 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 0:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 2 == -1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == -1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x * 2 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x * 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x + 2 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x + 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 2 == 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 2:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 2 == 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 0:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 2 == 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 0:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 2 == -1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == -1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // 2] |= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 2\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // 2] |= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 0\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // 2] |= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 0\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // 2] |= -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= -1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if x < W:",
      "mutated_line": "if x <= W:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x <= W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if x < W:",
      "mutated_line": "if x >= W:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x >= W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if x < W:",
      "mutated_line": "if x != W:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x != W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 2] |= 3",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 3\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 2] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 1\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 2] |= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 0\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 2] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 1\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 2] |= -2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= -2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K < W // 3:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 3:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K < W // 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 1:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K < W // 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 0:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K < W // 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 1:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if K < W // 2:",
      "mutated_line": "if K < W // -2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // -2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -2\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -0\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -0\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return --1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 3 + 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 3 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 1 + 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 1 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 0 + 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 0 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // 1 + 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 1 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "K -= W // 2 + 1",
      "mutated_line": "K -= W // -2 + 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // -2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 11 ** 9",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 11 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 9 ** 9",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 9 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 0 ** 9",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 0 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 1 ** 9",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 1 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = -10 ** 9",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = -10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 10 ** 10",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 10\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 10 ** 8",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 8\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 10 ** 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 0\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 10 ** 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 1\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b = 10 ** 9",
      "mutated_line": "b = 10 ** -9",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** -9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prv = -1",
      "mutated_line": "prv = -2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -2\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prv = -1",
      "mutated_line": "prv = -0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -0\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prv = -1",
      "mutated_line": "prv = -0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -0\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prv = -1",
      "mutated_line": "prv = --1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = --1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x - prv >= 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv >= 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x - prv <= 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv <= 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x - prv != 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv != 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 1 >= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 >= 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 1 <= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 <= 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 1 != 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 != 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 2 >= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 >= 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 2 <= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 <= 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 2 != 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 != 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 4 >= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 >= 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 4 <= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 <= 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 4 != 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 != 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv < W / 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W / 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv < W * 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W * 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) - max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) - max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) * max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) * max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 3 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 3 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 1 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 1 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 0 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 0 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % 1 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 1 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y % 2 == 1:",
      "mutated_line": "if y % -2 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % -2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 3 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 3 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 1 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 1 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 0 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 0 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % 1 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 1 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if x % 2 == 1:",
      "mutated_line": "if x % -2 == 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % -2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x / 2] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x / 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x * 2] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x * 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + 1] |= 5",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 5\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + 1] |= 3",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 3\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + 1] |= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 0\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + 1] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 1\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + 1] |= -4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= -4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x / 2] |= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x / 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x * 2] |= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x * 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x + prv > 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x + prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x * prv > 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x * prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x - prv > 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 2:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x - prv > 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 0:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x - prv > 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 0:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if x - prv > 1:",
      "mutated_line": "if x - prv > -1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > -1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs | 1 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs | 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 1 > 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 1\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 1 > -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > -1\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 1 > 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 1\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs | 2 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs | 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 2 > 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 1\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 2 > -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > -1\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 2 > 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 1\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs | 4 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs | 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 4 > 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 1\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 4 > -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > -1\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 4 > 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 1\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv < W // 3:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 3:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv < W // 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 1:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv < W // 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 0:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv < W // 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 1:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if prv < W // 2:",
      "mutated_line": "if prv < W // -2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // -2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) / (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) / (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max(W // 2 + 1 + H // 2 + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max(W // 2 + 1 + H // 2 + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) ** (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) ** (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // 3] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 3] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // 1] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 1] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // 0] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 0] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // 1] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 1] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "mp[y][x // 2] |= 1",
      "mutated_line": "mp[y][x // -2] |= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // -2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 - 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 - 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 * 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 * 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 3] |= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 3] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 1] |= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 1] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 0] |= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 0] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // 1] |= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 1] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mp[y][x // 2] |= 2",
      "mutated_line": "mp[y][x // -2] |= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // -2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 2 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 2 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 0 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 0 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & 0 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 0 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "v0 = bs & 1 > 0",
      "mutated_line": "v0 = bs & -1 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & -1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 3 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 3 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 1 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 1 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 0 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 0 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & 1 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 1 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v1 = bs & 2 > 0",
      "mutated_line": "v1 = bs & -2 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & -2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 5 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 5 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 3 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 3 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 0 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 0 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & 1 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 1 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v2 = bs & 4 > 0",
      "mutated_line": "v2 = bs & -4 > 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & -4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a - v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a - v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a * v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a * v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b - min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b - min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b * min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b * min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b - v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b - v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b * v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b * v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 - 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 - 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max(W // 2 * 1 * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max(W // 2 * 1 * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H / 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H / 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H * 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H * 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r + K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r + K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r * K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r * K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 1) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 1) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, -1) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, -1) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 1) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 1) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x / 2 + 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x / 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x * 2 + 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x * 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + 2] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 2] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + 0] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 0] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + 0] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 0] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 2 + -1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + -1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W / 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W / 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W * 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W * 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 2) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 2) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 0) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 0) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 0) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 0) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + -1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + -1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 3) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 3) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 1) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 1) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 0) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 0) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // 1) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 1) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 2 + 1) * (H // -2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // -2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 3 + 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 3 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 1 + 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 1 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 0 + 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 0 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // 1 + 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 1 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mp[y][x // 2 + 1] |= 4",
      "mutated_line": "mp[y][x // -2 + 1] |= 4",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // -2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 - v2, 2 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 - v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 * v2, 2 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 * v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 / v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 / v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 + v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 + v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 ** v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 ** v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 3 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 3 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 1 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 1 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 0 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 0 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // 1 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 1 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "mutated_line": "ans = max((W // -2 + 1) * (H // 2) + max(r - K, 0) - K, 0)",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // -2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 3 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 3 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 1 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 1 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 0 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 0 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 1 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, 1 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(a, b) = (min(a + v0, b + min(v0 + v2, 2 * v1)), min(a, b + v2))",
      "mutated_line": "(a, b) = (min(a + v0, b + min(v0 + v2, -2 * v1)), min(a, b + v2))",
      "code": "from collections import defaultdict\n\ndef calculate_max_coverage(W, H, K, coordinates):\n    mp = defaultdict(lambda : defaultdict(int))\n    for (x, y) in coordinates:\n        if y % 2 == 1:\n            continue\n        if x % 2 == 1:\n            mp[y][x // 2] |= 1\n            if x < W:\n                mp[y][x // 2 + 1] |= 4\n        else:\n            mp[y][x // 2] |= 2\n    if K < W // 2:\n        return -1\n    K -= W // 2 + 1\n    r = 0\n    for (y, mp_xs) in mp.items():\n        S = list(mp_xs.items())\n        S.sort()\n        a = 0\n        b = 10 ** 9\n        prv = -1\n        for (x, bs) in S:\n            if x - prv > 1:\n                a = b = min(a, b)\n            v0 = bs & 1 > 0\n            v1 = bs & 2 > 0\n            v2 = bs & 4 > 0\n            (a, b) = (min(a + v0, b + min(v0 + v2, -2 * v1)), min(a, b + v2))\n            prv = x\n        if prv < W // 2:\n            c = min(a, b)\n        else:\n            c = a\n        r += c\n    ans = max((W // 2 + 1) * (H // 2) + max(r - K, 0) - K, 0)\n    return ans"
    }
  ]
}