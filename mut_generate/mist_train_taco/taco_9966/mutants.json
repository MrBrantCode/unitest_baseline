{
  "task_id": "taco_9966",
  "entry_point": "calculate_minimum_road_cells",
  "mutant_count": 189,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = 1e+18",
      "mutated_line": "ans = 1e+18",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = 1e+18",
      "mutated_line": "ans = 1e+18",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = 1e+18",
      "mutated_line": "ans = 0",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 0\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = 1e+18",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans = 1e+18",
      "mutated_line": "ans = -1e+18",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = -1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ans >= 1e+18:",
      "mutated_line": "if ans > 1e+18:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans > 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ans >= 1e+18:",
      "mutated_line": "if ans < 1e+18:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans < 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ans >= 1e+18:",
      "mutated_line": "if ans == 1e+18:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans == 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for root in range(3):",
      "mutated_line": "for root in range(4):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(4):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for root in range(3):",
      "mutated_line": "for root in range(2):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(2):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for root in range(3):",
      "mutated_line": "for root in range(0):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(0):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for root in range(3):",
      "mutated_line": "for root in range(1):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(1):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for root in range(3):",
      "mutated_line": "for root in range(-3):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(-3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] / 3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] / 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] + 3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] + 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] ** 3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] ** 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist[root] = 0",
      "mutated_line": "dist[root] = 1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 1\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist[root] = 0",
      "mutated_line": "dist[root] = -1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = -1\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist[root] = 0",
      "mutated_line": "dist[root] = 1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 1\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ans >= 1e+18:",
      "mutated_line": "if ans >= 1e+18:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ans >= 1e+18:",
      "mutated_line": "if ans >= 1e+18:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ans >= 1e+18:",
      "mutated_line": "if ans >= 0:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 0:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ans >= 1e+18:",
      "mutated_line": "if ans >= 1:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ans >= 1e+18:",
      "mutated_line": "if ans >= -1e+18:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= -1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return +1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if map_data[i][j] in '123':",
      "mutated_line": "if map_data[i][j] not in '123':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] not in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] / 3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] / 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] + 3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] + 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] ** 3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] ** 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vi = [[False] * m for _ in range(n)]",
      "mutated_line": "vi = [[False] / m for _ in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] / m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vi = [[False] * m for _ in range(n)]",
      "mutated_line": "vi = [[False] + m for _ in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] + m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vi = [[False] * m for _ in range(n)]",
      "mutated_line": "vi = [[False] ** m for _ in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] ** m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "vi[i][j] = True",
      "mutated_line": "vi[i][j] = False",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = False\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "z[i][j][root] = 0",
      "mutated_line": "z[i][j][root] = 1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 1\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "z[i][j][root] = 0",
      "mutated_line": "z[i][j][root] = -1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = -1\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "z[i][j][root] = 0",
      "mutated_line": "z[i][j][root] = 1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 1\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] * 4",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 4\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] * 2",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 2\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] * 0",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 0\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] * 1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 1\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] * -3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * -3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -2\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -0\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -0\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return --1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if map_data[i][j] == '.':",
      "mutated_line": "if map_data[i][j] != '.':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] != '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if map_data[i][j] in '123':",
      "mutated_line": "if map_data[i][j] in '':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] * 4 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 4 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] * 2 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 2 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] * 0 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 0 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] * 1 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 1 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] * -3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * -3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] * 3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1e+18] * 3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [0] * 3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [0] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [1] * 3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist = [1e+18] * 3",
      "mutated_line": "dist = [-1e+18] * 3",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [-1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 <= ii < n or 0 <= jj < m or (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n or 0 <= jj < m or (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if map_data[i][j] == '.':",
      "mutated_line": "if map_data[i][j] == '':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 <= ii < n or 0 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n or 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[0] * 3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[0] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[1] * 3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]",
      "mutated_line": "z = [[[-1e+18] * 3 for j in range(m)] for i in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[-1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vi = [[False] * m for _ in range(n)]",
      "mutated_line": "vi = [[True] * m for _ in range(n)]",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[True] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "q.append((i, j, 0))",
      "mutated_line": "q.append((i, j, 1))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 1))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "q.append((i, j, 0))",
      "mutated_line": "q.append((i, j, -1))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, -1))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "q.append((i, j, 0))",
      "mutated_line": "q.append((i, j, 1))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 1))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i - 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i - 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i * 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i * 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i + 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i + 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i * 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i * 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j - 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j - 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j * 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j * 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j + 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j + 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j * 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j * 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 < ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 < ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 > ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 > ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 == ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 == ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 <= ii < n and 0 < jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 < jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 <= ii < n and 0 > jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 > jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 <= ii < n and 0 == jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 == jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if map_data[ii][jj] == '.':",
      "mutated_line": "if map_data[ii][jj] != '.':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] != '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = min(ans, sum(z[i][j]) - 2)",
      "mutated_line": "ans = min(ans, sum(z[i][j]) + 2)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) + 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = min(ans, sum(z[i][j]) - 2)",
      "mutated_line": "ans = min(ans, sum(z[i][j]) * 2)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) * 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i - 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i - 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i * 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i * 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i + 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i + 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i * 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i * 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j - 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j - 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j * 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j * 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j + 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j + 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j * 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j * 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 < ii < n and 0 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 < ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 > ii < n and 0 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 > ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 == ii < n and 0 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 == ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 <= ii < n and 0 < jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 < jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 <= ii < n and 0 > jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 > jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 <= ii < n and 0 == jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 == jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:",
      "mutated_line": "if map_data[ii][jj] in '123.' or map_data[i][j] != map_data[ii][jj]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' or map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 2, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 2, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + -1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + -1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 2, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 2, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - -1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - -1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 2), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 2), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + -1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + -1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 2)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 2)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - -1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - -1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 1 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 1 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if -1 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if -1 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 1 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 1 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 <= ii < n and 1 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 1 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 <= ii < n and -1 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and -1 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):",
      "mutated_line": "if 0 <= ii < n and 1 <= jj < m and (not vi[ii][jj]):",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 1 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if map_data[ii][jj] == '.':",
      "mutated_line": "if map_data[ii][jj] == '':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "vi[ii][jj] = True",
      "mutated_line": "vi[ii][jj] = False",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = False\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':",
      "mutated_line": "elif map_data[ii][jj] != map_data[i][j] or map_data[ii][jj] in '123':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] or map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = min(ans, sum(z[i][j]) - 2)",
      "mutated_line": "ans = min(ans, sum(z[i][j]) - 3)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 3)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = min(ans, sum(z[i][j]) - 2)",
      "mutated_line": "ans = min(ans, sum(z[i][j]) - 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = min(ans, sum(z[i][j]) - 2)",
      "mutated_line": "ans = min(ans, sum(z[i][j]) - 0)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = min(ans, sum(z[i][j]) - 2)",
      "mutated_line": "ans = min(ans, sum(z[i][j]) - 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = min(ans, sum(z[i][j]) - 2)",
      "mutated_line": "ans = min(ans, sum(z[i][j]) - -2)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - -2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 2, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 2, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 0, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + -1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + -1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 2, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 2, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 0, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - -1, j), (i, j + 1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - -1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 2), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 2), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 0), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + -1), (i, j - 1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + -1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 2)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 2)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 0)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:",
      "mutated_line": "for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - -1)]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - -1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 1 <= ii < n and 0 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 1 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if -1 <= ii < n and 0 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if -1 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 1 <= ii < n and 0 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 1 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 <= ii < n and 1 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 1 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 <= ii < n and -1 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and -1 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ii < n and 0 <= jj < m:",
      "mutated_line": "if 0 <= ii < n and 1 <= jj < m:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 1 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:",
      "mutated_line": "if map_data[ii][jj] not in '123.' and map_data[i][j] != map_data[ii][jj]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] not in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:",
      "mutated_line": "if map_data[ii][jj] in '123.' and map_data[i][j] == map_data[ii][jj]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] == map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 1)",
      "mutated_line": "z[ii][jj][root] = min(z[ii][jj][root], d - 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d - 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 1)",
      "mutated_line": "z[ii][jj][root] = min(z[ii][jj][root], d * 1)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d * 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':",
      "mutated_line": "elif map_data[ii][jj] == map_data[i][j] and map_data[ii][jj] in '123':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] == map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':",
      "mutated_line": "elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] not in '123':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] not in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:",
      "mutated_line": "if map_data[ii][jj] in '' and map_data[i][j] != map_data[ii][jj]:",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "q.append((ii, jj, d + 1))",
      "mutated_line": "q.append((ii, jj, d - 1))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d - 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "q.append((ii, jj, d + 1))",
      "mutated_line": "q.append((ii, jj, d * 1))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d * 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 1)",
      "mutated_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 2)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 2)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 1)",
      "mutated_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 0)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 0)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 1)",
      "mutated_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 0)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 0)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "z[ii][jj][root] = min(z[ii][jj][root], d + 1)",
      "mutated_line": "z[ii][jj][root] = min(z[ii][jj][root], d + -1)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + -1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':",
      "mutated_line": "elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '':",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) + 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) + 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) * 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) * 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "q.append((ii, jj, d + 1))",
      "mutated_line": "q.append((ii, jj, d + 2))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 2))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "q.append((ii, jj, d + 1))",
      "mutated_line": "q.append((ii, jj, d + 0))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 0))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "q.append((ii, jj, d + 1))",
      "mutated_line": "q.append((ii, jj, d + 0))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 0))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "q.append((ii, jj, d + 1))",
      "mutated_line": "q.append((ii, jj, d + -1))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + -1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 2] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 2] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 0] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 0] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 0] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 0] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - -1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - -1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) + 1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) + 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) * 1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) * 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t[int(map_data[i][j]) - 1].add((i, j))",
      "mutated_line": "t[int(map_data[i][j]) + 1].add((i, j))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) + 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t[int(map_data[i][j]) - 1].add((i, j))",
      "mutated_line": "t[int(map_data[i][j]) * 1].add((i, j))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) * 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 2], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 2], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 0], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 0], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 0], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 0], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)",
      "mutated_line": "dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - -1], d)",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - -1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t[int(map_data[i][j]) - 1].add((i, j))",
      "mutated_line": "t[int(map_data[i][j]) - 2].add((i, j))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 2].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t[int(map_data[i][j]) - 1].add((i, j))",
      "mutated_line": "t[int(map_data[i][j]) - 0].add((i, j))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 0].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t[int(map_data[i][j]) - 1].add((i, j))",
      "mutated_line": "t[int(map_data[i][j]) - 0].add((i, j))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - 0].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t[int(map_data[i][j]) - 1].add((i, j))",
      "mutated_line": "t[int(map_data[i][j]) - -1].add((i, j))",
      "code": "from collections import deque\n\ndef calculate_minimum_road_cells(n, m, map_data):\n    t = [set(), set(), set()]\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] in '123':\n                for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= ii < n and 0 <= jj < m:\n                        if map_data[ii][jj] in '123.' and map_data[i][j] != map_data[ii][jj]:\n                            t[int(map_data[i][j]) - -1].add((i, j))\n                            break\n    z = [[[1e+18] * 3 for j in range(m)] for i in range(n)]\n    ans = 1e+18\n    for root in range(3):\n        q = deque()\n        vi = [[False] * m for _ in range(n)]\n        for (i, j) in t[root]:\n            q.append((i, j, 0))\n            vi[i][j] = True\n            z[i][j][root] = 0\n        dist = [1e+18] * 3\n        dist[root] = 0\n        while q:\n            (i, j, d) = q.popleft()\n            for (ii, jj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= ii < n and 0 <= jj < m and (not vi[ii][jj]):\n                    if map_data[ii][jj] == '.':\n                        vi[ii][jj] = True\n                        q.append((ii, jj, d + 1))\n                        z[ii][jj][root] = min(z[ii][jj][root], d + 1)\n                    elif map_data[ii][jj] != map_data[i][j] and map_data[ii][jj] in '123':\n                        dist[int(map_data[ii][jj]) - 1] = min(dist[int(map_data[ii][jj]) - 1], d)\n        ans = min(ans, sum(dist))\n    if ans >= 1e+18:\n        return -1\n    for i in range(n):\n        for j in range(m):\n            if map_data[i][j] == '.':\n                ans = min(ans, sum(z[i][j]) - 2)\n    return ans"
    }
  ]
}