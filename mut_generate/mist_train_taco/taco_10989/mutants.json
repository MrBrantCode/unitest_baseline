{
  "task_id": "taco_10989",
  "entry_point": "find_min_roads_for_capital",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 1\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = -1\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 1\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "ans -= 1",
      "mutated_line": "ans += 1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans += 1\n        return ans\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] / (V + 1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] / (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] + (V + 1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] + (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] ** (V + 1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] ** (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "indegree[node] -= 1",
      "mutated_line": "indegree[node] += 1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] += 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return False\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 2",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 2\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 0\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 0\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans -= 1",
      "mutated_line": "ans -= -1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= -1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] * (V - 1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V - 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] * (V * 1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V * 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(2, V + 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(2, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(0, V + 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(0, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(0, V + 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(0, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(-1, V + 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(-1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V - 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V - 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V * 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V * 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "indegree[j] += 1",
      "mutated_line": "indegree[j] -= 1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] -= 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(2, V + 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(2, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(0, V + 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(0, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(0, V + 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(0, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(-1, V + 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(-1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V - 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V - 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V * 1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V * 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if indegree[i] == 0:",
      "mutated_line": "if indegree[i] != 0:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] != 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "indegree[node] -= 1",
      "mutated_line": "indegree[node] -= 2",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 2\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "indegree[node] -= 1",
      "mutated_line": "indegree[node] -= 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 0\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "indegree[node] -= 1",
      "mutated_line": "indegree[node] -= 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 0\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "indegree[node] -= 1",
      "mutated_line": "indegree[node] -= -1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= -1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "indegree[k] -= 1",
      "mutated_line": "indegree[k] += 1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] += 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i > 0:",
      "mutated_line": "if i >= 0:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i >= 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i > 0:",
      "mutated_line": "if i <= 0:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i <= 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i > 0:",
      "mutated_line": "if i != 0:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i != 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, len(adj)):",
      "mutated_line": "for i in range(2, len(adj)):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(2, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, len(adj)):",
      "mutated_line": "for i in range(0, len(adj)):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(0, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, len(adj)):",
      "mutated_line": "for i in range(0, len(adj)):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(0, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, len(adj)):",
      "mutated_line": "for i in range(-1, len(adj)):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(-1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(adj[i]) == 0:",
      "mutated_line": "if len(adj[i]) != 0:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) != 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans -= 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [1] * (V + 1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [1] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [-1] * (V + 1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [-1] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [1] * (V + 1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [1] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] * (V + 2)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 2)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] * (V + 0)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 0)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] * (V + 0)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 0)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "indegree = [0] * (V + 1)",
      "mutated_line": "indegree = [0] * (V + -1)",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + -1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V + 2):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 2):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V + 0):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 0):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V + 0):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 0):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V + -1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + -1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "indegree[j] += 1",
      "mutated_line": "indegree[j] += 2",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 2\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "indegree[j] += 1",
      "mutated_line": "indegree[j] += 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 0\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "indegree[j] += 1",
      "mutated_line": "indegree[j] += 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 0\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "indegree[j] += 1",
      "mutated_line": "indegree[j] += -1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += -1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V + 2):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 2):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V + 0):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 0):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V + 0):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 0):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(1, V + 1):",
      "mutated_line": "for i in range(1, V + -1):",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + -1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if indegree[i] == 0:",
      "mutated_line": "if indegree[i] == 1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 1:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if indegree[i] == 0:",
      "mutated_line": "if indegree[i] == -1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == -1:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if indegree[i] == 0:",
      "mutated_line": "if indegree[i] == 1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 1:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "indegree[k] -= 1",
      "mutated_line": "indegree[k] -= 2",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 2\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "indegree[k] -= 1",
      "mutated_line": "indegree[k] -= 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 0\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "indegree[k] -= 1",
      "mutated_line": "indegree[k] -= 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 0\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "indegree[k] -= 1",
      "mutated_line": "indegree[k] -= -1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= -1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if indegree[k] == 0:",
      "mutated_line": "if indegree[k] != 0:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] != 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i > 0:",
      "mutated_line": "if i > 1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 1:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i > 0:",
      "mutated_line": "if i > -1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > -1:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i > 0:",
      "mutated_line": "if i > 1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 1:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return True\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n - 1)]",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n - 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n * 1)]",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n * 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(adj[i]) == 0:",
      "mutated_line": "if len(adj[i]) == 1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 1:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(adj[i]) == 0:",
      "mutated_line": "if len(adj[i]) == -1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == -1:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(adj[i]) == 0:",
      "mutated_line": "if len(adj[i]) == 1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 1:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 2\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 0\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 0\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += -1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if indegree[k] == 0:",
      "mutated_line": "if indegree[k] == 1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 1:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if indegree[k] == 0:",
      "mutated_line": "if indegree[k] == -1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == -1:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if indegree[k] == 0:",
      "mutated_line": "if indegree[k] == 1:",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 1:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 2)]",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 2)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 0)]",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 0)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + 0)]",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + 0)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "adj = [[] for _ in range(n + -1)]",
      "code": "def find_min_roads_for_capital(n, m, roads):\n    from collections import deque\n\n    def topoSort(V, adj):\n        q = deque()\n        indegree = [0] * (V + 1)\n        for i in range(1, V + 1):\n            for j in adj[i]:\n                indegree[j] += 1\n        for i in range(1, V + 1):\n            if indegree[i] == 0:\n                q.append(i)\n        arr = []\n        while q:\n            node = q.popleft()\n            indegree[node] -= 1\n            arr.append(node)\n            for k in adj[node]:\n                indegree[k] -= 1\n                if indegree[k] == 0:\n                    q.append(k)\n        for i in indegree:\n            if i > 0:\n                return False\n        return True\n    adj = [[] for _ in range(n + -1)]\n    for (x, y) in roads:\n        adj[x].append(y)\n    ans = 0\n    if topoSort(n, adj):\n        for i in range(1, len(adj)):\n            if len(adj[i]) == 0:\n                ans += 1\n        ans -= 1\n        return ans\n    return -1"
    }
  ]
}