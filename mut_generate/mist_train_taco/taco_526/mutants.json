{
  "task_id": "taco_526",
  "entry_point": "park_cars",
  "mutant_count": 334,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = True\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if len(moves) > 20000:",
      "mutated_line": "if len(moves) >= 20000:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) >= 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if len(moves) > 20000:",
      "mutated_line": "if len(moves) <= 20000:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) <= 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if len(moves) > 20000:",
      "mutated_line": "if len(moves) != 20000:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) != 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[0]][start[1]] = 1",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 1\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[0]][start[1]] = -1",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = -1\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[0]][start[1]] = 1",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 1\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if parking_lot[1][pos] == 0:",
      "mutated_line": "if parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] != 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] != 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return +1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for cnt in range(20000):",
      "mutated_line": "for cnt in range(20001):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20001):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for cnt in range(20000):",
      "mutated_line": "for cnt in range(19999):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(19999):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for cnt in range(20000):",
      "mutated_line": "for cnt in range(0):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(0):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for cnt in range(20000):",
      "mutated_line": "for cnt in range(1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(1):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for cnt in range(20000):",
      "mutated_line": "for cnt in range(-20000):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(-20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 or parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 or parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 or parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 or parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if len(moves) > 20000:",
      "mutated_line": "if len(moves) > 20001:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20001:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if len(moves) > 20000:",
      "mutated_line": "if len(moves) > 19999:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 19999:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if len(moves) > 20000:",
      "mutated_line": "if len(moves) > 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 0:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if len(moves) > 20000:",
      "mutated_line": "if len(moves) > 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 1:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if len(moves) > 20000:",
      "mutated_line": "if len(moves) > -20000:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > -20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "UOI",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return +1\n    return (len(moves), moves)"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[0][pos] or parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] or parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[3][pos] or parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] or parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if parking_lot[1][pos] == 0:",
      "mutated_line": "if parking_lot[1][pos] == 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 1:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if parking_lot[1][pos] == 0:",
      "mutated_line": "if parking_lot[1][pos] == -1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == -1:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if parking_lot[1][pos] == 0:",
      "mutated_line": "if parking_lot[1][pos] == 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 1:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = False\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[2][pos] == 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 1:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[2][pos] == -1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == -1:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[2][pos] == 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 1:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = False\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -2\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -0\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -0\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return --1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] == 0 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] == 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] != 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n != 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for pos in range(1, n):",
      "mutated_line": "for pos in range(2, n):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(2, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for pos in range(1, n):",
      "mutated_line": "for pos in range(0, n):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(0, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for pos in range(1, n):",
      "mutated_line": "for pos in range(0, n):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(0, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for pos in range(1, n):",
      "mutated_line": "for pos in range(-1, n):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(-1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 or parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 or parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] != 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] != 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] == 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n + 2, -1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n + 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n * 2, -1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n * 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, +1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, +1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, -1, +1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, +1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 or parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 or parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -2\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -0\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -0\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return --1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] - 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] - 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] * 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] * 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] - 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] * 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] * 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[2]] = parking_lot[start[0]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[2]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[0]] = parking_lot[start[0]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[0]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[0]] = parking_lot[start[0]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[0]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[-1]] = parking_lot[start[0]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[-1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[2]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[2]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[0]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[0]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[0]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[0]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[-1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[-1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[0]][start[2]] = 0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[2]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[0]][start[0]] = 0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[0]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[0]][start[0]] = 0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[0]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[0]][start[-1]] = 0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[-1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] != parking_lot[0][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] != parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] != parking_lot[3][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] != parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 1 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 1 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != -1 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != -1 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 1 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 1 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 1:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == -1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == -1:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 1:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 2:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 0:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 0:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == -1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] != 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] != 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] == 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 1 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 1 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == -1 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == -1 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 1 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 1 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 1:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != -1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != -1:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 1:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 3, -1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 3, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 1, -1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 1, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 0, -1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 0, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 1, -1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 1, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - -2, -1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - -2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, -2, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -2, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, -0, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -0, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, -0, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -0, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, --1, -1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, --1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, -1, -2):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -2):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, -1, -0):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -0):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, -1, -0):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -0):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for pos in range(n - 2, -1, -1):",
      "mutated_line": "for pos in range(n - 2, -1, --1):",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, --1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] != 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] != 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] == 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 2, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 2, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 0, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 0, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 0, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 0, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + -1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + -1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 2))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 2))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 0))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 0))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + -1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + -1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[1]][finish[1]] = parking_lot[start[0]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[1]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[-1]][finish[1]] = parking_lot[start[0]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[-1]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[1]][finish[1]] = parking_lot[start[0]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[1]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[1]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[1]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[-1]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[-1]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]",
      "mutated_line": "parking_lot[finish[0]][finish[1]] = parking_lot[start[1]][start[1]]",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[1]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[1]][start[1]] = 0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[1]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[-1]][start[1]] = 0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[-1]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "parking_lot[start[0]][start[1]] = 0",
      "mutated_line": "parking_lot[start[1]][start[1]] = 0",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[1]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if parking_lot[1][pos] == 0:",
      "mutated_line": "if parking_lot[2][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if parking_lot[1][pos] == 0:",
      "mutated_line": "if parking_lot[0][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[0][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if parking_lot[1][pos] == 0:",
      "mutated_line": "if parking_lot[0][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[0][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if parking_lot[1][pos] == 0:",
      "mutated_line": "if parking_lot[-1][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[-1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[3][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[3][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[1][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[0][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[0][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[1][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if parking_lot[2][pos] == 0:",
      "mutated_line": "if parking_lot[-2][pos] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[-2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][1] != 0 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][1] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][-1] != 0 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][-1] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][1] != 0 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][1] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[2][1] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][1] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[2][-1] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][-1] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[2][1] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][1] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((2, 0), (2, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((2, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((0, 0), (2, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((0, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((0, 0), (2, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((0, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((-1, 0), (2, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((-1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 1), (2, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 1), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, -1), (2, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, -1), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 1), (2, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 1), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 0), (3, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (3, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 0), (1, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (1, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 0), (0, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (0, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 0), (1, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (1, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 0), (-2, 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (-2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 0), (2, 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 1))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 0), (2, -1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, -1))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "make_move((1, 0), (2, 0))",
      "mutated_line": "make_move((1, 0), (2, 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 1))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 1 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 1 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == -1 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == -1 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 1 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 1 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 1:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != -1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != -1:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 1:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n + 1] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n + 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n * 1] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n * 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n + 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n + 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n * 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n * 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((3, n - 1), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((3, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((1, n - 1), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((1, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((0, n - 1), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((0, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((1, n - 1), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((1, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((-2, n - 1), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((-2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n + 1), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n + 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n * 1), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n * 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (2, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (2, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (0, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (0, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (0, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (0, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (-1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (-1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (1, n + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n + 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (1, n * 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n * 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 1 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 1 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == -1 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == -1 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 1 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 1 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 1:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != -1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != -1:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 1:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 1:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[2]], finish[0] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[2]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[0]], finish[0] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[0]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[0]], finish[0] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[0]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[-1]], finish[0] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[-1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[1] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[1] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[-1] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[-1] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[1] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[1] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[2] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[2] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[0] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[0] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[0] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[0] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[-1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[-1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[2][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[0][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[0][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[0][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[0][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[-1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[-1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "make_move((1, pos), (0, pos))",
      "mutated_line": "make_move((2, pos), (0, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((2, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "make_move((1, pos), (0, pos))",
      "mutated_line": "make_move((0, pos), (0, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((0, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "make_move((1, pos), (0, pos))",
      "mutated_line": "make_move((0, pos), (0, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((0, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "make_move((1, pos), (0, pos))",
      "mutated_line": "make_move((-1, pos), (0, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((-1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "make_move((1, pos), (0, pos))",
      "mutated_line": "make_move((1, pos), (1, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (1, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "make_move((1, pos), (0, pos))",
      "mutated_line": "make_move((1, pos), (-1, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (-1, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "make_move((1, pos), (0, pos))",
      "mutated_line": "make_move((1, pos), (1, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (1, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[3][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[3][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[1][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[0][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[0][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[1][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[-2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[-2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((3, pos), (3, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((3, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((1, pos), (3, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((1, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((0, pos), (3, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((0, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((1, pos), (3, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((1, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((-2, pos), (3, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((-2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((2, pos), (4, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (4, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((2, pos), (2, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (2, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((2, pos), (0, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (0, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((2, pos), (1, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (1, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "make_move((2, pos), (3, pos))",
      "mutated_line": "make_move((2, pos), (-3, pos))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (-3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[2][0] != 0 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[2][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[0][0] != 0 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[0][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[0][0] != 0 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[0][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[-1][0] != 0 and parking_lot[2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[-1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[3][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[3][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[1][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[1][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[0][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[0][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[1][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[1][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:",
      "mutated_line": "if parking_lot[1][0] != 0 and parking_lot[-2][0] == 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[-2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos + 1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos + 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos * 1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos * 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((2, pos), (1, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((2, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((0, pos), (1, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((0, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((0, pos), (1, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((0, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((-1, pos), (1, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((-1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (2, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (2, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (0, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (0, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (0, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (0, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (-1, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (-1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (1, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos + 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (1, pos * 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos * 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[2][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[2][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[0][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[0][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[0][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[0][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[-1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[-1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 2] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 2] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 0] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 0] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 0] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 0] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - -1] == 0 and parking_lot[2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - -1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[3][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[3][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[1][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[1][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[0][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[0][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[1][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[1][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[-2][n - 1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[-2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 2] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 2] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 0] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 0] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 0] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 0] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:",
      "mutated_line": "if parking_lot[1][n - 1] == 0 and parking_lot[2][n - -1] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - -1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 2), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 2), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 0), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 0), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 0), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 0), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - -1), (1, n - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - -1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (1, n - 2))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 2))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (1, n - 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 0))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (1, n - 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 0))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "make_move((2, n - 1), (1, n - 1))",
      "mutated_line": "make_move((2, n - 1), (1, n - -1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - -1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos - 1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos - 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos * 1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos * 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((3, pos), (2, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((3, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((1, pos), (2, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((1, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((0, pos), (2, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((0, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((1, pos), (2, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((1, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((-2, pos), (2, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((-2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (3, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (3, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (1, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (1, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (0, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (0, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (1, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (1, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (-2, pos + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (-2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (2, pos - 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos - 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (2, pos * 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos * 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[1]][start[1]], finish[0] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[1]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[-1]][start[1]], finish[0] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[-1]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))",
      "mutated_line": "moves.append((parking_lot[start[1]][start[1]], finish[0] + 1, finish[1] + 1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[1]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[2][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[0][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[0][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[0][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[0][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[-1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[-1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[1][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[1][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[-1][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[-1][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[1][pos] and parking_lot[1][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[1][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[3][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[3][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[1][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[0][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[0][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[1][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[1][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[-2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[-2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[4][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[4][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[2][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[2][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[0][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[0][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[1][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[1][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:",
      "mutated_line": "if parking_lot[2][pos] == parking_lot[-3][pos] and parking_lot[2][pos]:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[-3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[2][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[0][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[0][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[0][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[0][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[-1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[-1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 2] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 2] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 0] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 0] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 0] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 0] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - -1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - -1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[0][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[0][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[0][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[0][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos - 1] == 0 and parking_lot[-1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[-1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (1, pos - 2))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 2))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (1, pos - 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 0))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (1, pos - 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 0))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "make_move((1, pos), (1, pos - 1))",
      "mutated_line": "make_move((1, pos), (1, pos - -1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - -1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[3][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[3][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[1][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[0][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[0][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[1][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[1][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[-2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[-2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 2] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 2] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 0] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 0] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 0] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 0] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + -1] == 0 and parking_lot[2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + -1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[3][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[3][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[0][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[0][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[1][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:",
      "mutated_line": "if parking_lot[2][pos + 1] == 0 and parking_lot[-2][pos] != 0:",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[-2][pos] != 0:\n                make_move((2, pos), (2, pos + 1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (2, pos + 2))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 2))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (2, pos + 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 0))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (2, pos + 0))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + 0))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "make_move((2, pos), (2, pos + 1))",
      "mutated_line": "make_move((2, pos), (2, pos + -1))",
      "code": "def park_cars(n, k, parking_lot):\n    moves = []\n\n    def make_move(start, finish):\n        moves.append((parking_lot[start[0]][start[1]], finish[0] + 1, finish[1] + 1))\n        parking_lot[finish[0]][finish[1]] = parking_lot[start[0]][start[1]]\n        parking_lot[start[0]][start[1]] = 0\n\n    def move_all_to_places():\n        for pos in range(n):\n            if parking_lot[1][pos] == parking_lot[0][pos] and parking_lot[1][pos]:\n                make_move((1, pos), (0, pos))\n            if parking_lot[2][pos] == parking_lot[3][pos] and parking_lot[2][pos]:\n                make_move((2, pos), (3, pos))\n    move_all_to_places()\n    found = False\n    for pos in range(n):\n        if parking_lot[1][pos] == 0:\n            found = True\n            break\n        if parking_lot[2][pos] == 0:\n            found = True\n            break\n    if not found:\n        return -1\n    for cnt in range(20000):\n        if parking_lot[1][0] != 0 and parking_lot[2][0] == 0:\n            make_move((1, 0), (2, 0))\n            if n == 1:\n                continue\n        for pos in range(1, n):\n            if parking_lot[1][pos - 1] == 0 and parking_lot[1][pos] != 0:\n                make_move((1, pos), (1, pos - 1))\n        move_all_to_places()\n        if parking_lot[1][n - 1] == 0 and parking_lot[2][n - 1] != 0:\n            make_move((2, n - 1), (1, n - 1))\n        for pos in range(n - 2, -1, -1):\n            if parking_lot[2][pos + 1] == 0 and parking_lot[2][pos] != 0:\n                make_move((2, pos), (2, pos + -1))\n        move_all_to_places()\n    if len(moves) > 20000:\n        return -1\n    return (len(moves), moves)"
    }
  ]
}