{
  "task_id": "taco_12663",
  "entry_point": "find_minimum_adjustment",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "adj = 0",
      "mutated_line": "adj = 1",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 1\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "adj = 0",
      "mutated_line": "adj = -1",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = -1\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "adj = 0",
      "mutated_line": "adj = 1",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 1\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(2, max_t // 2 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(2, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(0, max_t // 2 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(0, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(0, max_t // 2 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(0, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(-1, max_t // 2 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(-1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 2 - 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 - 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 2 * 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 * 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if max_t % i == 0:",
      "mutated_line": "if max_t % i != 0:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i != 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t / 2 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t / 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t * 2 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t * 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 2 + 2):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 2):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 2 + 0):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 0):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 2 + 0):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 0):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 2 + -1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + -1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if max_t % i == 0:",
      "mutated_line": "if max_t * i == 0:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t * i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if max_t % i == 0:",
      "mutated_line": "if max_t + i == 0:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t + i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if max_t % i == 0:",
      "mutated_line": "if max_t % i == 1:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 1:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if max_t % i == 0:",
      "mutated_line": "if max_t % i == -1:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == -1:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if max_t % i == 0:",
      "mutated_line": "if max_t % i == 1:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 1:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if d >= t:",
      "mutated_line": "if d > t:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d > t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if d >= t:",
      "mutated_line": "if d < t:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d < t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if d >= t:",
      "mutated_line": "if d == t:",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d == t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "adj += d - t",
      "mutated_line": "adj -= d - t",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj -= d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 3 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 3 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 1 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 1 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 0 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 0 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // 1 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 1 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, (max_t // 2) + 1):",
      "mutated_line": "for i in range(1, max_t // -2 + 1):",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // -2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d - t\n                break\n    return adj"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj += d - t",
      "mutated_line": "adj += d + t",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d + t\n                break\n    return adj"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "adj += d - t",
      "mutated_line": "adj += d * t",
      "code": "def find_minimum_adjustment(intervals):\n    \"\"\"\n    Calculate the minimum value of the sum of all adjustments (d_i) needed to make all metronomes tick in unison at the shortest interval.\n\n    Parameters:\n    intervals (list of int): A list of integers representing the preset ticking intervals of the metronomes.\n\n    Returns:\n    int: The minimum value of the sum of all adjustments.\n    \"\"\"\n    n = len(intervals)\n    max_t = max(intervals)\n    divisors = []\n    for i in range(1, max_t // 2 + 1):\n        if max_t % i == 0:\n            divisors.append(i)\n    divisors.append(max_t)\n    adj = 0\n    for t in intervals:\n        for d in divisors:\n            if d >= t:\n                adj += d * t\n                break\n    return adj"
    }
  ]
}