{
  "task_id": "taco_14734",
  "entry_point": "find_hopping_number",
  "mutant_count": 152,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 1\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = -1\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 1\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "return ans + 1",
      "mutated_line": "return ans - 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans - 1"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "return ans + 1",
      "mutated_line": "return ans * 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans * 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 1\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = -1\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 1\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ind = 0",
      "mutated_line": "ind = 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 1\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ind = 0",
      "mutated_line": "ind = -1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = -1\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "ind = 0",
      "mutated_line": "ind = 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 1\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 1 and ind == len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 and ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] > s2[ind] or s1[ind] in s2[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] or s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] < s2[ind] or s2[ind] in s1[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] or s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 2\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 0\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 0\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return -1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(s1) < len(s2):",
      "mutated_line": "if len(s1) <= len(s2):",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) <= len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(s1) < len(s2):",
      "mutated_line": "if len(s1) >= len(s2):",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) >= len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if len(s1) < len(s2):",
      "mutated_line": "if len(s1) != len(s2):",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) != len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if cost[k] > 0:",
      "mutated_line": "if cost[k] >= 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] >= 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if cost[k] > 0:",
      "mutated_line": "if cost[k] <= 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] <= 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if cost[k] > 0:",
      "mutated_line": "if cost[k] != 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] != 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cost = {i: 0 for i in range(n)}",
      "mutated_line": "cost = {i: 1 for i in range(n)}",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 1 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cost = {i: 0 for i in range(n)}",
      "mutated_line": "cost = {i: -1 for i in range(n)}",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: -1 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cost = {i: 0 for i in range(n)}",
      "mutated_line": "cost = {i: 1 for i in range(n)}",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 1 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return ans + 1",
      "mutated_line": "return ans + 2",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 2"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return ans + 1",
      "mutated_line": "return ans + 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 0"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return ans + 1",
      "mutated_line": "return ans + 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 0"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return ans + 1",
      "mutated_line": "return ans + -1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + -1"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if s1[i] != s2[i]:",
      "mutated_line": "if s1[i] == s2[i]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] == s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c -= 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c >= 1 or ind == len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c >= 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c <= 1 or ind == len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c <= 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c != 1 or ind == len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c != 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 1 or ind != len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind != len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 1\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return -1\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 1\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] >= s2[ind] and s1[ind] in s2[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] >= s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] <= s2[ind] and s1[ind] in s2[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] <= s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] != s2[ind] and s1[ind] in s2[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] != s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] > s2[ind] and s1[ind] not in s2[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] not in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0] = True",
      "mutated_line": "p[0] = False",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = False\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] <= s2[ind] and s2[ind] in s1[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] <= s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] >= s2[ind] and s2[ind] in s1[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] >= s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] != s2[ind] and s2[ind] in s1[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] != s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] < s2[ind] and s2[ind] not in s1[ind + 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] not in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[1] = True",
      "mutated_line": "p[1] = False",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = False\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cost[k] > 0:",
      "mutated_line": "if cost[k] > 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 1:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cost[k] > 0:",
      "mutated_line": "if cost[k] > -1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > -1:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cost[k] > 0:",
      "mutated_line": "if cost[k] > 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 1:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if i != j:",
      "mutated_line": "if i == j:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 2\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 0\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 0\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += -1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 2 or ind == len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 2 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 0 or ind == len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 0 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 0 or ind == len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 0 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > -1 or ind == len(s1) - 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > -1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 1 or ind == len(s1) + 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) + 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 1 or ind == len(s1) * 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) * 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0] = True",
      "mutated_line": "p[1] = True",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[1] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0] = True",
      "mutated_line": "p[-1] = True",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[-1] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "p[0] = True",
      "mutated_line": "p[1] = True",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[1] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[1] = True",
      "mutated_line": "p[2] = True",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[2] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[1] = True",
      "mutated_line": "p[0] = True",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[0] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[1] = True",
      "mutated_line": "p[0] = True",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[0] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p[1] = True",
      "mutated_line": "p[-1] = True",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[-1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] + s2[i + 1:] != s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] != s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] + s1[i + 1:] != s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] != s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cost[k] = max(cost[k], longest(i) + 1)",
      "mutated_line": "cost[k] = max(cost[k], longest(i) - 1)",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) - 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cost[k] = max(cost[k], longest(i) + 1)",
      "mutated_line": "cost[k] = max(cost[k], longest(i) * 1)",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) * 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if len(words[i]) == len(words[j]):",
      "mutated_line": "if len(words[i]) != len(words[j]):",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) != len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 1 or ind == len(s1) - 2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 2:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 1 or ind == len(s1) - 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 0:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 1 or ind == len(s1) - 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 0:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if c > 1 or ind == len(s1) - 1:",
      "mutated_line": "if c > 1 or ind == len(s1) - -1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - -1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] - s2[i + 1:] == s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] - s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] * s2[i + 1:] == s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] * s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 2\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 0\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 0\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return -1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] - s1[i + 1:] == s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] - s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] * s1[i + 1:] == s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] * s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 2",
      "mutated_line": "return 3",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 3\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 1\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 2",
      "mutated_line": "return 0",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 0\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 1\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 2",
      "mutated_line": "return -2",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return -2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[k] = max(cost[k], longest(i) + 1)",
      "mutated_line": "cost[k] = max(cost[k], longest(i) + 2)",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 2)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[k] = max(cost[k], longest(i) + 1)",
      "mutated_line": "cost[k] = max(cost[k], longest(i) + 0)",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 0)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[k] = max(cost[k], longest(i) + 1)",
      "mutated_line": "cost[k] = max(cost[k], longest(i) + 0)",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 0)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[k] = max(cost[k], longest(i) + 1)",
      "mutated_line": "cost[k] = max(cost[k], longest(i) + -1)",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + -1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "p = [False, False]",
      "mutated_line": "p = [True, False]",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [True, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "p = [False, False]",
      "mutated_line": "p = [False, True]",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, True]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "elif abs(len(words[i]) - len(words[j])) == 1:",
      "mutated_line": "elif abs(len(words[i]) - len(words[j])) != 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) != 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind - 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind - 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind * 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind * 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind - 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind - 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind * 1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind * 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if p[0] == True:",
      "mutated_line": "if p[0] != True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] != True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if p[1] == True:",
      "mutated_line": "if p[1] != True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] != True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif abs(len(words[i]) - len(words[j])) == 1:",
      "mutated_line": "elif abs(len(words[i]) - len(words[j])) == 2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 2:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif abs(len(words[i]) - len(words[j])) == 1:",
      "mutated_line": "elif abs(len(words[i]) - len(words[j])) == 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 0:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif abs(len(words[i]) - len(words[j])) == 1:",
      "mutated_line": "elif abs(len(words[i]) - len(words[j])) == 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 0:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif abs(len(words[i]) - len(words[j])) == 1:",
      "mutated_line": "elif abs(len(words[i]) - len(words[j])) == -1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == -1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if y == 1:",
      "mutated_line": "if y != 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y != 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if y == 2:",
      "mutated_line": "if y != 2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y != 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 2:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 2:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 0:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 0:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 0:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 0:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:",
      "mutated_line": "if s1[ind] > s2[ind] and s1[ind] in s2[ind + -1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + -1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 2:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 2:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 0:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 0:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 0:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 0:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:",
      "mutated_line": "if s1[ind] < s2[ind] and s2[ind] in s1[ind + -1:]:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + -1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if p[0] == True:",
      "mutated_line": "if p[0] == False:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == False:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if p[1] == True:",
      "mutated_line": "if p[1] == False:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == False:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "elif abs(len(words[i]) - len(words[j])) == 1:",
      "mutated_line": "elif abs(len(words[i]) + len(words[j])) == 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) + len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "elif abs(len(words[i]) - len(words[j])) == 1:",
      "mutated_line": "elif abs(len(words[i]) * len(words[j])) == 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) * len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if y == 1:",
      "mutated_line": "if y == 2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 2:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if y == 1:",
      "mutated_line": "if y == 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 0:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if y == 1:",
      "mutated_line": "if y == 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 0:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if y == 1:",
      "mutated_line": "if y == -1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == -1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if y == 2:",
      "mutated_line": "if y == 3:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 3:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if y == 2:",
      "mutated_line": "if y == 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 1:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if y == 2:",
      "mutated_line": "if y == 0:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 0:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if y == 2:",
      "mutated_line": "if y == 1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 1:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if y == 2:",
      "mutated_line": "if y == -2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == -2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] + s2[i - 1:] == s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i - 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] + s2[i * 1:] == s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i * 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] + s1[i - 1:] == s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i - 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] + s1[i * 1:] == s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i * 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if p[0] == True:",
      "mutated_line": "if p[1] == True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[1] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if p[0] == True:",
      "mutated_line": "if p[-1] == True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[-1] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if p[0] == True:",
      "mutated_line": "if p[1] == True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[1] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if p[1] == True:",
      "mutated_line": "if p[2] == True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[2] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if p[1] == True:",
      "mutated_line": "if p[0] == True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[0] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if p[1] == True:",
      "mutated_line": "if p[0] == True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[0] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if p[1] == True:",
      "mutated_line": "if p[-1] == True:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[-1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] + s2[i + 2:] == s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 2:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] + s2[i + 0:] == s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 0:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] + s2[i + 0:] == s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 0:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s2[:i] + s2[i + 1:] == s1:",
      "mutated_line": "if s2[:i] + s2[i + -1:] == s1:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + -1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] + s1[i + 2:] == s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 2:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] + s1[i + 0:] == s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 0:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] + s1[i + 0:] == s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + 0:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if s1[:i] + s1[i + 1:] == s2:",
      "mutated_line": "if s1[:i] + s1[i + -1:] == s2:",
      "code": "def find_hopping_number(words):\n\n    def codn1(s1, s2, p):\n        c = 0\n        ind = 0\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                c += 1\n                ind = i\n        if c > 1 or ind == len(s1) - 1:\n            return 0\n        if s1[ind] > s2[ind] and s1[ind] in s2[ind + 1:]:\n            p[0] = True\n        if s1[ind] < s2[ind] and s2[ind] in s1[ind + 1:]:\n            p[1] = True\n        return 1\n\n    def codn2(s1, s2):\n        if len(s1) < len(s2):\n            for i in range(len(s2)):\n                if s2[:i] + s2[i + 1:] == s1:\n                    return 1\n        else:\n            for i in range(len(s1)):\n                if s1[:i] + s1[i + -1:] == s2:\n                    return 2\n\n    def longest(k):\n        if cost[k] > 0:\n            return cost[k]\n        for i in list(d[k]):\n            cost[k] = max(cost[k], longest(i) + 1)\n        return cost[k]\n    n = len(words)\n    d = {i: [] for i in range(n)}\n    cost = {i: 0 for i in range(n)}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p = [False, False]\n                if len(words[i]) == len(words[j]):\n                    if codn1(words[i], words[j], p):\n                        if p[0] == True:\n                            d[j].append(i)\n                        if p[1] == True:\n                            d[i].append(j)\n                elif abs(len(words[i]) - len(words[j])) == 1:\n                    y = codn2(words[i], words[j])\n                    if y == 1:\n                        d[j].append(i)\n                    if y == 2:\n                        d[i].append(j)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, longest(i))\n    return ans + 1"
    }
  ]
}