{
  "task_id": "taco_18541",
  "entry_point": "min_traffic_inversions",
  "mutant_count": 208,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] or a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] or a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] != a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] != a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] != a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] != a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] != a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] != a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 1\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return -1\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 1\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [1, 0, 0]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [1, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [-1, 0, 0]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [-1, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [1, 0, 0]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [1, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [0, 1, 0]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 1, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [0, -1, 0]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, -1, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [0, 1, 0]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 1, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [0, 0, 1]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 1]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [0, 0, -1]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, -1]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "big = [0, 0, 0]",
      "mutated_line": "big = [0, 0, 1]",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 1]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (1, 1, 2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (1, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (-1, 1, 2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (-1, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (1, 1, 2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (1, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, 2, 2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 2, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, 0, 2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 0, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, 0, 2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 0, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, -1, 2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, -1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, 1, 3):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 3):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, 1, 1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 1):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, 1, 0):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 0):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, 1, 1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 1):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in (0, 1, 2):",
      "mutated_line": "for i in (0, 1, -2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, -2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "w = 2",
      "mutated_line": "w = 3",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 3\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "w = 2",
      "mutated_line": "w = 1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 1\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "w = 2",
      "mutated_line": "w = 0",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 0\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "w = 2",
      "mutated_line": "w = 1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 1\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "w = 2",
      "mutated_line": "w = -2",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = -2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] != a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] != a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) - min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) - min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) * min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) * min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n + 2, -1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n + 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n * 2, -1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n * 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, +1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, +1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, +1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, +1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if a[i][j] != a[i][n - 1]:",
      "mutated_line": "if a[i][j] == a[i][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] == a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n + 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n + 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n * 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n * 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n + 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n + 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n * 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n * 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "w = 1",
      "mutated_line": "w = 2",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 2\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "w = 1",
      "mutated_line": "w = 0",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 0\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "w = 1",
      "mutated_line": "w = 0",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 0\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "w = 1",
      "mutated_line": "w = -1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = -1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] != a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] != a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n + 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n + 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n * 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n * 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n + 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n + 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n * 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n * 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n + 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n + 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n * 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n * 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n + 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n + 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n * 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n * 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 3, -1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 3, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 1, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 0, -1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 0, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 1, -1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 1, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - -2, -1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - -2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -2, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -2, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -0, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -0, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -0, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -0, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, --1, -1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, --1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, -2):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -2):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, -0):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -0):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, -0):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -0):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(n - 2, -1, -1):",
      "mutated_line": "for j in range(n - 2, -1, --1):",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, --1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "big[i] = j + 1",
      "mutated_line": "big[i] = j - 1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j - 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "big[i] = j + 1",
      "mutated_line": "big[i] = j * 1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j * 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[1][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[1][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[-1][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[-1][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[1][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[1][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 2] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 2] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 0] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 0] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 0] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 0] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - -1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - -1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[2][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[0][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[0][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[0][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[0][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[-1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[-1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 2]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 2]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 0]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 0]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if a[0][n - 1] == a[1][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - -1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - -1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n + 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n + 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n * 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n * 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[2][n + 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n + 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[2][n * 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n * 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 1\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "w = 0",
      "mutated_line": "w = -1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = -1\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 1\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n + big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n + big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n * big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n * big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n + big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n + big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n * big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n * big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n + big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n + big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n * big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n * big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n + big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n + big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n * big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n * big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[1][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[1][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[-1][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[-1][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[1][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[1][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 2] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 2] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 0] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 0] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 0] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 0] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - -1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - -1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[2][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[2][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[0][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[0][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[0][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[0][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[-1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[-1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 2] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 2] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 0] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 0] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 0] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 0] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - -1] and a[0][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - -1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[1][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[1][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[-1][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[-1][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[1][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[1][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 2] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 2] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 0] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 0] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 0] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 0] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - -1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - -1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[3][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[3][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[1][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[0][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[0][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[1][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[-2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[-2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 2]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 2]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 0]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 0]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - -1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - -1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if a[i][j] != a[i][n - 1]:",
      "mutated_line": "if a[i][j] != a[i][n + 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n + 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if a[i][j] != a[i][n - 1]:",
      "mutated_line": "if a[i][j] != a[i][n * 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n * 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "big[i] = j + 1",
      "mutated_line": "big[i] = j + 2",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 2\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "big[i] = j + 1",
      "mutated_line": "big[i] = j + 0",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 0\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "big[i] = j + 1",
      "mutated_line": "big[i] = j + 0",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 0\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "big[i] = j + 1",
      "mutated_line": "big[i] = j + -1",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + -1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[1][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[1][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[-1][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[-1][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[1][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[1][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 2] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 2] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 0] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 0] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 0] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 0] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - -1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - -1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[3][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[3][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[1][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[0][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[0][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[1][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[-2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[-2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[2][n - 2]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 2]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[2][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 0]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[2][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 0]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif a[0][n - 1] == a[2][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[2][n - -1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - -1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n + 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n + 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n * 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n * 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[1][n + 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n + 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[1][n * 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n * 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if a[i][j] != a[i][n - 1]:",
      "mutated_line": "if a[i][j] != a[i][n - 2]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 2]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if a[i][j] != a[i][n - 1]:",
      "mutated_line": "if a[i][j] != a[i][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 0]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if a[i][j] != a[i][n - 1]:",
      "mutated_line": "if a[i][j] != a[i][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 0]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if a[i][j] != a[i][n - 1]:",
      "mutated_line": "if a[i][j] != a[i][n - -1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - -1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[3][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[3][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[1][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[1][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[0][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[0][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[1][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[1][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[-2][n - 1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[-2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 2] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 2] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 0] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 0] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 0] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 0] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - -1] == a[1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - -1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[2][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[2][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[0][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[0][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[0][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[0][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[-1][n - 1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[-1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[1][n - 2]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 2]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[1][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 0]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[1][n - 0]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 0]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif a[2][n - 1] == a[1][n - 1]:",
      "mutated_line": "elif a[2][n - 1] == a[1][n - -1]:",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - -1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) * 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) * 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[w + 1 + 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[w + 1 + 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) * 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) * 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[w + 2 + 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[w + 2 + 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w - 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w - 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[w * 1 % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[w * 1 % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 4]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 4]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 2]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 2]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 0]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 0]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 1]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 1]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % -3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % -3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w - 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w - 2) % 3]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[w * 2 % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[w * 2 % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 4]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 4]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 2]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 2]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 0]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 0]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 1]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 1]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % -3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % -3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 2) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 2) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 0) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 0) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 0) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 0) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + -1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + -1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 3) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 3) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 1) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 1) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 0) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 0) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 1) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 1) % 3]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + 2) % 3]))",
      "mutated_line": "return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + -2) % 3]))",
      "code": "def min_traffic_inversions(n, directions):\n    a = directions\n    if a[0][n - 1] == a[1][n - 1] and a[0][n - 1] == a[2][n - 1]:\n        return 0\n    big = [0, 0, 0]\n    for i in (0, 1, 2):\n        for j in range(n - 2, -1, -1):\n            if a[i][j] != a[i][n - 1]:\n                big[i] = j + 1\n                break\n    if a[0][n - 1] == a[1][n - 1]:\n        w = 2\n    elif a[0][n - 1] == a[2][n - 1]:\n        w = 1\n    elif a[2][n - 1] == a[1][n - 1]:\n        w = 0\n    return min(n, min(n - big[w], n - big[(w + 1) % 3]) + min(n - big[w], n - big[(w + -2) % 3]))"
    }
  ]
}