{
  "task_id": "taco_545",
  "entry_point": "max_additional_edges",
  "mutant_count": 117,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "node = [-1] * N",
      "mutated_line": "node = [-1] / N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] / N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "node = [-1] * N",
      "mutated_line": "node = [-1] + N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] + N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "node = [-1] * N",
      "mutated_line": "node = [-1] ** N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] ** N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[0] = 0",
      "mutated_line": "node[0] = 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 1\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[0] = 0",
      "mutated_line": "node[0] = -1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = -1\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[0] = 0",
      "mutated_line": "node[0] = 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 1\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [0] / 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] / 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [0] + 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] + 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [0] ** 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] ** 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 1\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = -1\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 1\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans -= d[1 - node[i]] - len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans -= d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return ans // 2",
      "mutated_line": "return ans / 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans / 2"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "return ans // 2",
      "mutated_line": "return ans * 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans * 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[0] = 0",
      "mutated_line": "node[1] = 0",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[1] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[0] = 0",
      "mutated_line": "node[-1] = 0",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[-1] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "node[0] = 0",
      "mutated_line": "node[1] = 0",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[1] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [0] * 3",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 3\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [0] * 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 1\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [0] * 0",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 0\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [0] * 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 1\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [0] * -2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * -2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[1] = N + 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N + 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[1] = N * 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N * 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "node = [0] * N",
      "mutated_line": "node = [0] / N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] / N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "node = [0] * N",
      "mutated_line": "node = [0] + N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] + N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "node = [0] * N",
      "mutated_line": "node = [0] ** N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] ** N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans += d[1 - node[i]] + len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] + len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans += d[1 - node[i]] * len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] * len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans // 2",
      "mutated_line": "return ans // 3",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 3"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans // 2",
      "mutated_line": "return ans // 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans // 2",
      "mutated_line": "return ans // 0",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans // 2",
      "mutated_line": "return ans // 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return ans // 2",
      "mutated_line": "return ans // -2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // -2"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b + 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b + 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b * 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b * 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a + 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a + 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a * 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a * 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "node = [-1] * N",
      "mutated_line": "node = [+1] * N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [+1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append((0, 0))",
      "mutated_line": "q.append((1, 0))",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((1, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append((0, 0))",
      "mutated_line": "q.append((-1, 0))",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((-1, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append((0, 0))",
      "mutated_line": "q.append((1, 0))",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((1, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append((0, 0))",
      "mutated_line": "q.append((0, 1))",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 1))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append((0, 0))",
      "mutated_line": "q.append((0, -1))",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, -1))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append((0, 0))",
      "mutated_line": "q.append((0, 1))",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 1))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [1] * 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [1] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [-1] * 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [-1] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "d = [0] * 2",
      "mutated_line": "d = [1] * 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [1] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if c == node[v]:",
      "mutated_line": "if c != node[v]:",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c != node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if node[v] < 0:",
      "mutated_line": "if node[v] <= 0:",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] <= 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if node[v] < 0:",
      "mutated_line": "if node[v] >= 0:",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] >= 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if node[v] < 0:",
      "mutated_line": "if node[v] != 0:",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] != 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[2] = N - 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[2] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[0] = N - 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[0] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[0] = N - 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[0] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[-1] = N - 1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[-1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[1] = N - 2",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 2\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[1] = N - 0",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 0\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[1] = N - 0",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 0\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "d[1] = N - 1",
      "mutated_line": "d[1] = N - -1",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - -1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[0] = node.count(0)",
      "mutated_line": "d[1] = node.count(0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[1] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[0] = node.count(0)",
      "mutated_line": "d[-1] = node.count(0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[-1] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[0] = node.count(0)",
      "mutated_line": "d[1] = node.count(0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[1] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[0] = node.count(0)",
      "mutated_line": "d[0] = node.count(1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(1)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[0] = node.count(0)",
      "mutated_line": "d[0] = node.count(-1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(-1)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d[0] = node.count(0)",
      "mutated_line": "d[0] = node.count(1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(1)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d[1] = node.count(1)",
      "mutated_line": "d[2] = node.count(1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[2] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d[1] = node.count(1)",
      "mutated_line": "d[0] = node.count(1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[0] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d[1] = node.count(1)",
      "mutated_line": "d[0] = node.count(1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[0] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d[1] = node.count(1)",
      "mutated_line": "d[-1] = node.count(1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[-1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d[1] = node.count(1)",
      "mutated_line": "d[1] = node.count(2)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(2)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d[1] = node.count(1)",
      "mutated_line": "d[1] = node.count(0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(0)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d[1] = node.count(1)",
      "mutated_line": "d[1] = node.count(0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(0)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "d[1] = node.count(1)",
      "mutated_line": "d[1] = node.count(-1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(-1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b - 2)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 2)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b - 0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 0)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b - 0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 0)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 1].append(b - -1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - -1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a - 2)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 2)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a - 0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 0)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a - 0)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 0)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 1].append(a - -1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - -1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "node = [-1] * N",
      "mutated_line": "node = [-2] * N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-2] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "node = [-1] * N",
      "mutated_line": "node = [-0] * N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-0] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "node = [-1] * N",
      "mutated_line": "node = [-0] * N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-0] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "node = [-1] * N",
      "mutated_line": "node = [--1] * N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [--1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if node[v] < 0:",
      "mutated_line": "if node[v] < 1:",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 1:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if node[v] < 0:",
      "mutated_line": "if node[v] < -1:",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < -1:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if node[v] < 0:",
      "mutated_line": "if node[v] < 1:",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 1:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "node[v] = 1 - c",
      "mutated_line": "node[v] = 1 + c",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 + c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "node[v] = 1 - c",
      "mutated_line": "node[v] = 1 * c",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 * c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "node = [0] * N",
      "mutated_line": "node = [1] * N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [1] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "node = [0] * N",
      "mutated_line": "node = [-1] * N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [-1] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "node = [0] * N",
      "mutated_line": "node = [1] * N",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [1] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans += d[1 + node[i]] - len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 + node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans += d[1 * node[i]] - len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 * node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a + 1].append(b - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a + 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a * 1].append(b - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a * 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b + 1].append(a - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b + 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b * 1].append(a - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b * 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "node[v] = 1 - c",
      "mutated_line": "node[v] = 2 - c",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 2 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "node[v] = 1 - c",
      "mutated_line": "node[v] = 0 - c",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 0 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "node[v] = 1 - c",
      "mutated_line": "node[v] = 0 - c",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 0 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "node[v] = 1 - c",
      "mutated_line": "node[v] = -1 - c",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = -1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans += d[2 - node[i]] - len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[2 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans += d[0 - node[i]] - len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[0 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans += d[0 - node[i]] - len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[0 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans += d[1 - node[i]] - len(edge[i])",
      "mutated_line": "ans += d[-1 - node[i]] - len(edge[i])",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[-1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 2].append(b - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 2].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 0].append(b - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 0].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - 0].append(b - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 0].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edge[a - 1].append(b - 1)",
      "mutated_line": "edge[a - -1].append(b - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - -1].append(b - 1)\n        edge[b - 1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 2].append(a - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 2].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 0].append(a - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 0].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - 0].append(a - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - 0].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edge[b - 1].append(a - 1)",
      "mutated_line": "edge[b - -1].append(a - 1)",
      "code": "import collections\n\ndef max_additional_edges(N, M, edges):\n    edge = [[] for _ in range(N)]\n    for (a, b) in edges:\n        edge[a - 1].append(b - 1)\n        edge[b - -1].append(a - 1)\n    node = [-1] * N\n    node[0] = 0\n    q = collections.deque()\n    q.append((0, 0))\n    d = [0] * 2\n    while q:\n        (u, c) = q.popleft()\n        for v in edge[u]:\n            if c == node[v]:\n                break\n            if node[v] < 0:\n                node[v] = 1 - c\n                q.append((v, node[v]))\n        else:\n            continue\n        d[1] = N - 1\n        node = [0] * N\n        break\n    else:\n        d[0] = node.count(0)\n        d[1] = node.count(1)\n    ans = 0\n    for i in range(N):\n        ans += d[1 - node[i]] - len(edge[i])\n    return ans // 2"
    }
  ]
}