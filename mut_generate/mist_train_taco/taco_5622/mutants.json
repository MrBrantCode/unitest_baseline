{
  "task_id": "taco_5622",
  "entry_point": "calculate_min_removal_time",
  "mutant_count": 106,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans += 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans += 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = 3 * sum(D)",
      "mutated_line": "ans = 3 / sum(D)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 / sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = 3 * sum(D)",
      "mutated_line": "ans = 3 + sum(D)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 + sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = 3 * sum(D)",
      "mutated_line": "ans = 3 ** sum(D)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 ** sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] / (n + 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] / (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] + (n + 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] + (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] ** (n + 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] ** (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 / sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 / sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 + sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 + sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 ** sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 ** sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 1\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = -1\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 1\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return ans - r",
      "mutated_line": "return ans + r",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans + r"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return ans - r",
      "mutated_line": "return ans * r",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans * r"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(10 * 8)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 * 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(10 + 8)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 + 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for (i, (p, c)) in enumerate(zip(P, D), 2):",
      "mutated_line": "for (i, (p, c)) in enumerate(zip(P, D), 3):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 3):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for (i, (p, c)) in enumerate(zip(P, D), 2):",
      "mutated_line": "for (i, (p, c)) in enumerate(zip(P, D), 1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 1):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for (i, (p, c)) in enumerate(zip(P, D), 2):",
      "mutated_line": "for (i, (p, c)) in enumerate(zip(P, D), 0):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 0):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for (i, (p, c)) in enumerate(zip(P, D), 2):",
      "mutated_line": "for (i, (p, c)) in enumerate(zip(P, D), 1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 1):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for (i, (p, c)) in enumerate(zip(P, D), 2):",
      "mutated_line": "for (i, (p, c)) in enumerate(zip(P, D), -2):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), -2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 3 * sum(D)",
      "mutated_line": "ans = 4 * sum(D)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 4 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 3 * sum(D)",
      "mutated_line": "ans = 2 * sum(D)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 2 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 3 * sum(D)",
      "mutated_line": "ans = 0 * sum(D)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 0 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 3 * sum(D)",
      "mutated_line": "ans = 1 * sum(D)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 1 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 3 * sum(D)",
      "mutated_line": "ans = -3 * sum(D)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = -3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n - 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n - 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n * 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n * 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) != 1 for i in range(n + 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) != 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 3 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 3 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 1 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 1 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 0 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 0 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 1 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 1 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= -2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= -2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited[i] = True",
      "mutated_line": "visited[i] = False",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = False\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 1\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = -1\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 1\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(2, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(0, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(0, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(-1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n - 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n * 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] / (n + 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] / (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] + (n + 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] + (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] ** (n + 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] ** (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(11 ** 8)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(11 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(9 ** 8)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(9 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(0 ** 8)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(0 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(1 ** 8)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(1 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(-10 ** 8)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(-10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(10 ** 9)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 9)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(10 ** 7)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 7)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(10 ** 0)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 0)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(10 ** 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 1)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "setrecursionlimit(10 ** 8)",
      "mutated_line": "setrecursionlimit(10 ** -8)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** -8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [True] * (n + 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [True] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 2)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 2)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 0)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 0)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 0)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 0)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + -1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + -1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 2 for i in range(n + 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 2 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 0 for i in range(n + 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 0 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 0 for i in range(n + 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 0 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == -1 for i in range(n + 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == -1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if is_leaf[e] or visited[e]:",
      "mutated_line": "if is_leaf[e] and visited[e]:",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] and visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 2):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 0):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 0):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + -1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n - 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n - 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n * 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n * 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "E = [list() for _ in range(n + 1)]",
      "mutated_line": "E = [list() for _ in range(n - 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n - 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "E = [list() for _ in range(n + 1)]",
      "mutated_line": "E = [list() for _ in range(n * 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n * 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 1 for i in range(n - 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n - 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 1 for i in range(n * 1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n * 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res = max(res, dfs(e) + c)",
      "mutated_line": "res = max(res, dfs(e) - c)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) - c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "res = max(res, dfs(e) + c)",
      "mutated_line": "res = max(res, dfs(e) * c)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) * c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [True] * (n + 1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [True] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 2)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 2)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 0)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 0)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + 0)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 0)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [False] * (n + 1)",
      "mutated_line": "visited = [False] * (n + -1)",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + -1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E = [list() for _ in range(n + 1)]",
      "mutated_line": "E = [list() for _ in range(n + 2)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 2)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E = [list() for _ in range(n + 1)]",
      "mutated_line": "E = [list() for _ in range(n + 0)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 0)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E = [list() for _ in range(n + 1)]",
      "mutated_line": "E = [list() for _ in range(n + 0)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 0)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "E = [list() for _ in range(n + 1)]",
      "mutated_line": "E = [list() for _ in range(n + -1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + -1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 2)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 2)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 0)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 0)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 0)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 0)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "is_leaf = [len(E[i]) == 1 for i in range(n + 1)]",
      "mutated_line": "is_leaf = [len(E[i]) == 1 for i in range(n + -1)]",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + -1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][2] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][2] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][0] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][0] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][0] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][0] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][-1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][-1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][1][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][1][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][-1][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][-1][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][1][1] for i in range(n + 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][1][1] for i in range(n + 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][1] for i in range(n - 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n - 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][1] for i in range(n * 1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n * 1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 2) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 2) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 0) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 0) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 0) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + 0) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + 1) if is_leaf[i]))",
      "mutated_line": "ans -= 2 * sum((E[i][0][1] for i in range(n + -1) if is_leaf[i]))",
      "code": "def calculate_min_removal_time(n, P, D):\n    from sys import setrecursionlimit\n    setrecursionlimit(10 ** 8)\n    E = [list() for _ in range(n + 1)]\n    for (i, (p, c)) in enumerate(zip(P, D), 2):\n        E[i].append((p, c))\n        E[p].append((i, c))\n    ans = 3 * sum(D)\n    visited = [False] * (n + 1)\n    is_leaf = [len(E[i]) == 1 for i in range(n + 1)]\n    ans -= 2 * sum((E[i][0][1] for i in range(n + -1) if is_leaf[i]))\n\n    def dfs(i):\n        visited[i] = True\n        res = 0\n        for (e, c) in E[i]:\n            if is_leaf[e] or visited[e]:\n                continue\n            res = max(res, dfs(e) + c)\n        return res\n    r = 0\n    for i in range(1, n + 1):\n        if is_leaf[i]:\n            continue\n        visited = [False] * (n + 1)\n        r = max(r, dfs(i))\n    return ans - r"
    }
  ]
}