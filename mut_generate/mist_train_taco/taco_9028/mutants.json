{
  "task_id": "taco_9028",
  "entry_point": "can_reach_sorted_state",
  "mutant_count": 78,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "P = [0] + P",
      "mutated_line": "P = [0] - P",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] - P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "P = [0] + P",
      "mutated_line": "P = [0] * P",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] * P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 1\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "left = 0",
      "mutated_line": "left = -1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = -1\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "left = 0",
      "mutated_line": "left = 1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 1\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "right = -1",
      "mutated_line": "right = +1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = +1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "right = -1",
      "mutated_line": "right = -2",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -2\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "right = -1",
      "mutated_line": "right = -0",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -0\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "right = -1",
      "mutated_line": "right = -0",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -0\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "right = -1",
      "mutated_line": "right = --1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = --1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if right < p:",
      "mutated_line": "if right <= p:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right <= p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if right < p:",
      "mutated_line": "if right >= p:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right >= p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if right < p:",
      "mutated_line": "if right != p:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right != p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i == right:",
      "mutated_line": "if i != right:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i != right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if L == R:",
      "mutated_line": "if L != R:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L != R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed == list(range(L + 1, R + 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed == list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return True",
      "mutated_line": "answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return False\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "answer = 'Yes' if all(check(L, R) for L, R in intervals) else 'No'",
      "mutated_line": "answer = '' if all((check(L, R) for (L, R) in intervals)) else 'No'",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = '' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "answer = 'Yes' if all(check(L, R) for L, R in intervals) else 'No'",
      "mutated_line": "answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else ''",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else ''\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "P = [0] + P",
      "mutated_line": "P = [1] + P",
      "code": "def can_reach_sorted_state(N, P):\n    P = [1] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "P = [0] + P",
      "mutated_line": "P = [-1] + P",
      "code": "def can_reach_sorted_state(N, P):\n    P = [-1] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "P = [0] + P",
      "mutated_line": "P = [1] + P",
      "code": "def can_reach_sorted_state(N, P):\n    P = [1] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "left = i + 1",
      "mutated_line": "left = i - 1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i - 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "left = i + 1",
      "mutated_line": "left = i * 1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i * 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "right = -1",
      "mutated_line": "right = +1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = +1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return False\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i > p:",
      "mutated_line": "if i >= p:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i >= p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i > p:",
      "mutated_line": "if i <= p:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i <= p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i > p:",
      "mutated_line": "if i != p:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i != p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return False",
      "mutated_line": "return False",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return True\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return False",
      "mutated_line": "return False",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return True\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return True\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "left = i + 1",
      "mutated_line": "left = i + 2",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 2\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "left = i + 1",
      "mutated_line": "left = i + 0",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 0\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "left = i + 1",
      "mutated_line": "left = i + 0",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 0\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "left = i + 1",
      "mutated_line": "left = i + -1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + -1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "right = -1",
      "mutated_line": "right = -2",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -2\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "right = -1",
      "mutated_line": "right = -0",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -0\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "right = -1",
      "mutated_line": "right = -0",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -0\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "right = -1",
      "mutated_line": "right = --1",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = --1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif i == p:",
      "mutated_line": "elif i != p:",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i != p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if any(x > y for x, y in zip(to_left, to_left[1:])):",
      "mutated_line": "if any((x >= y for (x, y) in zip(to_left, to_left[1:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x >= y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if any(x > y for x, y in zip(to_left, to_left[1:])):",
      "mutated_line": "if any((x <= y for (x, y) in zip(to_left, to_left[1:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x <= y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if any(x > y for x, y in zip(to_left, to_left[1:])):",
      "mutated_line": "if any((x != y for (x, y) in zip(to_left, to_left[1:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x != y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if any(x > y for x, y in zip(to_right, to_right[1:])):",
      "mutated_line": "if any((x >= y for (x, y) in zip(to_right, to_right[1:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x >= y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if any(x > y for x, y in zip(to_right, to_right[1:])):",
      "mutated_line": "if any((x <= y for (x, y) in zip(to_right, to_right[1:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x <= y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if any(x > y for x, y in zip(to_right, to_right[1:])):",
      "mutated_line": "if any((x != y for (x, y) in zip(to_right, to_right[1:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x != y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i, p in enumerate(P[L:R + 1], L):",
      "mutated_line": "for (i, p) in enumerate(P[L:R - 1], L):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R - 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i, p in enumerate(P[L:R + 1], L):",
      "mutated_line": "for (i, p) in enumerate(P[L:R * 1], L):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R * 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L - 1, R + 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L - 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L * 1, R + 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L * 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R - 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R - 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R * 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R * 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + 1, 3)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 3)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + 1, 1)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 1)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + 1, 0)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 0)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + 1, 1)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 1)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + 1, -2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, -2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i, p in enumerate(P[L:R + 1], L):",
      "mutated_line": "for (i, p) in enumerate(P[L:R + 2], L):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 2], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i, p in enumerate(P[L:R + 1], L):",
      "mutated_line": "for (i, p) in enumerate(P[L:R + 0], L):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 0], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i, p in enumerate(P[L:R + 1], L):",
      "mutated_line": "for (i, p) in enumerate(P[L:R + 0], L):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 0], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i, p in enumerate(P[L:R + 1], L):",
      "mutated_line": "for (i, p) in enumerate(P[L:R + -1], L):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + -1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 2, R + 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 2, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 0, R + 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 0, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 0, R + 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 0, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + -1, R + 1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + -1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + 2, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 2, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + 0, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 0, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + 0, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 0, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if fixed != list(range(L + 1, R + 1, 2)):",
      "mutated_line": "if fixed != list(range(L + 1, R + -1, 2)):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + -1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if any(x > y for x, y in zip(to_left, to_left[1:])):",
      "mutated_line": "if any((x > y for (x, y) in zip(to_left, to_left[2:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[2:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if any(x > y for x, y in zip(to_left, to_left[1:])):",
      "mutated_line": "if any((x > y for (x, y) in zip(to_left, to_left[0:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[0:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if any(x > y for x, y in zip(to_left, to_left[1:])):",
      "mutated_line": "if any((x > y for (x, y) in zip(to_left, to_left[0:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[0:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if any(x > y for x, y in zip(to_left, to_left[1:])):",
      "mutated_line": "if any((x > y for (x, y) in zip(to_left, to_left[-1:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[-1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if any(x > y for x, y in zip(to_right, to_right[1:])):",
      "mutated_line": "if any((x > y for (x, y) in zip(to_right, to_right[2:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[2:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if any(x > y for x, y in zip(to_right, to_right[1:])):",
      "mutated_line": "if any((x > y for (x, y) in zip(to_right, to_right[0:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[0:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if any(x > y for x, y in zip(to_right, to_right[1:])):",
      "mutated_line": "if any((x > y for (x, y) in zip(to_right, to_right[0:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[0:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if any(x > y for x, y in zip(to_right, to_right[1:])):",
      "mutated_line": "if any((x > y for (x, y) in zip(to_right, to_right[-1:]))):",
      "code": "def can_reach_sorted_state(N, P):\n    P = [0] + P\n    intervals = []\n    left = 0\n    right = -1\n    for (i, p) in enumerate(P):\n        if right < p:\n            right = p\n        if i == right:\n            intervals.append((left, right))\n            left = i + 1\n            right = -1\n\n    def check(L, R):\n        if L == R:\n            return True\n        to_left = []\n        fixed = []\n        to_right = []\n        for (i, p) in enumerate(P[L:R + 1], L):\n            if i > p:\n                to_left.append(p)\n            elif i == p:\n                fixed.append(p)\n            else:\n                to_right.append(p)\n        if fixed != list(range(L + 1, R + 1, 2)):\n            return False\n        if any((x > y for (x, y) in zip(to_left, to_left[1:]))):\n            return False\n        if any((x > y for (x, y) in zip(to_right, to_right[-1:]))):\n            return False\n        return True\n    answer = 'Yes' if all((check(L, R) for (L, R) in intervals)) else 'No'\n    return answer"
    }
  ]
}