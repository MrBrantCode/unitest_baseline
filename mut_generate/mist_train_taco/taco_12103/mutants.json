{
  "task_id": "taco_12103",
  "entry_point": "find_digit_in_sequence",
  "mutant_count": 388,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "poz = 1",
      "mutated_line": "poz = 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 2\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "poz = 1",
      "mutated_line": "poz = 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 0\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "poz = 1",
      "mutated_line": "poz = 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 0\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "poz = 1",
      "mutated_line": "poz = -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = -1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while False:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 1) / 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) / 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 1) * 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) * 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n - (n - 1) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n - (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n * ((n - 1) * n // 2 * r)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n * ((n - 1) * n // 2 * r)\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n != 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) - 9 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) - 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) * (9 * 10 ** (n - 1) * n)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) * (9 * 10 ** (n - 1) * n)\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "poz = 1",
      "mutated_line": "poz = 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 2\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "poz = 1",
      "mutated_line": "poz = 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 0\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "poz = 1",
      "mutated_line": "poz = 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 0\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "poz = 1",
      "mutated_line": "poz = -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = -1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while False:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "left = 1",
      "mutated_line": "left = 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 2\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "left = 1",
      "mutated_line": "left = 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 0\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "left = 1",
      "mutated_line": "left = 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 0\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "left = 1",
      "mutated_line": "left = -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = -1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) - 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) - 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) * 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) * 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while left < right:",
      "mutated_line": "while left <= right:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left <= right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while left < right:",
      "mutated_line": "while left >= right:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left >= right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while left < right:",
      "mutated_line": "while left != right:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left != right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left != 9 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left != 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "left -= 1",
      "mutated_line": "left += 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left += 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "n -= poz * left",
      "mutated_line": "n += poz * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n += poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "poz += 1",
      "mutated_line": "poz -= 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz -= 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 57,
      "original_line": "left -= 1",
      "mutated_line": "left += 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left += 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 58,
      "original_line": "n -= poz * left",
      "mutated_line": "n += poz * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n += poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n / (n + 1) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n / (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return (n + (n + 1)) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return (n + (n + 1)) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n ** (n + 1) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n ** (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 1) // 3",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 3\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 1) // 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 1\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 1) // 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 0\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 1) // 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 1\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 1) // -2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // -2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a / n + (n - 1) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a / n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a + n + (n - 1) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a + n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a ** n + (n - 1) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a ** n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) * n // 2 / r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 / r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + ((n - 1) * n // 2 + r)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + ((n - 1) * n // 2 + r)\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + ((n - 1) * n // 2) ** r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + ((n - 1) * n // 2) ** r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 1:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == -1:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 1:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 1\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return -1\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 1\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 10 ** (n - 1) / n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) / n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + (9 * 10 ** (n - 1) + n)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + (9 * 10 ** (n - 1) + n)\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + (9 * 10 ** (n - 1)) ** n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + (9 * 10 ** (n - 1)) ** n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "left = 1",
      "mutated_line": "left = 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 2\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "left = 1",
      "mutated_line": "left = 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 0\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "left = 1",
      "mutated_line": "left = 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 0\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "left = 1",
      "mutated_line": "left = -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = -1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) - 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) - 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) * 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) * 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while left < right:",
      "mutated_line": "while left <= right:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left <= right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while left < right:",
      "mutated_line": "while left >= right:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left >= right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while left < right:",
      "mutated_line": "while left != right:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left != right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "cur += sm(poz, poz, mid)",
      "mutated_line": "cur -= sm(poz, poz, mid)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur -= sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left != 9 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left != 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n += cale(poz - 1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n += cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "n -= sm(poz, poz, left)",
      "mutated_line": "n += sm(poz, poz, left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n += sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "poz += 1",
      "mutated_line": "poz -= 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz -= 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "left -= 1",
      "mutated_line": "left += 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left += 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n += cale(poz - 1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n += cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "n -= sm(poz, poz, left)",
      "mutated_line": "n += sm(poz, poz, left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n += sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 / 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 / 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 + 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 + 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 ** 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 ** 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) + 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 2\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) + 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 0\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) + 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 0\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) + -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + -1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) / 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) / 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) * 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) * 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "cur = poz * mid",
      "mutated_line": "cur = poz / mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz / mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "cur = poz * mid",
      "mutated_line": "cur = poz + mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz + mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "cur = poz * mid",
      "mutated_line": "cur = poz ** mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz ** mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if cur >= n:",
      "mutated_line": "if cur > n:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur > n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if cur >= n:",
      "mutated_line": "if cur < n:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur < n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if cur >= n:",
      "mutated_line": "if cur == n:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur == n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) - 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) - 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) * 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) * 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "left -= 1",
      "mutated_line": "left -= 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 2\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "left -= 1",
      "mutated_line": "left -= 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 0\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "left -= 1",
      "mutated_line": "left -= 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 0\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "left -= 1",
      "mutated_line": "left -= -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= -1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n -= poz * left",
      "mutated_line": "n -= poz / left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz / left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n -= poz * left",
      "mutated_line": "n -= poz + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz + left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "n -= poz * left",
      "mutated_line": "n -= poz ** left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz ** left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "poz += 1",
      "mutated_line": "poz += 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 2\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "poz += 1",
      "mutated_line": "poz += 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 0\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "poz += 1",
      "mutated_line": "poz += 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 0\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "poz += 1",
      "mutated_line": "poz += -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += -1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "assert n > 0, 'n == 0 down'",
      "mutated_line": "assert n >= 0, 'n == 0 down'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n >= 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "assert n > 0, 'n == 0 down'",
      "mutated_line": "assert n <= 0, 'n == 0 down'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n <= 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "assert n > 0, 'n == 0 down'",
      "mutated_line": "assert n != 0, 'n == 0 down'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n != 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "assert n > 0, 'n == 0 down'",
      "mutated_line": "assert n > 0, ''",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, ''\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "left -= 1",
      "mutated_line": "left -= 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 2\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "left -= 1",
      "mutated_line": "left -= 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 0\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "left -= 1",
      "mutated_line": "left -= 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 0\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "left -= 1",
      "mutated_line": "left -= -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= -1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "n -= poz * left",
      "mutated_line": "n -= poz / left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz / left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "n -= poz * left",
      "mutated_line": "n -= poz + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz + left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "n -= poz * left",
      "mutated_line": "n -= poz ** left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz ** left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n - 1) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n - 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n * 1) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n * 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) * n / 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n / 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) * n * 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n * 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n + 1) + 9 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n + 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n * 1) + 9 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n * 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 / 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 / 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + (9 + 10 ** (n - 1)) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + (9 + 10 ** (n - 1)) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 ** 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 ** 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 / 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 / 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 + 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 + 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 ** 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 ** 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) + 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 2\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) + 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 0\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) + 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 0\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 1) + -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + -1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) / 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) / 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) * 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) * 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz - 1) / mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) / mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz - 1) + mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) + mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz - 1) ** mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) ** mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cur >= n:",
      "mutated_line": "if cur > n:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur > n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cur >= n:",
      "mutated_line": "if cur < n:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur < n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cur >= n:",
      "mutated_line": "if cur == n:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur == n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) - 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) - 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) * 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) * 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 / 10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 / 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 + 10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 + 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 ** 10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 ** 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 1) / left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) / left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) + left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 1) ** left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) ** left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "poz += 1",
      "mutated_line": "poz += 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 2\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "poz += 1",
      "mutated_line": "poz += 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 0\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "poz += 1",
      "mutated_line": "poz += 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 0\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "poz += 1",
      "mutated_line": "poz += -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += -1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "assert n > 0, 'n == 0'",
      "mutated_line": "assert n >= 0, 'n == 0'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n >= 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "assert n > 0, 'n == 0'",
      "mutated_line": "assert n <= 0, 'n == 0'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n <= 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "assert n > 0, 'n == 0'",
      "mutated_line": "assert n != 0, 'n == 0'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n != 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "assert n > 0, 'n == 0'",
      "mutated_line": "assert n > 0, ''",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, ''\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "left -= 1",
      "mutated_line": "left -= 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 2\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "left -= 1",
      "mutated_line": "left -= 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 0\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "left -= 1",
      "mutated_line": "left -= 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 0\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "left -= 1",
      "mutated_line": "left -= -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= -1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 1) / left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) / left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) + left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 1) ** left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) ** left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 ** (poz - 1) - left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) - left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 ** (poz - 1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) * left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 10 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 10 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 8 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 8 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 0 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 0 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 1 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 1 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = -9 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = -9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * (10 * (poz - 1)) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * (10 * (poz - 1)) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * (10 + (poz - 1)) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * (10 + (poz - 1)) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left - right) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left - right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = left * right // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = left * right // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 3",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 3\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 1\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 0\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 1\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // -2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // -2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid - 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid - 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid * 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid * 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 / 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 / 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 + 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 + 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 ** 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 ** 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) + 2:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 2:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) + 0:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 0:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) + 0:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 0:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) + -1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + -1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "assert n > 0, 'n == 0 down'",
      "mutated_line": "assert n > 1, 'n == 0 down'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 1, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "assert n > 0, 'n == 0 down'",
      "mutated_line": "assert n > -1, 'n == 0 down'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > -1, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "assert n > 0, 'n == 0 down'",
      "mutated_line": "assert n > 1, 'n == 0 down'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 1, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 ** (poz - 1) - left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) - left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 ** (poz - 1) * left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) * left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 2) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 2) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 0) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 0) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + 0) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 0) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return n * (n + 1) // 2",
      "mutated_line": "return n * (n + -1) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + -1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) / n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) / n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1 + n) // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1 + n) // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) ** n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) ** n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) * n // 3 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 3 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) * n // 1 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 1 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) * n // 0 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 0 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) * n // 1 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 1 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 1) * n // -2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // -2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 2) + 9 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 2) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 0) + 9 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 0) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 0) + 9 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 0) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - -1) + 9 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - -1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 10 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 10 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 8 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 8 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 0 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 0 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 1 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 1 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + -9 * 10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + -9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * (10 * (n - 1)) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * (10 * (n - 1)) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * (10 + (n - 1)) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * (10 + (n - 1)) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 10 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 10 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 8 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 8 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 0 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 0 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 1 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 1 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = -9 * 10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = -9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * (10 * (poz - 1)) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * (10 * (poz - 1)) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * (10 + (poz - 1)) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * (10 + (poz - 1)) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left - right) // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left - right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = left * right // 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = left * right // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 3",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 3\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 1\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 0\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 1\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "mid = (left + right) // 2",
      "mutated_line": "mid = (left + right) // -2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // -2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid - 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid - 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid * 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid * 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 / 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 / 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 + 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 + 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 ** 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 ** 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) + 2:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 2:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) + 0:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 0:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) + 0:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 0:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 1) + -1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + -1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 10 * 10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 10 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 8 * 10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 8 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 0 * 10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 0 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 1 * 10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 1 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = -9 * 10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = -9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * (10 * (poz - 1))",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * (10 * (poz - 1))\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * (10 + (poz - 1))",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * (10 + (poz - 1))\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "assert n > 0, 'n == 0'",
      "mutated_line": "assert n > 1, 'n == 0'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 1, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "assert n > 0, 'n == 0'",
      "mutated_line": "assert n > -1, 'n == 0'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > -1, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "assert n > 0, 'n == 0'",
      "mutated_line": "assert n > 1, 'n == 0'",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 1, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 * (poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 * (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 + (poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 + (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 11 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 11 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 9 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 9 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 0 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 0 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 1 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 1 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * -10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * -10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz + 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz + 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz * 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz * 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 2\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 0\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 0\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + -1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 10 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 10 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 8 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 8 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 0 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 0 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 1 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 1 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == -9 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == -9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * (10 * (poz - 1)) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * (10 * (poz - 1)) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * (10 + (poz - 1)) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * (10 + (poz - 1)) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 * (poz - 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 * (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 + (poz - 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 + (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 60,
      "original_line": "return int(l[n - 1])",
      "mutated_line": "return int(l[n + 1])",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n + 1])"
    },
    {
      "operator": "AOR",
      "lineno": 60,
      "original_line": "return int(l[n - 1])",
      "mutated_line": "return int(l[n * 1])",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n * 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n + 1) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n + 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + n * 1 * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + n * 1 * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 11 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 11 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 9 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 9 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 0 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 0 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 1 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 1 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * -10 ** (n - 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * -10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 10 ** (n + 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n + 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 10 ** (n * 1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n * 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 11 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 11 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 9 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 9 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 0 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 0 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 1 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 1 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * -10 ** (poz - 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * -10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz + 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz + 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz * 1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz * 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz + 1) * mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz + 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz * 1) * mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz * 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 2",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 2\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 0\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + 0",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 0\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "left = mid + 1",
      "mutated_line": "left = mid + -1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + -1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 10 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 10 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 8 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 8 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 0 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 0 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 1 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 1 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == -9 * 10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == -9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * (10 * (poz - 1)) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * (10 * (poz - 1)) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * (10 + (poz - 1)) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * (10 + (poz - 1)) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 11 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 11 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 9 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 9 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 0 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 0 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 1 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 1 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * -10 ** (poz - 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * -10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 10 ** (poz + 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz + 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 10 ** (poz * 1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz * 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz + 1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz + 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz * 1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz * 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz + 1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz + 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz * 1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz * 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 11 ** (poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 11 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 9 ** (poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 9 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 0 ** (poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 0 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 1 ** (poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 1 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = -10 ** (poz - 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = -10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 ** (poz + 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz + 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 ** (poz * 1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz * 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 2) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 2) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 0) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 0) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 0) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 0) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - -1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - -1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 11 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 11 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 9 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 9 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 0 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 0 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 1 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 1 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * -10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * -10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz + 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz + 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz * 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz * 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(11 ** (poz - 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(11 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(9 ** (poz - 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(9 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(0 ** (poz - 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(0 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(1 ** (poz - 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(1 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(-10 ** (poz - 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(-10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 ** (poz + 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz + 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 ** (poz * 1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz * 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return int(l[n - 1])",
      "mutated_line": "return int(l[n - 2])",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 2])"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return int(l[n - 1])",
      "mutated_line": "return int(l[n - 0])",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 0])"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return int(l[n - 1])",
      "mutated_line": "return int(l[n - 0])",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 0])"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return int(l[n - 1])",
      "mutated_line": "return int(l[n - -1])",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - -1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 2) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 2) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 0) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 0) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - 0) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 0) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return a * n + (n - 1) * n // 2 * r",
      "mutated_line": "return a * n + (n - -1) * n // 2 * r",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - -1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 10 ** (n - 2) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 2) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 10 ** (n - 0) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 0) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 10 ** (n - 0) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 0) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return cale(n - 1) + 9 * 10 ** (n - 1) * n",
      "mutated_line": "return cale(n - 1) + 9 * 10 ** (n - -1) * n",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - -1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 2) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 2) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 0) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 0) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - 0) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 0) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "right = 9 * 10 ** (poz - 1) + 1",
      "mutated_line": "right = 9 * 10 ** (poz - -1) + 1",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - -1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz - 2) * mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 2) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz - 0) * mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 0) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz - 0) * mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 0) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = cale(poz - 1) * mid",
      "mutated_line": "cur = cale(poz - -1) * mid",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - -1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 11 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 11 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 9 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 9 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 0 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 0 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 1 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 1 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * -10 ** (poz - 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * -10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz + 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz + 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz * 1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz * 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 10 ** (poz - 2)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 2)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 10 ** (poz - 0)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 0)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 10 ** (poz - 0)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 0)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "left = 9 * 10 ** (poz - 1)",
      "mutated_line": "left = 9 * 10 ** (poz - -1)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - -1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 2) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 2) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 0) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 0) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 0) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 0) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - -1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - -1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 2) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 2) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 0) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 0) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - 0) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 0) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "n -= cale(poz - 1) * left",
      "mutated_line": "n -= cale(poz - -1) * left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - -1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 ** (poz - 2) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 2) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 ** (poz - 0) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 0) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 ** (poz - 0) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 0) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ktory = 10 ** (poz - 1) + left",
      "mutated_line": "ktory = 10 ** (poz - -1) + left",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - -1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 2) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 2) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 0) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 0) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 0) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 0) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - -1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - -1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 ** (poz - 2) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 2) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 ** (poz - 0) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 0) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 ** (poz - 0) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 0) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "l = str(10 ** (poz - 1) + left)",
      "mutated_line": "l = str(10 ** (poz - -1) + left)",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - -1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 2) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 2) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 0) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 0) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - 0) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - 0) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if left == 9 * 10 ** (poz - 1) + 1:",
      "mutated_line": "if left == 9 * 10 ** (poz - -1) + 1:",
      "code": "def find_digit_in_sequence(k: int) -> int:\n\n    def ar(n):\n        return n * (n + 1) // 2\n\n    def sm(a, r, n):\n        return a * n + (n - 1) * n // 2 * r\n\n    def cale(n):\n        if n == 0:\n            return 0\n        return cale(n - 1) + 9 * 10 ** (n - 1) * n\n\n    def zaj(n):\n        poz = 1\n        while True:\n            left = 1\n            right = 9 * 10 ** (poz - 1) + 1\n            while left < right:\n                mid = (left + right) // 2\n                cur = cale(poz - 1) * mid\n                cur += sm(poz, poz, mid)\n                if cur >= n:\n                    right = mid\n                else:\n                    left = mid + 1\n            if left == 9 * 10 ** (poz - -1) + 1:\n                left = 9 * 10 ** (poz - 1)\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                poz += 1\n                assert n > 0, 'n == 0'\n            else:\n                left -= 1\n                n -= cale(poz - 1) * left\n                n -= sm(poz, poz, left)\n                ktory = 10 ** (poz - 1) + left\n                return (ktory, n)\n    (_, n) = zaj(k)\n    poz = 1\n    while True:\n        left = 1\n        right = 9 * 10 ** (poz - 1) + 1\n        while left < right:\n            mid = (left + right) // 2\n            cur = poz * mid\n            if cur >= n:\n                right = mid\n            else:\n                left = mid + 1\n        if left == 9 * 10 ** (poz - 1) + 1:\n            left -= 1\n            n -= poz * left\n            poz += 1\n            assert n > 0, 'n == 0 down'\n        else:\n            left -= 1\n            n -= poz * left\n            l = str(10 ** (poz - 1) + left)\n            return int(l[n - 1])"
    }
  ]
}