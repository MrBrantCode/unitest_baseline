{
  "task_id": "taco_12650",
  "entry_point": "count_distinct_decompositions",
  "mutant_count": 178,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Mod = 1000000007",
      "mutated_line": "Mod = 1000000008",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000008\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Mod = 1000000007",
      "mutated_line": "Mod = 1000000006",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000006\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Mod = 1000000007",
      "mutated_line": "Mod = 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 0\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Mod = 1000000007",
      "mutated_line": "Mod = 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "Mod = 1000000007",
      "mutated_line": "Mod = -1000000007",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = -1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MAX = 33000",
      "mutated_line": "MAX = 33001",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33001\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MAX = 33000",
      "mutated_line": "MAX = 32999",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 32999\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MAX = 33000",
      "mutated_line": "MAX = 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 0\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MAX = 33000",
      "mutated_line": "MAX = 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 1\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MAX = 33000",
      "mutated_line": "MAX = -33000",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = -33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "B = [0] * MAX",
      "mutated_line": "B = [0] / MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] / MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "B = [0] * MAX",
      "mutated_line": "B = [0] + MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] + MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "B = [0] * MAX",
      "mutated_line": "B = [0] ** MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] ** MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "bePrime = [0] * MAX",
      "mutated_line": "bePrime = [0] / MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] / MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "bePrime = [0] * MAX",
      "mutated_line": "bePrime = [0] + MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] + MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "bePrime = [0] * MAX",
      "mutated_line": "bePrime = [0] ** MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] ** MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 2\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 0\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 0\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = -1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "return ans % Mod",
      "mutated_line": "return ans * Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans * Mod"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "return ans % Mod",
      "mutated_line": "return ans + Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans + Mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "fac = [1]",
      "mutated_line": "fac = [2]",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [2]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "fac = [1]",
      "mutated_line": "fac = [0]",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [0]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "fac = [1]",
      "mutated_line": "fac = [0]",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [0]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "fac = [1]",
      "mutated_line": "fac = [-1]",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [-1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(1, MAX):",
      "mutated_line": "for j in range(2, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(2, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(1, MAX):",
      "mutated_line": "for j in range(0, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(0, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(1, MAX):",
      "mutated_line": "for j in range(0, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(0, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for j in range(1, MAX):",
      "mutated_line": "for j in range(-1, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(-1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) * Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) * Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) + Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) + Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(3, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(3, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(1, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(1, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(0, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(0, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(1, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(1, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(-2, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(-2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if bePrime[j] == 0:",
      "mutated_line": "if bePrime[j] != 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] != 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if tmp > 1:",
      "mutated_line": "if tmp >= 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp >= 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if tmp > 1:",
      "mutated_line": "if tmp <= 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp <= 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if tmp > 1:",
      "mutated_line": "if tmp != 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp != 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(3, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(3, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(1, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(1, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(0, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(0, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(1, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(1, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for j in range(2, MAX):",
      "mutated_line": "for j in range(-2, MAX):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(-2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if B[j] > 0:",
      "mutated_line": "if B[j] >= 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] >= 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if B[j] > 0:",
      "mutated_line": "if B[j] <= 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] <= 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if B[j] > 0:",
      "mutated_line": "if B[j] != 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] != 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(0, l):",
      "mutated_line": "for j in range(1, l):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(1, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(0, l):",
      "mutated_line": "for j in range(-1, l):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(-1, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(0, l):",
      "mutated_line": "for j in range(1, l):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(1, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "num = 0",
      "mutated_line": "num = 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 1\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "num = 0",
      "mutated_line": "num = -1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = -1\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "num = 0",
      "mutated_line": "num = 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 1\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if num > 0:",
      "mutated_line": "if num >= 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num >= 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if num > 0:",
      "mutated_line": "if num <= 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num <= 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if num > 0:",
      "mutated_line": "if num != 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num != 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "B = [0] * MAX",
      "mutated_line": "B = [1] * MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [1] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "B = [0] * MAX",
      "mutated_line": "B = [-1] * MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [-1] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "B = [0] * MAX",
      "mutated_line": "B = [1] * MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [1] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bePrime = [0] * MAX",
      "mutated_line": "bePrime = [1] * MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [1] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bePrime = [0] * MAX",
      "mutated_line": "bePrime = [-1] * MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [-1] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bePrime = [0] * MAX",
      "mutated_line": "bePrime = [1] * MAX",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [1] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[-1] * j * Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j * Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[-1] * j + Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j + Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] / pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] / pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return (fac[M] + pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod)) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return (fac[M] + pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod)) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] ** pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] ** pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if bePrime[j] == 0:",
      "mutated_line": "if bePrime[j] == 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 1:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if bePrime[j] == 0:",
      "mutated_line": "if bePrime[j] == -1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == -1:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if bePrime[j] == 0:",
      "mutated_line": "if bePrime[j] == 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 1:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < MAX:",
      "mutated_line": "while i <= MAX:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i <= MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < MAX:",
      "mutated_line": "while i >= MAX:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i >= MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < MAX:",
      "mutated_line": "while i != MAX:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i != MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while tmp % j == 0:",
      "mutated_line": "while tmp % j != 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j != 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "B[j] += 1",
      "mutated_line": "B[j] -= 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] -= 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if tmp > 1:",
      "mutated_line": "if tmp > 2:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 2:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if tmp > 1:",
      "mutated_line": "if tmp > 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 0:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if tmp > 1:",
      "mutated_line": "if tmp > 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 0:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if tmp > 1:",
      "mutated_line": "if tmp > -1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > -1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if B[j] > 0:",
      "mutated_line": "if B[j] > 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 1:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if B[j] > 0:",
      "mutated_line": "if B[j] > -1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > -1:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if B[j] > 0:",
      "mutated_line": "if B[j] > 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 1:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 1, n - 1) * Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) * Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 1, n - 1) + Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) + Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for k in range(0, l):",
      "mutated_line": "for k in range(1, l):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(1, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for k in range(0, l):",
      "mutated_line": "for k in range(-1, l):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(-1, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for k in range(0, l):",
      "mutated_line": "for k in range(1, l):",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(1, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if C[k] == C[j]:",
      "mutated_line": "if C[k] != C[j]:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] != C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if num > 0:",
      "mutated_line": "if num > 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 1:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if num > 0:",
      "mutated_line": "if num > -1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > -1:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if num > 0:",
      "mutated_line": "if num > 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 1:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 1, n - 1) * Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) * Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 1, n - 1) + Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) + Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[-1] / j % Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] / j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append((fac[-1] + j) % Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append((fac[-1] + j) % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[-1] ** j % Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] ** j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "bePrime[i] = 1",
      "mutated_line": "bePrime[i] = 2",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 2\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "bePrime[i] = 1",
      "mutated_line": "bePrime[i] = 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 0\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "bePrime[i] = 1",
      "mutated_line": "bePrime[i] = 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 0\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "bePrime[i] = 1",
      "mutated_line": "bePrime[i] = -1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = -1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "i = i + j",
      "mutated_line": "i = i - j",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i - j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "i = i + j",
      "mutated_line": "i = i * j",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i * j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "while tmp % j == 0:",
      "mutated_line": "while tmp * j == 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp * j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "while tmp % j == 0:",
      "mutated_line": "while tmp + j == 0:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp + j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while tmp % j == 0:",
      "mutated_line": "while tmp % j == 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 1:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while tmp % j == 0:",
      "mutated_line": "while tmp % j == -1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == -1:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "while tmp % j == 0:",
      "mutated_line": "while tmp % j == 1:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 1:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "B[j] += 1",
      "mutated_line": "B[j] += 2",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 2\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "B[j] += 1",
      "mutated_line": "B[j] += 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 0\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "B[j] += 1",
      "mutated_line": "B[j] += 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 0\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "B[j] += 1",
      "mutated_line": "B[j] += -1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += -1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans / calc(n + B[j] - 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans / calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = (ans + calc(n + B[j] - 1, n - 1)) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = (ans + calc(n + B[j] - 1, n - 1)) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans ** calc(n + B[j] - 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans ** calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "num = num + 1",
      "mutated_line": "num = num - 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num - 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "num = num + 1",
      "mutated_line": "num = num * 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num * 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if k > j:",
      "mutated_line": "if k >= j:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k >= j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if k > j:",
      "mutated_line": "if k <= j:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k <= j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if k > j:",
      "mutated_line": "if k != j:",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k != j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans / calc(n + num - 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans / calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = (ans + calc(n + num - 1, n - 1)) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = (ans + calc(n + num - 1, n - 1)) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans ** calc(n + num - 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans ** calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] * Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] * Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] + Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] + Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod + 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod + 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod * 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod * 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num = num + 1",
      "mutated_line": "num = num + 2",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 2\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num = num + 1",
      "mutated_line": "num = num + 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 0\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num = num + 1",
      "mutated_line": "num = num + 0",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 0\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "num = num + 1",
      "mutated_line": "num = num + -1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + -1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "num = 0",
      "mutated_line": "num = 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 1\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "num = 0",
      "mutated_line": "num = -1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = -1\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "num = 0",
      "mutated_line": "num = 1",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 1\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[+1] * j % Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[+1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] / fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] / fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow((fac[N] + fac[M - N]) % Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow((fac[N] + fac[M - N]) % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] ** fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] ** fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 3, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 3, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 1, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 1, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 0, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 0, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 1, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 1, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - -2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - -2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] + 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] + 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc((n + B[j]) * 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc((n + B[j]) * 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 1, n + 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n + 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 1, n * 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n * 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num + 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num + 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc((n + num) * 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc((n + num) * 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 1, n + 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n + 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 1, n * 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n * 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[-2] * j % Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-2] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[-0] * j % Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-0] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[-0] * j % Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-0] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "fac.append(fac[-1] * j % Mod)",
      "mutated_line": "fac.append(fac[--1] * j % Mod)",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[--1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n - B[j] - 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n - B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n * B[j] - 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n * B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 2, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 2, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 0, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 0, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 0, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 0, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - -1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - -1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 1, n - 2) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 2) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 1, n - 0) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 0) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 1, n - 0) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 0) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = ans * calc(n + B[j] - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + B[j] - 1, n - -1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - -1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n - num - 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n - num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n * num - 1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n * num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 2, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 2, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 0, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 0, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 0, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 0, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - -1, n - 1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - -1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 1, n - 2) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 2) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 1, n - 0) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 0) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 1, n - 0) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 0) % Mod\n    return ans % Mod"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "ans = ans * calc(n + num - 1, n - 1) % Mod",
      "mutated_line": "ans = ans * calc(n + num - 1, n - -1) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - -1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M + N] % Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M + N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod",
      "mutated_line": "return fac[M] * pow(fac[N] * fac[M * N] % Mod, Mod - 2, Mod) % Mod",
      "code": "def count_distinct_decompositions(n, A):\n    Mod = 1000000007\n    MAX = 33000\n    B = [0] * MAX\n    bePrime = [0] * MAX\n    primNum = []\n    C = []\n    fac = [1]\n    for j in range(1, MAX):\n        fac.append(fac[-1] * j % Mod)\n\n    def calc(M, N):\n        return fac[M] * pow(fac[N] * fac[M * N] % Mod, Mod - 2, Mod) % Mod\n    for j in range(2, MAX):\n        if bePrime[j] == 0:\n            primNum.append(j)\n            i = j\n            while i < MAX:\n                bePrime[i] = 1\n                i = i + j\n    for x in A:\n        tmp = x\n        for j in primNum:\n            while tmp % j == 0:\n                tmp //= j\n                B[j] += 1\n        if tmp > 1:\n            C.append(tmp)\n    ans = 1\n    for j in range(2, MAX):\n        if B[j] > 0:\n            ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n    l = len(C)\n    for j in range(0, l):\n        num = 0\n        for k in range(0, l):\n            if C[k] == C[j]:\n                num = num + 1\n                if k > j:\n                    num = 0\n                    break\n        if num > 0:\n            ans = ans * calc(n + num - 1, n - 1) % Mod\n    return ans % Mod"
    }
  ]
}