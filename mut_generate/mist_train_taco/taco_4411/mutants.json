{
  "task_id": "taco_4411",
  "entry_point": "min_operations_to_sorted",
  "mutant_count": 145,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "cp[i] *= 2",
      "mutated_line": "cp[i] /= 2",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] /= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "cn[i] *= 2",
      "mutated_line": "cn[i] /= 2",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] /= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "cn[i] += n - i",
      "mutated_line": "cn[i] -= n - i",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] -= n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 1\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = -1\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 1\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while x > y:",
      "mutated_line": "while x >= y:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x >= y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while x > y:",
      "mutated_line": "while x <= y:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x <= y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while x > y:",
      "mutated_line": "while x != y:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x != y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "y *= 4",
      "mutated_line": "y /= 4",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y /= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "ret += 1",
      "mutated_line": "ret -= 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret -= 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ret = [0] * l",
      "mutated_line": "ret = [0] / l",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] / l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ret = [0] * l",
      "mutated_line": "ret = [0] + l",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] + l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ret = [0] * l",
      "mutated_line": "ret = [0] ** l",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] ** l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cp[i] *= 2",
      "mutated_line": "cp[i] *= 3",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 3\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cp[i] *= 2",
      "mutated_line": "cp[i] *= 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 1\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cp[i] *= 2",
      "mutated_line": "cp[i] *= 0",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 0\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cp[i] *= 2",
      "mutated_line": "cp[i] *= 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 1\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "cp[i] *= 2",
      "mutated_line": "cp[i] *= -2",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= -2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cn[i] *= 2",
      "mutated_line": "cn[i] *= 3",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 3\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cn[i] *= 2",
      "mutated_line": "cn[i] *= 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 1\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cn[i] *= 2",
      "mutated_line": "cn[i] *= 0",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 0\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cn[i] *= 2",
      "mutated_line": "cn[i] *= 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 1\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cn[i] *= 2",
      "mutated_line": "cn[i] *= -2",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= -2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "cn[i] += n - i",
      "mutated_line": "cn[i] += n + i",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n + i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "cn[i] += n - i",
      "mutated_line": "cn[i] += n * i",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n * i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(2, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(0, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(0, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(-1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "y *= 4",
      "mutated_line": "y *= 5",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 5\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "y *= 4",
      "mutated_line": "y *= 3",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 3\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "y *= 4",
      "mutated_line": "y *= 0",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 0\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "y *= 4",
      "mutated_line": "y *= 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 1\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "y *= 4",
      "mutated_line": "y *= -4",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= -4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ret += 1",
      "mutated_line": "ret += 2",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 2\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ret += 1",
      "mutated_line": "ret += 0",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 0\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ret += 1",
      "mutated_line": "ret += 0",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 0\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ret += 1",
      "mutated_line": "ret += -1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += -1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] < ls[i + 1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] < ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] > ls[i + 1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] > ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] == ls[i + 1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] == ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ansls = [cp[0], cn[0]]",
      "mutated_line": "ansls = [cp[1], cn[0]]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[1], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ansls = [cp[0], cn[0]]",
      "mutated_line": "ansls = [cp[-1], cn[0]]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[-1], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ansls = [cp[0], cn[0]]",
      "mutated_line": "ansls = [cp[1], cn[0]]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[1], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ansls = [cp[0], cn[0]]",
      "mutated_line": "ansls = [cp[0], cn[1]]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[1]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ansls = [cp[0], cn[0]]",
      "mutated_line": "ansls = [cp[0], cn[-1]]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[-1]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ansls = [cp[0], cn[0]]",
      "mutated_line": "ansls = [cp[0], cn[1]]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[1]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ansls.append(cp[i] + cn[n - i])",
      "mutated_line": "ansls.append(cp[i] - cn[n - i])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] - cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ansls.append(cp[i] + cn[n - i])",
      "mutated_line": "ansls.append(cp[i] * cn[n - i])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] * cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ret = [0] * l",
      "mutated_line": "ret = [1] * l",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [1] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ret = [0] * l",
      "mutated_line": "ret = [-1] * l",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [-1] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ret = [0] * l",
      "mutated_line": "ret = [1] * l",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [1] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l + 1, 10 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l + 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l * 1, 10 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l * 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 10 * 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 * 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 10 + 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 + 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l + 1)[::-1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l + 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l * 1)[::-1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l * 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - 1)[::+1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::+1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret[i] = ret[i + 1]",
      "mutated_line": "ret[i] = ret[i - 1]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i - 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret[i] = ret[i + 1]",
      "mutated_line": "ret[i] = ret[i * 1]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i * 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 1], ls[i]) + 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) + 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 1], ls[i]) * 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) * 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d > 0:",
      "mutated_line": "if d >= 0:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d >= 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d > 0:",
      "mutated_line": "if d <= 0:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d <= 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if d > 0:",
      "mutated_line": "if d != 0:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d != 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "cn = cost(A[::-1])",
      "mutated_line": "cn = cost(A[::+1])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::+1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 2, 10 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 2, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 0, 10 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 0, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 0, 10 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 0, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - -1, 10 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - -1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 11 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 11 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 9 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 9 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 0 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 0 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 1 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 1 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, -10 ** 18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, -10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 10 ** 19)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 19)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 10 ** 17)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 17)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 10 ** 0)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 0)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 10 ** 1)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 1)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(l - 1, 10 ** 18)]",
      "mutated_line": "stack = [(l - 1, 10 ** -18)]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** -18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - 2)[::-1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 2)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - 0)[::-1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 0)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - 0)[::-1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 0)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - -1)[::-1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - -1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - 1)[::-2]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-2]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - 1)[::-0]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-0]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - 1)[::-0]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-0]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l - 1)[::-1]:",
      "mutated_line": "for i in range(l - 1)[::--1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::--1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret[i] = ret[i + 1]",
      "mutated_line": "ret[i] = ret[i + 2]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 2]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret[i] = ret[i + 1]",
      "mutated_line": "ret[i] = ret[i + 0]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 0]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret[i] = ret[i + 1]",
      "mutated_line": "ret[i] = ret[i + 0]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 0]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret[i] = ret[i + 1]",
      "mutated_line": "ret[i] = ret[i + -1]",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + -1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] <= ls[i - 1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i - 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] <= ls[i * 1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i * 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 1], ls[i]) - 2",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 2\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 1], ls[i]) - 0",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 0\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 1], ls[i]) - 0",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 0\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 1], ls[i]) - -1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - -1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d > 0:",
      "mutated_line": "if d > 1:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 1:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d > 0:",
      "mutated_line": "if d > -1:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > -1:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if d > 0:",
      "mutated_line": "if d > 1:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 1:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if d > num:",
      "mutated_line": "if d >= num:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d >= num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if d > num:",
      "mutated_line": "if d <= num:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d <= num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if d > num:",
      "mutated_line": "if d != num:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d != num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "ret[i] += (idx - i) * num",
      "mutated_line": "ret[i] -= (idx - i) * num",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] -= (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "d -= num",
      "mutated_line": "d += num",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d += num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "ret[i] += (idx - i) * d",
      "mutated_line": "ret[i] -= (idx - i) * d",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] -= (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "num -= d",
      "mutated_line": "num += d",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num += d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cn = cost(A[::-1])",
      "mutated_line": "cn = cost(A[::-2])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-2])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cn = cost(A[::-1])",
      "mutated_line": "cn = cost(A[::-0])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-0])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cn = cost(A[::-1])",
      "mutated_line": "cn = cost(A[::-0])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-0])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cn = cost(A[::-1])",
      "mutated_line": "cn = cost(A[::--1])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::--1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ansls.append(cp[i] + cn[n - i])",
      "mutated_line": "ansls.append(cp[i] + cn[n + i])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n + i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ansls.append(cp[i] + cn[n - i])",
      "mutated_line": "ansls.append(cp[i] + cn[n * i])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n * i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] <= ls[i + 2]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 2]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] <= ls[i + 0]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 0]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] <= ls[i + 0]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 0]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if ls[i] <= ls[i + 1]:",
      "mutated_line": "if ls[i] <= ls[i + -1]:",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + -1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = d4(ls[i], ls[i + 1])",
      "mutated_line": "d = d4(ls[i], ls[i - 1])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i - 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "d = d4(ls[i], ls[i + 1])",
      "mutated_line": "d = d4(ls[i], ls[i * 1])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i * 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret[i] += (idx - i) * num",
      "mutated_line": "ret[i] += (idx - i) / num",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) / num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret[i] += (idx - i) * num",
      "mutated_line": "ret[i] += idx - i + num",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += idx - i + num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret[i] += (idx - i) * num",
      "mutated_line": "ret[i] += (idx - i) ** num",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) ** num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ret[i] += (idx - i) * d",
      "mutated_line": "ret[i] += (idx - i) / d",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) / d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ret[i] += (idx - i) * d",
      "mutated_line": "ret[i] += idx - i + d",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += idx - i + d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ret[i] += (idx - i) * d",
      "mutated_line": "ret[i] += (idx - i) ** d",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) ** d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "d = 0",
      "mutated_line": "d = 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 1\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "d = 0",
      "mutated_line": "d = -1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = -1\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "d = 0",
      "mutated_line": "d = 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 1\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i - 1], ls[i]) - 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i - 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i * 1], ls[i]) - 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i * 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = d4(ls[i], ls[i + 1])",
      "mutated_line": "d = d4(ls[i], ls[i + 2])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 2])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = d4(ls[i], ls[i + 1])",
      "mutated_line": "d = d4(ls[i], ls[i + 0])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 0])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = d4(ls[i], ls[i + 1])",
      "mutated_line": "d = d4(ls[i], ls[i + 0])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 0])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d = d4(ls[i], ls[i + 1])",
      "mutated_line": "d = d4(ls[i], ls[i + -1])",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + -1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret[i] += (idx - i) * num",
      "mutated_line": "ret[i] += (idx + i) * num",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx + i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret[i] += (idx - i) * num",
      "mutated_line": "ret[i] += idx * i * num",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += idx * i * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ret[i] += (idx - i) * d",
      "mutated_line": "ret[i] += (idx + i) * d",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx + i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "ret[i] += (idx - i) * d",
      "mutated_line": "ret[i] += idx * i * d",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += idx * i * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 2], ls[i]) - 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 2], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 0], ls[i]) - 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 0], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + 0], ls[i]) - 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + 0], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "d = d4(ls[i + 1], ls[i]) - 1",
      "mutated_line": "d = d4(ls[i + -1], ls[i]) - 1",
      "code": "def min_operations_to_sorted(A):\n\n    def d4(x, y):\n        ret = 0\n        while x > y:\n            y *= 4\n            ret += 1\n        return ret\n\n    def cost(ls):\n        l = len(ls)\n        ret = [0] * l\n        stack = [(l - 1, 10 ** 18)]\n        for i in range(l - 1)[::-1]:\n            ret[i] = ret[i + 1]\n            if ls[i] <= ls[i + 1]:\n                d = d4(ls[i + -1], ls[i]) - 1\n                if d > 0:\n                    stack.append((i, d))\n            else:\n                d = d4(ls[i], ls[i + 1])\n                while d:\n                    (idx, num) = stack.pop()\n                    if d > num:\n                        ret[i] += (idx - i) * num\n                        d -= num\n                    else:\n                        ret[i] += (idx - i) * d\n                        num -= d\n                        d = 0\n                        if num:\n                            stack.append((idx, num))\n        return ret\n    cp = cost(A)\n    cn = cost(A[::-1])\n    n = len(A)\n    for i in range(n):\n        cp[i] *= 2\n        cn[i] *= 2\n        cn[i] += n - i\n    ansls = [cp[0], cn[0]]\n    for i in range(1, n):\n        ansls.append(cp[i] + cn[n - i])\n    return min(ansls)"
    }
  ]
}