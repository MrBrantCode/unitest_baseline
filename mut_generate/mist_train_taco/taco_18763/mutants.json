{
  "task_id": "taco_18763",
  "entry_point": "find_permutations",
  "mutant_count": 25,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_permutations(n, q):\n    \"\"\"\"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pos = 0",
      "mutated_line": "pos = 1",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 1\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pos = 0",
      "mutated_line": "pos = -1",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = -1\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "pos = 0",
      "mutated_line": "pos = 1",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 1\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pos = 0",
      "mutated_line": "pos = 1",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 1\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pos = 0",
      "mutated_line": "pos = -1",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = -1\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pos = 0",
      "mutated_line": "pos = 1",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 1\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j > pos:",
      "mutated_line": "if j >= pos:",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j >= pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j > pos:",
      "mutated_line": "if j <= pos:",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j <= pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j > pos:",
      "mutated_line": "if j != pos:",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j != pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if j > pos:",
      "mutated_line": "if j >= pos:",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j >= pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if j > pos:",
      "mutated_line": "if j <= pos:",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j <= pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if j > pos:",
      "mutated_line": "if j != pos:",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j != pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos - 1, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos - 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos * 1, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos * 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos - 1, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos - 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos * 1, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos * 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos + 2, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 2, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos + 0, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 0, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos + 0, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 0, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos + -1, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + -1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos + 2, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 2, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos + 0, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 0, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos + 0, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + 0, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(pos + 1, j):",
      "mutated_line": "for k in range(pos + -1, j):",
      "code": "def find_permutations(n, q):\n    \"\"\"\n    Given an array q derived from a permutation p, this function finds the lexicographically minimal and maximal permutations that could have been originally presented to Polycarp.\n\n    Parameters:\n    n (int): The length of the permutation p.\n    q (list of int): The array derived from the permutation p.\n\n    Returns:\n    tuple: A tuple containing two lists - the lexicographically minimal permutation and the lexicographically maximal permutation.\n    \"\"\"\n    from collections import deque\n    och = deque()\n    pos = 0\n    min_perm = []\n    for j in q:\n        if j > pos:\n            min_perm.append(j)\n            for k in range(pos + 1, j):\n                och.append(k)\n        else:\n            min_perm.append(och.popleft())\n        pos = j\n    pos = 0\n    max_perm = []\n    for j in q:\n        if j > pos:\n            max_perm.append(j)\n            for k in range(pos + -1, j):\n                och.append(k)\n        else:\n            max_perm.append(och.pop())\n        pos = j\n    return (min_perm, max_perm)"
    }
  ]
}