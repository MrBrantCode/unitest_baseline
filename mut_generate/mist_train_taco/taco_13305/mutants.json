{
  "task_id": "taco_13305",
  "entry_point": "calculate_minimum_time",
  "mutant_count": 181,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 10 * 12",
      "code": "import sys\nINF = 10 * 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 10 + 12",
      "code": "import sys\nINF = 10 + 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 11 ** 12",
      "code": "import sys\nINF = 11 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 9 ** 12",
      "code": "import sys\nINF = 9 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 0 ** 12",
      "code": "import sys\nINF = 0 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 1 ** 12",
      "code": "import sys\nINF = 1 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = -10 ** 12",
      "code": "import sys\nINF = -10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 10 ** 13",
      "code": "import sys\nINF = 10 ** 13\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 10 ** 11",
      "code": "import sys\nINF = 10 ** 11\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 10 ** 0",
      "code": "import sys\nINF = 10 ** 0\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 10 ** 1",
      "code": "import sys\nINF = 10 ** 1\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 12",
      "mutated_line": "INF = 10 ** -12",
      "code": "import sys\nINF = 10 ** -12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "x += self.n - 1",
      "mutated_line": "x -= self.n - 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x -= self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "total_diff = 0",
      "mutated_line": "total_diff = 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 1\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "total_diff = 0",
      "mutated_line": "total_diff = -1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = -1\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "total_diff = 0",
      "mutated_line": "total_diff = 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 1\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "total_diff += diff",
      "mutated_line": "total_diff -= diff",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff -= diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "mutated_line": "return total_diff - min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff - min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "mutated_line": "return total_diff * min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff * min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] / (2 * self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] / (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] + (2 * self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] + (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] ** (2 * self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] ** (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "x += self.n - 1",
      "mutated_line": "x += self.n + 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n + 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "x += self.n - 1",
      "mutated_line": "x += self.n * 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n * 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while x > 0:",
      "mutated_line": "while x >= 0:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x >= 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while x > 0:",
      "mutated_line": "while x <= 0:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x <= 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while x > 0:",
      "mutated_line": "while x != 0:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x != 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while L < R:",
      "mutated_line": "while L <= R:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L <= R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while L < R:",
      "mutated_line": "while L >= R:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L >= R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while L < R:",
      "mutated_line": "while L != R:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L != R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp_l = Rmin(N + 1)",
      "mutated_line": "dp_l = Rmin(N - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N - 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "dp_l = Rmin(N + 1)",
      "mutated_line": "dp_l = Rmin(N * 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N * 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp_r = Rmin(N + 1)",
      "mutated_line": "dp_r = Rmin(N - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N - 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp_r = Rmin(N + 1)",
      "mutated_line": "dp_r = Rmin(N * 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N * 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "dp_l.Update(B, -B)",
      "mutated_line": "dp_l.Update(B, +B)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, +B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.n = 1 << size.bit_length()",
      "mutated_line": "self.n = 2 << size.bit_length()",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 2 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.n = 1 << size.bit_length()",
      "mutated_line": "self.n = 0 << size.bit_length()",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 0 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.n = 1 << size.bit_length()",
      "mutated_line": "self.n = 0 << size.bit_length()",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 0 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.n = 1 << size.bit_length()",
      "mutated_line": "self.n = -1 << size.bit_length()",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = -1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 * self.n + 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n + 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 * self.n * 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n * 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return self.node[x + self.n - 1]",
      "mutated_line": "return self.node[x + self.n + 1]",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n + 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return self.node[x + self.n - 1]",
      "mutated_line": "return self.node[(x + self.n) * 1]",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[(x + self.n) * 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x += self.n - 1",
      "mutated_line": "x += self.n - 2",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 2\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x += self.n - 1",
      "mutated_line": "x += self.n - 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 0\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x += self.n - 1",
      "mutated_line": "x += self.n - 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 0\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "x += self.n - 1",
      "mutated_line": "x += self.n - -1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - -1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while x > 0:",
      "mutated_line": "while x > 1:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 1:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while x > 0:",
      "mutated_line": "while x > -1:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > -1:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while x > 0:",
      "mutated_line": "while x > 1:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 1:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(L, R) = (l + self.n, r + self.n)",
      "mutated_line": "(L, R) = (l - self.n, r + self.n)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l - self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(L, R) = (l + self.n, r + self.n)",
      "mutated_line": "(L, R) = (l * self.n, r + self.n)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l * self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(L, R) = (l + self.n, r + self.n)",
      "mutated_line": "(L, R) = (l + self.n, r - self.n)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r - self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "(L, R) = (l + self.n, r + self.n)",
      "mutated_line": "(L, R) = (l + self.n, r * self.n)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r * self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if R & 1:",
      "mutated_line": "if R | 1:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R | 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "R -= 1",
      "mutated_line": "R += 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R += 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if L & 1:",
      "mutated_line": "if L | 1:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L | 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "L += 1",
      "mutated_line": "L -= 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L -= 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "L >>= 1",
      "mutated_line": "L >>= 2",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 2\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "L >>= 1",
      "mutated_line": "L >>= 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 0\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "L >>= 1",
      "mutated_line": "L >>= 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 0\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "L >>= 1",
      "mutated_line": "L >>= -1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= -1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R >>= 1",
      "mutated_line": "R >>= 2",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 2\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R >>= 1",
      "mutated_line": "R >>= 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 0\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R >>= 1",
      "mutated_line": "R >>= 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 0\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "R >>= 1",
      "mutated_line": "R >>= -1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= -1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp_l = Rmin(N + 1)",
      "mutated_line": "dp_l = Rmin(N + 2)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 2)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp_l = Rmin(N + 1)",
      "mutated_line": "dp_l = Rmin(N + 0)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 0)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp_l = Rmin(N + 1)",
      "mutated_line": "dp_l = Rmin(N + 0)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 0)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp_l = Rmin(N + 1)",
      "mutated_line": "dp_l = Rmin(N + -1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + -1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp_r = Rmin(N + 1)",
      "mutated_line": "dp_r = Rmin(N + 2)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 2)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp_r = Rmin(N + 1)",
      "mutated_line": "dp_r = Rmin(N + 0)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 0)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp_r = Rmin(N + 1)",
      "mutated_line": "dp_r = Rmin(N + 0)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 0)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dp_r = Rmin(N + 1)",
      "mutated_line": "dp_r = Rmin(N + -1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + -1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "diff = abs(y - x)",
      "mutated_line": "diff = abs(y + x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y + x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "diff = abs(y - x)",
      "mutated_line": "diff = abs(y * x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y * x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "l_min = dp_l.Get(1, y)",
      "mutated_line": "l_min = dp_l.Get(2, y)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(2, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "l_min = dp_l.Get(1, y)",
      "mutated_line": "l_min = dp_l.Get(0, y)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(0, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "l_min = dp_l.Get(1, y)",
      "mutated_line": "l_min = dp_l.Get(0, y)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(0, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "l_min = dp_l.Get(1, y)",
      "mutated_line": "l_min = dp_l.Get(-1, y)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(-1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "r_min = dp_r.Get(y, N + 1)",
      "mutated_line": "r_min = dp_r.Get(y, N - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N - 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "r_min = dp_r.Get(y, N + 1)",
      "mutated_line": "r_min = dp_r.Get(y, N * 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N * 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res = min(l_min + y, r_min - y)",
      "mutated_line": "res = min(l_min - y, r_min - y)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min - y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res = min(l_min + y, r_min - y)",
      "mutated_line": "res = min(l_min * y, r_min - y)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min * y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res = min(l_min + y, r_min - y)",
      "mutated_line": "res = min(l_min + y, r_min + y)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min + y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "res = min(l_min + y, r_min - y)",
      "mutated_line": "res = min(l_min + y, r_min * y)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min * y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dp_l.Update(x, res - diff - x)",
      "mutated_line": "dp_l.Update(x, res - diff + x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff + x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dp_l.Update(x, res - diff - x)",
      "mutated_line": "dp_l.Update(x, (res - diff) * x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, (res - diff) * x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp_r.Update(x, res - diff + x)",
      "mutated_line": "dp_r.Update(x, res - diff - x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff - x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp_r.Update(x, res - diff + x)",
      "mutated_line": "dp_r.Update(x, (res - diff) * x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, (res - diff) * x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 / self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 / self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 + self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 + self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 ** self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 ** self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 * self.n - 2)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 2)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 * self.n - 0)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 0)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 * self.n - 0)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 0)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (2 * self.n - -1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - -1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return self.node[x + self.n - 1]",
      "mutated_line": "return self.node[x - self.n - 1]",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x - self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return self.node[x + self.n - 1]",
      "mutated_line": "return self.node[x * self.n - 1]",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x * self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return self.node[x + self.n - 1]",
      "mutated_line": "return self.node[x + self.n - 2]",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 2]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return self.node[x + self.n - 1]",
      "mutated_line": "return self.node[x + self.n - 0]",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 0]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return self.node[x + self.n - 1]",
      "mutated_line": "return self.node[x + self.n - 0]",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 0]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return self.node[x + self.n - 1]",
      "mutated_line": "return self.node[x + self.n - -1]",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - -1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x + 1 >> 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x + 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x * 1 >> 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x * 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x - 1 >> 2",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 2\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x - 1 >> 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 0\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x - 1 >> 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 0\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x - 1 >> -1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> -1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if R & 1:",
      "mutated_line": "if R & 2:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 2:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if R & 1:",
      "mutated_line": "if R & 0:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 0:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if R & 1:",
      "mutated_line": "if R & 0:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 0:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if R & 1:",
      "mutated_line": "if R & -1:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & -1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "R -= 1",
      "mutated_line": "R -= 2",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 2\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "R -= 1",
      "mutated_line": "R -= 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 0\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "R -= 1",
      "mutated_line": "R -= 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 0\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "R -= 1",
      "mutated_line": "R -= -1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= -1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if L & 1:",
      "mutated_line": "if L & 2:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 2:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if L & 1:",
      "mutated_line": "if L & 0:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 0:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if L & 1:",
      "mutated_line": "if L & 0:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 0:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if L & 1:",
      "mutated_line": "if L & -1:",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & -1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "L += 1",
      "mutated_line": "L += 2",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 2\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "L += 1",
      "mutated_line": "L += 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 0\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "L += 1",
      "mutated_line": "L += 0",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 0\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "L += 1",
      "mutated_line": "L += -1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += -1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "r_min = dp_r.Get(y, N + 1)",
      "mutated_line": "r_min = dp_r.Get(y, N + 2)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 2)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "r_min = dp_r.Get(y, N + 1)",
      "mutated_line": "r_min = dp_r.Get(y, N + 0)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 0)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "r_min = dp_r.Get(y, N + 1)",
      "mutated_line": "r_min = dp_r.Get(y, N + 0)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 0)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "r_min = dp_r.Get(y, N + 1)",
      "mutated_line": "r_min = dp_r.Get(y, N + -1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + -1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dp_l.Update(x, res - diff - x)",
      "mutated_line": "dp_l.Update(x, res + diff - x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res + diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dp_l.Update(x, res - diff - x)",
      "mutated_line": "dp_l.Update(x, res * diff - x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res * diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp_r.Update(x, res - diff + x)",
      "mutated_line": "dp_r.Update(x, res + diff + x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res + diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "dp_r.Update(x, res - diff + x)",
      "mutated_line": "dp_r.Update(x, res * diff + x)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res * diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (3 * self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (3 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (1 * self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (1 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (0 * self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (0 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (1 * self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (1 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.node = [INF] * (2 * self.n - 1)",
      "mutated_line": "self.node = [INF] * (-2 * self.n - 1)",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (-2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x - 2 >> 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 2 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x - 0 >> 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 0 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x - 0 >> 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 0 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = x - 1 >> 1",
      "mutated_line": "x = x - -1 >> 1",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - -1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) - 1], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) - 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) * 1], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) * 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) - 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) - 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) * 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) * 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "mutated_line": "return total_diff + min((l - r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l - r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "mutated_line": "return total_diff + min((l * r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l * r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "mutated_line": "return total_diff + min((l + r >> 2 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 2 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "mutated_line": "return total_diff + min((l + r >> 0 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 0 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "mutated_line": "return total_diff + min((l + r >> 0 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 0 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "mutated_line": "return total_diff + min((l + r >> -1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> -1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 2], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 2], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 0], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 0], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 0], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 0], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + -1], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + -1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 3])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 3])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 1])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 1])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 0])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 0])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 1])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 1])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + -2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + -2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "s = min(s, self.node[R - 1])",
      "mutated_line": "s = min(s, self.node[R + 1])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R + 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "s = min(s, self.node[R - 1])",
      "mutated_line": "s = min(s, self.node[R * 1])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R * 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = min(s, self.node[L - 1])",
      "mutated_line": "s = min(s, self.node[L + 1])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L + 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "s = min(s, self.node[L - 1])",
      "mutated_line": "s = min(s, self.node[L * 1])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L * 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 2) + 1], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 2) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 0) + 1], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 0) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 0) + 1], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 0) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << -1) + 1], self.node[(x << 1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << -1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 2) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 2) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 0) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 0) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 0) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 0) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])",
      "mutated_line": "self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << -1) + 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << -1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = min(s, self.node[R - 1])",
      "mutated_line": "s = min(s, self.node[R - 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 2])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = min(s, self.node[R - 1])",
      "mutated_line": "s = min(s, self.node[R - 0])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 0])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = min(s, self.node[R - 1])",
      "mutated_line": "s = min(s, self.node[R - 0])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 0])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "s = min(s, self.node[R - 1])",
      "mutated_line": "s = min(s, self.node[R - -1])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - -1])\n            if L & 1:\n                s = min(s, self.node[L - 1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = min(s, self.node[L - 1])",
      "mutated_line": "s = min(s, self.node[L - 2])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 2])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = min(s, self.node[L - 1])",
      "mutated_line": "s = min(s, self.node[L - 0])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 0])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = min(s, self.node[L - 1])",
      "mutated_line": "s = min(s, self.node[L - 0])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - 0])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "s = min(s, self.node[L - 1])",
      "mutated_line": "s = min(s, self.node[L - -1])",
      "code": "import sys\nINF = 10 ** 12\n\nclass Rmin:\n\n    def __init__(self, size):\n        self.n = 1 << size.bit_length()\n        self.node = [INF] * (2 * self.n - 1)\n\n    def Access(self, x):\n        return self.node[x + self.n - 1]\n\n    def Update(self, x, val):\n        x += self.n - 1\n        self.node[x] = val\n        while x > 0:\n            x = x - 1 >> 1\n            self.node[x] = min(self.node[(x << 1) + 1], self.node[(x << 1) + 2])\n        return\n\n    def Get(self, l, r):\n        (L, R) = (l + self.n, r + self.n)\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, self.node[R - 1])\n            if L & 1:\n                s = min(s, self.node[L - -1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\ndef calculate_minimum_time(N, Q, A, B, queries):\n    dp_l = Rmin(N + 1)\n    dp_r = Rmin(N + 1)\n    dp_l.Update(B, -B)\n    dp_r.Update(B, B)\n    total_diff = 0\n    x = A\n    for y in queries:\n        diff = abs(y - x)\n        l_min = dp_l.Get(1, y)\n        r_min = dp_r.Get(y, N + 1)\n        res = min(l_min + y, r_min - y)\n        dp_l.Update(x, res - diff - x)\n        dp_r.Update(x, res - diff + x)\n        total_diff += diff\n        x = y\n    N = dp_l.n\n    return total_diff + min((l + r >> 1 for (l, r) in zip(dp_l.node[N:], dp_r.node[N:])))"
    }
  ]
}