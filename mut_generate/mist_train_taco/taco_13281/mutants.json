{
  "task_id": "taco_13281",
  "entry_point": "count_reachable_cells",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if mat[r][c] == '#':",
      "mutated_line": "if mat[r][c] != '#':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] != '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return len(visited) - obstacles",
      "mutated_line": "return len(visited) + obstacles",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) + obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return len(visited) - obstacles",
      "mutated_line": "return len(visited) * obstacles",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) * obstacles"
    },
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 0 or (i, j - 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 or (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 1 or (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 or (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 or i > 0 or (i - 1, j) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 or i > 0 or (i - 1, j) not in visited:\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 or i < n - 1 or (i + 1, j) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 or i < n - 1 or (i + 1, j) not in visited:\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if mat[r][c] == '#':",
      "mutated_line": "if mat[r][c] == '':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 1\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return -1\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 1\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j >= 0 and (i, j - 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j >= 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j <= 0 and (i, j - 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j <= 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j != 0 and (i, j - 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j != 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 0 and (i, j - 1) in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j <= m - 1 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j <= m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j >= m - 1 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j >= m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j != m - 1 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j != m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 1 and (i, j + 1) in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u >= 0 and i > 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u >= 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u <= 0 and i > 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u <= 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u != 0 and i > 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u != 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i >= 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i >= 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i <= 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i <= 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i != 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i != 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 0 and ((i - 1, j) in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d >= 0 and i < n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d >= 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d <= 0 and i < n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d <= 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d != 0 and i < n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d != 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i <= n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i <= n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i >= n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i >= n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i != n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i != n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 1 and ((i + 1, j) in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if mat[i][j] == '#':",
      "mutated_line": "if mat[i][j] != '#':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] != '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 1 and (i, j - 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 1 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > -1 and (i, j - 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > -1 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 1 and (i, j - 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 1 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m + 1 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m + 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m * 1 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m * 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 1 and i > 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 1 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > -1 and i > 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > -1 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 1 and i > 0 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 1 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 1 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 1 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > -1 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > -1 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 1 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 1 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 1 and i < n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 1 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > -1 and i < n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > -1 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 1 and i < n - 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 1 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n + 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n + 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n * 1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n * 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if mat[i][j] == '#':",
      "mutated_line": "if mat[i][j] == '':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 0 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j + 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 0 and (i, j * 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j * 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited.add((i, j - 1))",
      "mutated_line": "visited.add((i, j + 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited.add((i, j - 1))",
      "mutated_line": "visited.add((i, j * 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j * 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "queue.append((i, j - 1, u, d))",
      "mutated_line": "queue.append((i, j + 1, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j + 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "queue.append((i, j - 1, u, d))",
      "mutated_line": "queue.append((i, j * 1, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j * 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 2 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 2 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 0 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 0 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 0 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 0 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - -1 and (i, j + 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - -1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 1 and (i, j - 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j - 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 1 and (i, j * 1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j * 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "visited.add((i, j + 1))",
      "mutated_line": "visited.add((i, j - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "visited.add((i, j + 1))",
      "mutated_line": "visited.add((i, j * 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j * 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "queue.append((i, j + 1, u, d))",
      "mutated_line": "queue.append((i, j - 1, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j - 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "queue.append((i, j + 1, u, d))",
      "mutated_line": "queue.append((i, j * 1, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j * 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 0 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i + 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 0 and ((i * 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i * 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "visited.add((i - 1, j))",
      "mutated_line": "visited.add((i + 1, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "visited.add((i - 1, j))",
      "mutated_line": "visited.add((i * 1, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i * 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i + 1, j, u - 1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i + 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i * 1, j, u - 1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i * 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 1, j, u + 1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u + 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 1, j, u * 1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u * 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 2 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 2 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 0 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 0 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 0 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 0 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - -1 and ((i + 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - -1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 1 and ((i - 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i - 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 1 and ((i * 1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i * 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited.add((i + 1, j))",
      "mutated_line": "visited.add((i - 1, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited.add((i + 1, j))",
      "mutated_line": "visited.add((i * 1, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i * 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i - 1, j, u, d - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i - 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i * 1, j, u, d - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i * 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 1, j, u, d + 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d + 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 1, j, u, d * 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d * 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 0 and (i, j - 2) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 2) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 0 and (i, j - 0) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 0) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 0 and (i, j - 0) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 0) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if j > 0 and (i, j - 1) not in visited:",
      "mutated_line": "if j > 0 and (i, j - -1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - -1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited.add((i, j - 1))",
      "mutated_line": "visited.add((i, j - 2))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 2))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited.add((i, j - 1))",
      "mutated_line": "visited.add((i, j - 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 0))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited.add((i, j - 1))",
      "mutated_line": "visited.add((i, j - 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 0))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited.add((i, j - 1))",
      "mutated_line": "visited.add((i, j - -1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - -1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((i, j - 1, u, d))",
      "mutated_line": "queue.append((i, j - 2, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 2, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((i, j - 1, u, d))",
      "mutated_line": "queue.append((i, j - 0, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 0, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((i, j - 1, u, d))",
      "mutated_line": "queue.append((i, j - 0, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 0, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "queue.append((i, j - 1, u, d))",
      "mutated_line": "queue.append((i, j - -1, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - -1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 1 and (i, j + 2) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 2) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 1 and (i, j + 0) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 0) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 1 and (i, j + 0) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 0) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if j < m - 1 and (i, j + 1) not in visited:",
      "mutated_line": "if j < m - 1 and (i, j + -1) not in visited:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + -1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((i, j + 1))",
      "mutated_line": "visited.add((i, j + 2))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 2))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((i, j + 1))",
      "mutated_line": "visited.add((i, j + 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 0))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((i, j + 1))",
      "mutated_line": "visited.add((i, j + 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 0))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visited.add((i, j + 1))",
      "mutated_line": "visited.add((i, j + -1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + -1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "queue.append((i, j + 1, u, d))",
      "mutated_line": "queue.append((i, j + 2, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 2, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "queue.append((i, j + 1, u, d))",
      "mutated_line": "queue.append((i, j + 0, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 0, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "queue.append((i, j + 1, u, d))",
      "mutated_line": "queue.append((i, j + 0, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 0, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "queue.append((i, j + 1, u, d))",
      "mutated_line": "queue.append((i, j + -1, u, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + -1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 0 and ((i - 2, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 2, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 0 and ((i - 0, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 0, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 0 and ((i - 0, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 0, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if u > 0 and i > 0 and (i - 1, j) not in visited:",
      "mutated_line": "if u > 0 and i > 0 and ((i - -1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - -1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited.add((i - 1, j))",
      "mutated_line": "visited.add((i - 2, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 2, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited.add((i - 1, j))",
      "mutated_line": "visited.add((i - 0, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 0, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited.add((i - 1, j))",
      "mutated_line": "visited.add((i - 0, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 0, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited.add((i - 1, j))",
      "mutated_line": "visited.add((i - -1, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - -1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 2, j, u - 1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 2, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 0, j, u - 1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 0, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 0, j, u - 1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 0, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - -1, j, u - 1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - -1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 1, j, u - 2, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 2, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 1, j, u - 0, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 0, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 1, j, u - 0, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 0, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append((i - 1, j, u - 1, d))",
      "mutated_line": "queue.append((i - 1, j, u - -1, d))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - -1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 1 and ((i + 2, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 2, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 1 and ((i + 0, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 0, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 1 and ((i + 0, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 0, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d > 0 and i < n - 1 and (i + 1, j) not in visited:",
      "mutated_line": "if d > 0 and i < n - 1 and ((i + -1, j) not in visited):",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + -1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited.add((i + 1, j))",
      "mutated_line": "visited.add((i + 2, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 2, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited.add((i + 1, j))",
      "mutated_line": "visited.add((i + 0, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 0, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited.add((i + 1, j))",
      "mutated_line": "visited.add((i + 0, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 0, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited.add((i + 1, j))",
      "mutated_line": "visited.add((i + -1, j))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + -1, j))\n            queue.append((i + 1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 2, j, u, d - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 2, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 0, j, u, d - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 0, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 0, j, u, d - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 0, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + -1, j, u, d - 1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + -1, j, u, d - 1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 1, j, u, d - 2))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 2))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 1, j, u, d - 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 0))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 1, j, u, d - 0))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - 0))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "queue.append((i + 1, j, u, d - 1))",
      "mutated_line": "queue.append((i + 1, j, u, d - -1))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, u, d, mat):\n\n    def helper(i, j, u, d):\n        if j > 0 and (i, j - 1) not in visited:\n            visited.add((i, j - 1))\n            queue.append((i, j - 1, u, d))\n        if j < m - 1 and (i, j + 1) not in visited:\n            visited.add((i, j + 1))\n            queue.append((i, j + 1, u, d))\n        if u > 0 and i > 0 and ((i - 1, j) not in visited):\n            visited.add((i - 1, j))\n            queue.append((i - 1, j, u - 1, d))\n        if d > 0 and i < n - 1 and ((i + 1, j) not in visited):\n            visited.add((i + 1, j))\n            queue.append((i + 1, j, u, d - -1))\n    if mat[r][c] == '#':\n        return 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == '#':\n                visited.add((i, j))\n    obstacles = len(visited)\n    visited.add((r, c))\n    queue = deque([(r, c, u, d)])\n    while queue:\n        (a, b, u, d) = queue.popleft()\n        helper(a, b, u, d)\n    return len(visited) - obstacles"
    }
  ]
}