{
  "task_id": "taco_16646",
  "entry_point": "minimum_ambiguity_to_avoid_hard",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 - [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 - [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 * [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 * [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] / 4 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] / 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] + 4 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] + 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] ** 4 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] ** 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c in 'hard':",
      "mutated_line": "if c not in 'hard':",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c not in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 5 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 5 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 3 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 3 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 0 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 0 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 1 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 1 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * -4 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * -4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [10 * 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 * 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [10 + 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 + 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if c in 'hard':",
      "mutated_line": "if c in '':",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in '':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "c2c = {c: i for (i, c) in enumerate('hard')}",
      "mutated_line": "c2c = {c: i for (i, c) in enumerate('')}",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [1] * 4 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [1] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [-1] * 4 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [-1] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [1] * 4 + [10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [1] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [11 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [11 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [9 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [9 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [0 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [0 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [1 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [1 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [-10 ** 19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [-10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [10 ** 20]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 20]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [10 ** 18]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 18]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [10 ** 0]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 0]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [10 ** 1]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 1]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp = [0] * 4 + [10 ** 19]",
      "mutated_line": "dp = [0] * 4 + [10 ** -19]",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** -19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 1])",
      "mutated_line": "dp[idx] = min(dp[idx] - a[i], dp[idx - 1])",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] - a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 1])",
      "mutated_line": "dp[idx] = min(dp[idx] * a[i], dp[idx - 1])",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] * a[i], dp[idx - 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 1])",
      "mutated_line": "dp[idx] = min(dp[idx] + a[i], dp[idx + 1])",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx + 1])\n    return min(dp)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 1])",
      "mutated_line": "dp[idx] = min(dp[idx] + a[i], dp[idx * 1])",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx * 1])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 1])",
      "mutated_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 2])",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 2])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 1])",
      "mutated_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 0])",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 0])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 1])",
      "mutated_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 0])",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - 0])\n    return min(dp)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - 1])",
      "mutated_line": "dp[idx] = min(dp[idx] + a[i], dp[idx - -1])",
      "code": "def minimum_ambiguity_to_avoid_hard(n: int, s: str, a: list) -> int:\n    \"\"\"\n    Calculates the minimum ambiguity of the statement after removing some characters\n    to ensure the statement does not contain the subsequence 'hard'.\n\n    Parameters:\n    - n (int): The length of the statement.\n    - s (str): The statement string.\n    - a (list): The list of integers representing the ambiguity costs for each character.\n\n    Returns:\n    - int: The minimum possible ambiguity of the statement.\n    \"\"\"\n    c2c = {c: i for (i, c) in enumerate('hard')}\n    dp = [0] * 4 + [10 ** 19]\n    for (i, c) in enumerate(s):\n        if c in 'hard':\n            idx = c2c[c]\n            dp[idx] = min(dp[idx] + a[i], dp[idx - -1])\n    return min(dp)"
    }
  ]
}