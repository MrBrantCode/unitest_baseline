{
  "task_id": "taco_10639",
  "entry_point": "min_swaps_to_bst",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "visited = [-1] * n",
      "mutated_line": "visited = [-1] / n",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] / n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "visited = [-1] * n",
      "mutated_line": "visited = [-1] + n",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] + n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "visited = [-1] * n",
      "mutated_line": "visited = [-1] ** n",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] ** n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 1\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = -1\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 1\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return self.val == other.val",
      "mutated_line": "return self.val != other.val",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val != other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return self.val < other.val",
      "mutated_line": "return self.val <= other.val",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val <= other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return self.val < other.val",
      "mutated_line": "return self.val >= other.val",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val >= other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return self.val < other.val",
      "mutated_line": "return self.val != other.val",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val != other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if index >= n:",
      "mutated_line": "if index > n:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index > n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if index >= n:",
      "mutated_line": "if index < n:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index < n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if index >= n:",
      "mutated_line": "if index == n:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index == n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "_inorder_traversal(0)",
      "mutated_line": "_inorder_traversal(1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(1)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "_inorder_traversal(0)",
      "mutated_line": "_inorder_traversal(-1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(-1)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "_inorder_traversal(0)",
      "mutated_line": "_inorder_traversal(1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(1)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cycle_size = 0",
      "mutated_line": "cycle_size = 1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 1\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cycle_size = 0",
      "mutated_line": "cycle_size = -1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = -1\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cycle_size = 0",
      "mutated_line": "cycle_size = 1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 1\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while visited[curr_index] == -1:",
      "mutated_line": "while visited[curr_index] != -1:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] != -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "cycle_size += 1",
      "mutated_line": "cycle_size -= 1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size -= 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if cycle_size > 0:",
      "mutated_line": "if cycle_size >= 0:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size >= 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if cycle_size > 0:",
      "mutated_line": "if cycle_size <= 0:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size <= 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if cycle_size > 0:",
      "mutated_line": "if cycle_size != 0:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size != 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "ans += cycle_size - 1",
      "mutated_line": "ans -= cycle_size - 1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans -= cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 * index - 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index - 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 * index * 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index * 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 * index - 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index - 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 * index * 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index * 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "visited = [-1] * n",
      "mutated_line": "visited = [+1] * n",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [+1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "while visited[curr_index] == -1:",
      "mutated_line": "while visited[curr_index] == +1:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == +1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cycle_size += 1",
      "mutated_line": "cycle_size += 2",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 2\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cycle_size += 1",
      "mutated_line": "cycle_size += 0",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 0\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cycle_size += 1",
      "mutated_line": "cycle_size += 0",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 0\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cycle_size += 1",
      "mutated_line": "cycle_size += -1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += -1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "visited[curr_index] = 1",
      "mutated_line": "visited[curr_index] = 2",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 2\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "visited[curr_index] = 1",
      "mutated_line": "visited[curr_index] = 0",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 0\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "visited[curr_index] = 1",
      "mutated_line": "visited[curr_index] = 0",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 0\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "visited[curr_index] = 1",
      "mutated_line": "visited[curr_index] = -1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = -1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if cycle_size > 0:",
      "mutated_line": "if cycle_size > 1:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 1:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if cycle_size > 0:",
      "mutated_line": "if cycle_size > -1:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > -1:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if cycle_size > 0:",
      "mutated_line": "if cycle_size > 1:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 1:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans += cycle_size - 1",
      "mutated_line": "ans += cycle_size + 1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size + 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans += cycle_size - 1",
      "mutated_line": "ans += cycle_size * 1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size * 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 / index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 / index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 + index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 + index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 ** index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 ** index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 * index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 2)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 * index + 0)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 0)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 * index + 0)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 0)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(2 * index + -1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + -1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 / index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 / index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 + index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 + index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 ** index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 ** index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 * index + 3)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 3)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 * index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 1)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 * index + 0)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 0)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 * index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 1)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(2 * index + -2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + -2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [-1] * n",
      "mutated_line": "visited = [-2] * n",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-2] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [-1] * n",
      "mutated_line": "visited = [-0] * n",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-0] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [-1] * n",
      "mutated_line": "visited = [-0] * n",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-0] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "visited = [-1] * n",
      "mutated_line": "visited = [--1] * n",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [--1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while visited[curr_index] == -1:",
      "mutated_line": "while visited[curr_index] == -2:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -2:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while visited[curr_index] == -1:",
      "mutated_line": "while visited[curr_index] == -0:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -0:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while visited[curr_index] == -1:",
      "mutated_line": "while visited[curr_index] == -0:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -0:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while visited[curr_index] == -1:",
      "mutated_line": "while visited[curr_index] == --1:",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == --1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += cycle_size - 1",
      "mutated_line": "ans += cycle_size - 2",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += cycle_size - 1",
      "mutated_line": "ans += cycle_size - 0",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += cycle_size - 1",
      "mutated_line": "ans += cycle_size - 0",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += cycle_size - 1",
      "mutated_line": "ans += cycle_size - -1",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - -1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(3 * index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(3 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(1 * index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(1 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(0 * index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(0 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(1 * index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(1 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "_inorder_traversal(2 * index + 1)",
      "mutated_line": "_inorder_traversal(-2 * index + 1)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(-2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(3 * index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(3 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(1 * index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(1 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(0 * index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(0 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(1 * index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(1 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "_inorder_traversal(2 * index + 2)",
      "mutated_line": "_inorder_traversal(-2 * index + 2)",
      "code": "from typing import List\n\nclass pair:\n\n    def __init__(self, val, index):\n        self.val = val\n        self.index = index\n\n    def __eq__(self, other):\n        return self.val == other.val\n\n    def __lt__(self, other):\n        return self.val < other.val\n\ndef min_swaps_to_bst(A: List[int]) -> int:\n    n = len(A)\n    inorder = []\n\n    def _inorder_traversal(index):\n        if index >= n:\n            return\n        _inorder_traversal(2 * index + 1)\n        inorder.append(A[index])\n        _inorder_traversal(-2 * index + 2)\n    _inorder_traversal(0)\n    temp = [pair(inorder[i], i) for i in range(n)]\n    temp.sort()\n    visited = [-1] * n\n    ans = 0\n    for index in range(n):\n        cycle_size = 0\n        curr_index = index\n        while visited[curr_index] == -1:\n            cycle_size += 1\n            visited[curr_index] = 1\n            curr_index = temp[curr_index].index\n        if cycle_size > 0:\n            ans += cycle_size - 1\n    return ans"
    }
  ]
}