{
  "task_id": "taco_17816",
  "entry_point": "dijkstra",
  "mutant_count": 49,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "distance = [float('inf')] * size",
      "mutated_line": "distance = [float('inf')] / size",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] / size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "distance = [float('inf')] * size",
      "mutated_line": "distance = [float('inf')] + size",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] + size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "distance = [float('inf')] * size",
      "mutated_line": "distance = [float('inf')] ** size",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] ** size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance[source] = 0",
      "mutated_line": "distance[source] = 1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 1\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance[source] = 0",
      "mutated_line": "distance[source] = -1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = -1\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance[source] = 0",
      "mutated_line": "distance[source] = 1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 1\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False] * size",
      "mutated_line": "visited = [False] / size",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] / size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False] * size",
      "mutated_line": "visited = [False] + size",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] + size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [False] * size",
      "mutated_line": "visited = [False] ** size",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] ** size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u += 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v += 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "min_cost = 0",
      "mutated_line": "min_cost = 1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 1\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "min_cost = 0",
      "mutated_line": "min_cost = -1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = -1\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "min_cost = 0",
      "mutated_line": "min_cost = 1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 1\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "min_cost += cost",
      "mutated_line": "min_cost -= cost",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost -= cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[u] = True",
      "mutated_line": "visited[u] = False",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = False\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 2\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 0\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 0\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= -1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 2\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 0\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 0\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= -1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = dijkstra(edges, N, 0)",
      "mutated_line": "dist = dijkstra(edges, N, 1)",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 1)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = dijkstra(edges, N, 0)",
      "mutated_line": "dist = dijkstra(edges, N, -1)",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, -1)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist = dijkstra(edges, N, 0)",
      "mutated_line": "dist = dijkstra(edges, N, 1)",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 1)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, N):",
      "mutated_line": "for u in range(2, N):",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(2, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, N):",
      "mutated_line": "for u in range(0, N):",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(0, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, N):",
      "mutated_line": "for u in range(0, N):",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(0, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for u in range(1, N):",
      "mutated_line": "for u in range(-1, N):",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(-1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 1000",
      "mutated_line": "cost = 1001",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1001\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 1000",
      "mutated_line": "cost = 999",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 999\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 1000",
      "mutated_line": "cost = 0",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 0\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 1000",
      "mutated_line": "cost = 1",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = 1000",
      "mutated_line": "cost = -1000",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = -1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [False] * size",
      "mutated_line": "visited = [True] * size",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [True] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "heappush(pq, (0, source))",
      "mutated_line": "heappush(pq, (1, source))",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (1, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "heappush(pq, (0, source))",
      "mutated_line": "heappush(pq, (-1, source))",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (-1, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "heappush(pq, (0, source))",
      "mutated_line": "heappush(pq, (1, source))",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (1, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if dist[u] == dist[v] + d:",
      "mutated_line": "if dist[u] != dist[v] + d:",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] != dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "distance = [float('inf')] * size",
      "mutated_line": "distance = [float('')] * size",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_dist = dist_u + weight",
      "mutated_line": "new_dist = dist_u - weight",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u - weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "new_dist = dist_u + weight",
      "mutated_line": "new_dist = dist_u * weight",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u * weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if distance[v] > new_dist:",
      "mutated_line": "if distance[v] >= new_dist:",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] >= new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if distance[v] > new_dist:",
      "mutated_line": "if distance[v] <= new_dist:",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] <= new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if distance[v] > new_dist:",
      "mutated_line": "if distance[v] != new_dist:",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] != new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] + d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if dist[u] == dist[v] + d:",
      "mutated_line": "if dist[u] == dist[v] - d:",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] - d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if dist[u] == dist[v] + d:",
      "mutated_line": "if dist[u] == dist[v] * d:",
      "code": "from heapq import heappush, heappop\n\ndef dijkstra(edges, size, source):\n    distance = [float('inf')] * size\n    distance[source] = 0\n    visited = [False] * size\n    pq = []\n    heappush(pq, (0, source))\n    while pq:\n        (dist_u, u) = heappop(pq)\n        visited[u] = True\n        for (v, weight, _) in edges[u]:\n            if not visited[v]:\n                new_dist = dist_u + weight\n                if distance[v] > new_dist:\n                    distance[v] = new_dist\n                    heappush(pq, (new_dist, v))\n    return distance\n\ndef calculate_minimum_construction_cost(N, M, roads):\n    edges = [[] for _ in range(N)]\n    for (u, v, d, c) in roads:\n        u -= 1\n        v -= 1\n        edges[u].append((v, d, c))\n        edges[v].append((u, d, c))\n    dist = dijkstra(edges, N, 0)\n    min_cost = 0\n    for u in range(1, N):\n        cost = 1000\n        for (v, d, c) in edges[u]:\n            if dist[u] == dist[v] * d:\n                cost = min(cost, c)\n        min_cost += cost\n    return min_cost"
    }
  ]
}