{
  "task_id": "taco_4263",
  "entry_point": "count_remaining_candies",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "ma = m * n // math.gcd(m, n)",
      "mutated_line": "ma = m * n / math.gcd(m, n)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n / math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "ma = m * n // math.gcd(m, n)",
      "mutated_line": "ma = m * n * math.gcd(m, n)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n * math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "marked = [0] * ma",
      "mutated_line": "marked[0] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] / ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "marked = [0] * ma",
      "mutated_line": "marked[0] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] + ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "marked = [0] * ma",
      "mutated_line": "marked[0] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] ** ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "marked[0] = 1  # Starting position is visited",
      "mutated_line": "marked[0] = 2",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 2\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "marked[0] = 1  # Starting position is visited",
      "mutated_line": "marked[0] = 0",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "marked[0] = 1  # Starting position is visited",
      "mutated_line": "marked[0] = 0",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 0\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "marked[0] = 1  # Starting position is visited",
      "mutated_line": "marked[0] = -1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = -1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "ma = m * n // math.gcd(m, n)",
      "mutated_line": "ma = m / n // math.gcd(m, n)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m / n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "ma = m * n // math.gcd(m, n)",
      "mutated_line": "ma = (m + n) // math.gcd(m, n)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = (m + n) // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "ma = m * n // math.gcd(m, n)",
      "mutated_line": "ma = m ** n // math.gcd(m, n)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m ** n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "marked[0] = 1  # Starting position is visited",
      "mutated_line": "marked[1] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[1] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "marked[0] = 1  # Starting position is visited",
      "mutated_line": "marked[-1] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[-1] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "marked[0] = 1  # Starting position is visited",
      "mutated_line": "marked[1] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[1] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(1)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(1)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(-1)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(-1)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "q.append(0)",
      "mutated_line": "q.append(1)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(1)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m < ma or marked[curr + m] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma or marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n < ma or marked[curr + n] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma or marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return marked.count(0)",
      "mutated_line": "return marked.count(1)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return marked.count(0)",
      "mutated_line": "return marked.count(-1)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(-1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return marked.count(0)",
      "mutated_line": "return marked.count(1)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "marked = [0] * ma",
      "mutated_line": "marked[0] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [1] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "marked = [0] * ma",
      "mutated_line": "marked[0] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [-1] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "marked = [0] * ma",
      "mutated_line": "marked[0] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [1] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m <= ma and marked[curr + m] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m <= ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m >= ma and marked[curr + m] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m >= ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m != ma and marked[curr + m] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m != ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m < ma and marked[curr + m] != 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] != 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "marked[curr + m] = 1",
      "mutated_line": "marked[curr + m] = 2",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 2\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "marked[curr + m] = 1",
      "mutated_line": "marked[curr + m] = 0",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 0\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "marked[curr + m] = 1",
      "mutated_line": "marked[curr + m] = 0",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 0\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "marked[curr + m] = 1",
      "mutated_line": "marked[curr + m] = -1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = -1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n <= ma and marked[curr + n] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n <= ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n >= ma and marked[curr + n] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n >= ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n != ma and marked[curr + n] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n != ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n < ma and marked[curr + n] != 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] != 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "marked[curr + n] = 1",
      "mutated_line": "marked[curr + n] = 2",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 2\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "marked[curr + n] = 1",
      "mutated_line": "marked[curr + n] = 0",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 0\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "marked[curr + n] = 1",
      "mutated_line": "marked[curr + n] = 0",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 0\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "marked[curr + n] = 1",
      "mutated_line": "marked[curr + n] = -1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = -1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr - m < ma and marked[curr + m] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr - m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr * m < ma and marked[curr + m] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr * m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m < ma and marked[curr + m] == 1:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 1:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m < ma and marked[curr + m] == -1:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == -1:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m < ma and marked[curr + m] == 1:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 1:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "marked[curr + m] = 1",
      "mutated_line": "marked[curr - m] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr - m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "marked[curr + m] = 1",
      "mutated_line": "marked[curr * m] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr * m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "q.append(curr + m)",
      "mutated_line": "q.append(curr - m)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr - m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "q.append(curr + m)",
      "mutated_line": "q.append(curr * m)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr * m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr - n < ma and marked[curr + n] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr - n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr * n < ma and marked[curr + n] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr * n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n < ma and marked[curr + n] == 1:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 1:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n < ma and marked[curr + n] == -1:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == -1:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n < ma and marked[curr + n] == 1:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 1:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "marked[curr + n] = 1",
      "mutated_line": "marked[curr - n] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr - n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "marked[curr + n] = 1",
      "mutated_line": "marked[curr * n] = 1",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr * n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "q.append(curr + n)",
      "mutated_line": "q.append(curr - n)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr - n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "q.append(curr + n)",
      "mutated_line": "q.append(curr * n)",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr * n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m < ma and marked[curr - m] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr - m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if curr + m < ma and marked[curr + m] == 0:",
      "mutated_line": "if curr + m < ma and marked[curr * m] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr * m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr + n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n < ma and marked[curr - n] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr - n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if curr + n < ma and marked[curr + n] == 0:",
      "mutated_line": "if curr + n < ma and marked[curr * n] == 0:",
      "code": "import math\nfrom collections import deque\n\ndef count_remaining_candies(m: int, n: int) -> int:\n    ma = m * n // math.gcd(m, n)\n    marked = [0] * ma\n    marked[0] = 1\n    q = deque()\n    q.append(0)\n    while q:\n        curr = q.popleft()\n        if curr + m < ma and marked[curr + m] == 0:\n            marked[curr + m] = 1\n            q.append(curr + m)\n        if curr + n < ma and marked[curr * n] == 0:\n            marked[curr + n] = 1\n            q.append(curr + n)\n    return marked.count(0)"
    }
  ]
}