{
  "task_id": "taco_4777",
  "entry_point": "count_valid_road_pairs",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s += 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s += 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "t -= 1",
      "mutated_line": "t += 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t += 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s -= 2",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 2\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 0\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 0\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s -= -1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= -1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t -= 1",
      "mutated_line": "t -= 2",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 2\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t -= 1",
      "mutated_line": "t -= 0",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 0\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t -= 1",
      "mutated_line": "t -= 0",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 0\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t -= 1",
      "mutated_line": "t -= -1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= -1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "valid_pairs = 0",
      "mutated_line": "valid_pairs = 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "valid_pairs = 0",
      "mutated_line": "valid_pairs = -1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "valid_pairs = 0",
      "mutated_line": "valid_pairs = 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "distances = [-1] * n",
      "mutated_line": "distances = [-1] / n",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] / n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "distances = [-1] * n",
      "mutated_line": "distances = [-1] + n",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] + n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "distances = [-1] * n",
      "mutated_line": "distances = [-1] ** n",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] ** n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 1\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = -1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = -1\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "distances[start] = 0",
      "mutated_line": "distances[start] = 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 1\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v + 1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v + 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v * 1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v * 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u + 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u * 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i - 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i * 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if j not in adj[i]:",
      "mutated_line": "if j in adj[i]:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 2)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 2)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 0)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 0)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 0)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 0)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - -1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - -1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 2)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 0)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 0)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - -1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "distances = [-1] * n",
      "mutated_line": "distances = [+1] * n",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [+1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if distances[neighbor] == -1:",
      "mutated_line": "if distances[neighbor] != -1:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] != -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 2, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 0, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 0, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + -1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st or dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st or dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "valid_pairs += 1",
      "mutated_line": "valid_pairs -= 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs -= 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u + 1].append(v - 1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u + 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u * 1].append(v - 1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u * 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v + 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v * 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances = [-1] * n",
      "mutated_line": "distances = [-2] * n",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-2] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances = [-1] * n",
      "mutated_line": "distances = [-0] * n",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-0] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances = [-1] * n",
      "mutated_line": "distances = [-0] * n",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-0] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "distances = [-1] * n",
      "mutated_line": "distances = [--1] * n",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [--1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if distances[neighbor] == -1:",
      "mutated_line": "if distances[neighbor] == +1:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == +1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "distances[neighbor] = distances[node] + 1",
      "mutated_line": "distances[neighbor] = distances[node] - 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] - 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "distances[neighbor] = distances[node] + 1",
      "mutated_line": "distances[neighbor] = distances[node] * 1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] * 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] > distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] > distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] < distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] < distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] == distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] == distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] > distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] > distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] < distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] < distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] == distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] == distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "valid_pairs += 1",
      "mutated_line": "valid_pairs += 2",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 2\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "valid_pairs += 1",
      "mutated_line": "valid_pairs += 0",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 0\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "valid_pairs += 1",
      "mutated_line": "valid_pairs += 0",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 0\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "valid_pairs += 1",
      "mutated_line": "valid_pairs += -1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += -1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 2].append(v - 1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 2].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 0].append(v - 1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 0].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 0].append(v - 1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 0].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - -1].append(v - 1)",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - -1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 2].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 0].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 0].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - -1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if distances[neighbor] == -1:",
      "mutated_line": "if distances[neighbor] == -2:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -2:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if distances[neighbor] == -1:",
      "mutated_line": "if distances[neighbor] == -0:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -0:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if distances[neighbor] == -1:",
      "mutated_line": "if distances[neighbor] == -0:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -0:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if distances[neighbor] == -1:",
      "mutated_line": "if distances[neighbor] == --1:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == --1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distances[neighbor] = distances[node] + 1",
      "mutated_line": "distances[neighbor] = distances[node] + 2",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 2\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distances[neighbor] = distances[node] + 1",
      "mutated_line": "distances[neighbor] = distances[node] + 0",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 0\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distances[neighbor] = distances[node] + 1",
      "mutated_line": "distances[neighbor] = distances[node] + 0",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 0\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "distances[neighbor] = distances[node] + 1",
      "mutated_line": "distances[neighbor] = distances[node] + -1",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + -1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + 1 - dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 - dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if (dist_from_s[i] + 1) * dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if (dist_from_s[i] + 1) * dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 - dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 - dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and (dist_from_t[i] + 1) * dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and (dist_from_t[i] + 1) * dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] - 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] - 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] * 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] * 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] - 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] - 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] * 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] * 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + 2 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 2 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + 0 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 0 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + 0 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 0 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and \\",
      "mutated_line": "if dist_from_s[i] + -1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + -1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 2 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 2 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 0 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 0 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 0 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + 0 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist_from_t[i] + 1 + dist_from_s[j] >= distance_st:",
      "mutated_line": "if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + -1 + dist_from_s[j] >= distance_st:",
      "code": "def count_valid_road_pairs(n, m, s, t, roads):\n    from collections import deque\n    s -= 1\n    t -= 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in roads:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    def bfs(start):\n        distances = [-1] * n\n        distances[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n        return distances\n    dist_from_s = bfs(s)\n    dist_from_t = bfs(t)\n    distance_st = dist_from_s[t]\n    valid_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in adj[i]:\n                if dist_from_s[i] + 1 + dist_from_t[j] >= distance_st and dist_from_t[i] + -1 + dist_from_s[j] >= distance_st:\n                    valid_pairs += 1\n    return valid_pairs"
    }
  ]
}