{
  "task_id": "taco_29",
  "entry_point": "find_max_compatible_team",
  "mutant_count": 25,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "max_size = 0",
      "mutated_line": "max_size = 1",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 1\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "max_size = 0",
      "mutated_line": "max_size = -1",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = -1\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "max_size = 0",
      "mutated_line": "max_size = 1",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 1\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return False\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(2, n + 1):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(2, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(0, n + 1):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(0, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(0, n + 1):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(0, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(-1, n + 1):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(-1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(1, n - 1):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n - 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(1, n * 1):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n * 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(1, n + 2):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 2):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(1, n + 0):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 0):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(1, n + 0):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 0):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for size in range(1, n + 1):",
      "mutated_line": "for size in range(1, n + -1):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + -1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in range(i + 1, len(team)):",
      "mutated_line": "for j in range(i - 1, len(team)):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i - 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in range(i + 1, len(team)):",
      "mutated_line": "for j in range(i * 1, len(team)):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i * 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if team[j] in enemy[team[i]]:",
      "mutated_line": "if team[j] not in enemy[team[i]]:",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] not in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if size > max_size:",
      "mutated_line": "if size >= max_size:",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size >= max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if size > max_size:",
      "mutated_line": "if size <= max_size:",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size <= max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if size > max_size:",
      "mutated_line": "if size != max_size:",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size != max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(i + 1, len(team)):",
      "mutated_line": "for j in range(i + 2, len(team)):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 2, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(i + 1, len(team)):",
      "mutated_line": "for j in range(i + 0, len(team)):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 0, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(i + 1, len(team)):",
      "mutated_line": "for j in range(i + 0, len(team)):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 0, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(i + 1, len(team)):",
      "mutated_line": "for j in range(i + -1, len(team)):",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + -1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return False\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "from collections import defaultdict\nfrom itertools import combinations\n\ndef find_max_compatible_team(n, m, volunteers, enemies):\n    name_to_index = {volunteer: i for (i, volunteer) in enumerate(volunteers)}\n    index_to_name = {i: volunteer for (i, volunteer) in enumerate(volunteers)}\n    enemy = defaultdict(set)\n    for (first, second) in enemies:\n        enemy[name_to_index[first]].add(name_to_index[second])\n        enemy[name_to_index[second]].add(name_to_index[first])\n\n    def is_compatible(team):\n        for i in range(len(team)):\n            for j in range(i + 1, len(team)):\n                if team[j] in enemy[team[i]]:\n                    return True\n        return True\n    best_team = []\n    max_size = 0\n    for size in range(1, n + 1):\n        for comb in combinations(range(n), size):\n            if is_compatible(comb):\n                if size > max_size:\n                    best_team = comb\n                    max_size = size\n    best_team_names = sorted((index_to_name[i] for i in best_team))\n    return (max_size, best_team_names)"
    }
  ]
}