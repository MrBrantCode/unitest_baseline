{
  "task_id": "taco_1951",
  "entry_point": "is_lucky",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "return re.fullmatch('[47]+', str(num)) is not None",
      "mutated_line": "return re.fullmatch('[47]+', str(num)) is None",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 1\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = -1\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 1\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < len(res):",
      "mutated_line": "while i <= len(res):",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i <= len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < len(res):",
      "mutated_line": "while i >= len(res):",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i >= len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < len(res):",
      "mutated_line": "while i != len(res):",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i != len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i -= 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 2\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 0\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 0\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += -1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "tree_size = [1 for _ in range(n)]",
      "mutated_line": "tree_size = [2 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [2 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "tree_size = [1 for _ in range(n)]",
      "mutated_line": "tree_size = [0 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [0 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "tree_size = [1 for _ in range(n)]",
      "mutated_line": "tree_size = [0 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [0 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "tree_size = [1 for _ in range(n)]",
      "mutated_line": "tree_size = [-1 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [-1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if p is not None:",
      "mutated_line": "if p is None:",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "tree_size[p] += tree_size[u]",
      "mutated_line": "tree_size[p] -= tree_size[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] -= tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp_up = [0 for _ in range(n)]",
      "mutated_line": "dp_up = [1 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [1 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp_up = [0 for _ in range(n)]",
      "mutated_line": "dp_up = [-1 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [-1 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp_up = [0 for _ in range(n)]",
      "mutated_line": "dp_up = [1 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [1 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp_down = [0 for _ in range(n)]",
      "mutated_line": "dp_down = [1 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [1 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp_down = [0 for _ in range(n)]",
      "mutated_line": "dp_down = [-1 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [-1 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dp_down = [0 for _ in range(n)]",
      "mutated_line": "dp_down = [1 for _ in range(n)]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [1 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if p is not None:",
      "mutated_line": "if p is None:",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "dp_up[p] += tree_size[u] if cost else dp_up[u]",
      "mutated_line": "dp_up[p] -= tree_size[u] if cost else dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] -= tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if p is not None:",
      "mutated_line": "if p is None:",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] -= tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] -= tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return re.fullmatch('[47]+', str(num)) is not None",
      "mutated_line": "return re.fullmatch('', str(num)) is not None",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if v != p:",
      "mutated_line": "if v == p:",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v == p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "topo = list(topo_order(0, gr))",
      "mutated_line": "topo = list(topo_order(1, gr))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(1, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "topo = list(topo_order(0, gr))",
      "mutated_line": "topo = list(topo_order(-1, gr))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(-1, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "topo = list(topo_order(0, gr))",
      "mutated_line": "topo = list(topo_order(1, gr))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(1, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) / (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) / (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum((u + v + (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum((u + v + (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) ** (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) ** (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[0] + tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] + tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[0] * tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] * tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] + dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] + dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else (dp_down[p] + dp_up[p]) * dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else (dp_down[p] + dp_up[p]) * dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u - v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u - v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum((u * v * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum((u * v * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) * (u + v + 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v + 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) * ((u + v) * 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * ((u + v) * 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] - dp_up[p] - dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] - dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] * dp_up[p] - dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] * dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) * (u - v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u - v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) * (u * v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u * v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) * (u + v - 2) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 2) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) * (u + v - 0) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 0) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) * (u + v - 0) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 0) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))",
      "mutated_line": "ans = sum(((u + v) * (u + v - -1) for (u, v) in zip(dp_up, dp_down)))",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - -1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[1] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[1] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[-1] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[-1] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dp_down[u] += tree_size[0] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "mutated_line": "dp_down[u] += tree_size[1] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]",
      "code": "import re\n\ndef is_lucky(num):\n    return re.fullmatch('[47]+', str(num)) is not None\n\ndef topo_order(u, gr):\n    res = [(u, None, None)]\n    i = 0\n    while i < len(res):\n        (u, p, _) = res[i]\n        i += 1\n        for (v, c) in gr[u]:\n            if v != p:\n                res.append((v, u, c))\n    return reversed(res)\n\ndef count_lucky_triples(n, edges):\n    gr = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        c = is_lucky(w)\n        gr[u].append((v, c))\n        gr[v].append((u, c))\n    topo = list(topo_order(0, gr))\n    tree_size = [1 for _ in range(n)]\n    for (u, p, _) in topo:\n        if p is not None:\n            tree_size[p] += tree_size[u]\n    dp_up = [0 for _ in range(n)]\n    dp_down = [0 for _ in range(n)]\n    for (u, p, cost) in topo:\n        if p is not None:\n            dp_up[p] += tree_size[u] if cost else dp_up[u]\n    for (u, p, cost) in reversed(topo):\n        if p is not None:\n            dp_down[u] += tree_size[1] - tree_size[u] if cost else dp_down[p] + dp_up[p] - dp_up[u]\n    ans = sum(((u + v) * (u + v - 1) for (u, v) in zip(dp_up, dp_down)))\n    return ans"
    }
  ]
}