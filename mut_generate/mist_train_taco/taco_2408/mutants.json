{
  "task_id": "taco_2408",
  "entry_point": "find_correct_number",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base3_range = 2 * len(base3_str)",
      "mutated_line": "base3_range = 2 / len(base3_str)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 / len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base3_range = 2 * len(base3_str)",
      "mutated_line": "base3_range = 2 + len(base3_str)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 + len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "base3_range = 2 * len(base3_str)",
      "mutated_line": "base3_range = 2 ** len(base3_str)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 ** len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "bit_remainder = iteration % 2",
      "mutated_line": "bit_remainder = iteration * 2",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration * 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "bit_remainder = iteration % 2",
      "mutated_line": "bit_remainder = iteration + 2",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration + 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if bit_remainder == 0:",
      "mutated_line": "if bit_remainder != 0:",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder != 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "base2 = int(base2_str, 2)",
      "mutated_line": "base2 = int(base2_str, 3)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 3)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "base2 = int(base2_str, 2)",
      "mutated_line": "base2 = int(base2_str, 1)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 1)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "base2 = int(base2_str, 2)",
      "mutated_line": "base2 = int(base2_str, 0)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 0)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "base2 = int(base2_str, 2)",
      "mutated_line": "base2 = int(base2_str, 1)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 1)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "base2 = int(base2_str, 2)",
      "mutated_line": "base2 = int(base2_str, -2)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, -2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base3_range = 2 * len(base3_str)",
      "mutated_line": "base3_range = 3 * len(base3_str)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 3 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base3_range = 2 * len(base3_str)",
      "mutated_line": "base3_range = 1 * len(base3_str)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 1 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base3_range = 2 * len(base3_str)",
      "mutated_line": "base3_range = 0 * len(base3_str)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 0 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base3_range = 2 * len(base3_str)",
      "mutated_line": "base3_range = 1 * len(base3_str)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 1 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "base3_range = 2 * len(base3_str)",
      "mutated_line": "base3_range = -2 * len(base3_str)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = -2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mod_base2 = base2 ^ (1 << i)",
      "mutated_line": "mod_base2 = base2 | 1 << i",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 | 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return --1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "bit_loc = int(iteration / 2)",
      "mutated_line": "bit_loc = int(iteration * 2)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration * 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "bit_loc = int(iteration / 2)",
      "mutated_line": "bit_loc = int(iteration // 2)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration // 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit_remainder = iteration % 2",
      "mutated_line": "bit_remainder = iteration % 3",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 3\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit_remainder = iteration % 2",
      "mutated_line": "bit_remainder = iteration % 1",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 1\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit_remainder = iteration % 2",
      "mutated_line": "bit_remainder = iteration % 0",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 0\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit_remainder = iteration % 2",
      "mutated_line": "bit_remainder = iteration % 1",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 1\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "bit_remainder = iteration % 2",
      "mutated_line": "bit_remainder = iteration % -2",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % -2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if bit_remainder == 0:",
      "mutated_line": "if bit_remainder == 1:",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 1:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if bit_remainder == 0:",
      "mutated_line": "if bit_remainder == -1:",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == -1:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if bit_remainder == 0:",
      "mutated_line": "if bit_remainder == 1:",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 1:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if local_base3[bit_loc] == '2':",
      "mutated_line": "if local_base3[bit_loc] != '2':",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] != '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if local_base3[bit_loc] == '2':",
      "mutated_line": "local_base3[bit_loc] = '1'",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] != '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(local_base3), 3)",
      "mutated_line": "return int(''.join(local_base3), 4)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 4)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(local_base3), 3)",
      "mutated_line": "return int(''.join(local_base3), 2)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 2)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(local_base3), 3)",
      "mutated_line": "return int(''.join(local_base3), 0)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 0)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(local_base3), 3)",
      "mutated_line": "return int(''.join(local_base3), 1)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 1)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(local_base3), 3)",
      "mutated_line": "return int(''.join(local_base3), -3)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), -3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if mod_base2 == mod_base3:",
      "mutated_line": "if mod_base2 != mod_base3:",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 != mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bit_loc = int(iteration / 2)",
      "mutated_line": "bit_loc = int(iteration / 3)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 3)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bit_loc = int(iteration / 2)",
      "mutated_line": "bit_loc = int(iteration / 1)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 1)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bit_loc = int(iteration / 2)",
      "mutated_line": "bit_loc = int(iteration / 0)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 0)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bit_loc = int(iteration / 2)",
      "mutated_line": "bit_loc = int(iteration / 1)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 1)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bit_loc = int(iteration / 2)",
      "mutated_line": "bit_loc = int(iteration / -2)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / -2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if local_base3[bit_loc] == '2':",
      "mutated_line": "if local_base3[bit_loc] == '':",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "local_base3[bit_loc] = '1'",
      "mutated_line": "local_base3[bit_loc] = ''",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = ''\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif local_base3[bit_loc] == '1':",
      "mutated_line": "elif local_base3[bit_loc] != '1':",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] != '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if local_base3[bit_loc] == '2':",
      "mutated_line": "local_base3[bit_loc] = '1'",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "local_base3[bit_loc] = '0'",
      "mutated_line": "local_base3[bit_loc] = '1'",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = ''\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif local_base3[bit_loc] == '1':",
      "mutated_line": "local_base3[bit_loc] = '1'",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] != '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod_base2 = base2 ^ (1 << i)",
      "mutated_line": "mod_base2 = base2 ^ 2 << i",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 2 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod_base2 = base2 ^ (1 << i)",
      "mutated_line": "mod_base2 = base2 ^ 0 << i",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 0 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod_base2 = base2 ^ (1 << i)",
      "mutated_line": "mod_base2 = base2 ^ 0 << i",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 0 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mod_base2 = base2 ^ (1 << i)",
      "mutated_line": "mod_base2 = base2 ^ -1 << i",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ -1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "elif local_base3[bit_loc] == '1':",
      "mutated_line": "elif local_base3[bit_loc] == '':",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "local_base3[bit_loc] = '0'",
      "mutated_line": "local_base3[bit_loc] = ''",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = ''\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "local_base3[bit_loc] = '2'",
      "mutated_line": "local_base3[bit_loc] = ''",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = ''\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif local_base3[bit_loc] == '1':",
      "mutated_line": "local_base3[bit_loc] = '1'",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "local_base3[bit_loc] = '2'",
      "mutated_line": "local_base3[bit_loc] = '1'",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = ''\n        else:\n            local_base3[bit_loc] = '1'\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "local_base3[bit_loc] = '1'",
      "mutated_line": "local_base3[bit_loc] = ''",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = ''\n        return int(''.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(local_base3), 3)",
      "mutated_line": "return int('MUTATED'.join(local_base3), 3)",
      "code": "def find_correct_number(base2_str: str, base3_str: str) -> int:\n\n    def base3_modifier(base3_list: list, iteration: int) -> int:\n        local_base3 = list(base3_list)\n        bit_loc = int(iteration / 2)\n        bit_remainder = iteration % 2\n        if bit_remainder == 0:\n            if local_base3[bit_loc] == '2':\n                local_base3[bit_loc] = '1'\n            elif local_base3[bit_loc] == '1':\n                local_base3[bit_loc] = '0'\n            else:\n                local_base3[bit_loc] = '2'\n        elif local_base3[bit_loc] == '2':\n            local_base3[bit_loc] = '0'\n        elif local_base3[bit_loc] == '1':\n            local_base3[bit_loc] = '2'\n        else:\n            local_base3[bit_loc] = '1'\n        return int('MUTATED'.join(local_base3), 3)\n    base2 = int(base2_str, 2)\n    base2_range = len(base2_str)\n    base3_range = 2 * len(base3_str)\n    for i in range(base2_range):\n        mod_base2 = base2 ^ 1 << i\n        for j in range(base3_range):\n            mod_base3 = base3_modifier(base3_str, j)\n            if mod_base2 == mod_base3:\n                return mod_base2\n    return -1"
    }
  ]
}