{
  "task_id": "taco_2801",
  "entry_point": "count_restoration_ways",
  "mutant_count": 225,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 - 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 * 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 20",
      "mutated_line": "M = 21",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 21\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 20",
      "mutated_line": "M = 19",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 19\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 20",
      "mutated_line": "M = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 0\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 20",
      "mutated_line": "M = 1",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 1\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "M = 20",
      "mutated_line": "M = -20",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = -20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = 26",
      "mutated_line": "L = 27",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 27\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = 26",
      "mutated_line": "L = 25",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 25\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = 26",
      "mutated_line": "L = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 0\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = 26",
      "mutated_line": "L = 1",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 1\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = 26",
      "mutated_line": "L = -26",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = -26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 * 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 + 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 8\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 6\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 0\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 1\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + -7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ca = ord('a')",
      "mutated_line": "ca = ord('')",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cq = ord('?')",
      "mutated_line": "cq = ord('')",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca - 1] / M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] / M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca - 1] + M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] + M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca - 1] ** M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] ** M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n - 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n * 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n - 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n * 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if memo[l][r][p][c] != -1:",
      "mutated_line": "if memo[l][r][p][c] == -1:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] == -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res -= dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res -= dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "memo[l][r][p][c] = res = res % MOD",
      "mutated_line": "memo[l][r][p][c] = res = res * MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res * MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "memo[l][r][p][c] = res = res % MOD",
      "mutated_line": "memo[l][r][p][c] = res = res + MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res + MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(1, n, 0, 0)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(1, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(-1, n, 0, 0)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(-1, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(1, n, 0, 0)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(1, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(0, n, 1, 0)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(0, n, -1, 0)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(0, n, 1, 0)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(0, n, 0, 1)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(0, n, 0, -1)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return dfs(0, n, 0, 0)",
      "mutated_line": "return dfs(0, n, 0, 1)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 11 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 9 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 0 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 1 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = -10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 10 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 8 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 0 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 1 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** -9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 2):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 0):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 0):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + -1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M - 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M - 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M * 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M * 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 2):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 0):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 0):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + -1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i - 1, n + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i - 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i * 1, n + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i * 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n - 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n - 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n * 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n * 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "if memo[l][r][p][c] != -1:",
      "mutated_line": "if memo[l][r][p][c] != +1:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != +1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res = dfs(l, r, p, c + 1)",
      "mutated_line": "res = dfs(l, r, p, c - 1)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c - 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res = dfs(l, r, p, c + 1)",
      "mutated_line": "res = dfs(l, r, p, c * 1)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c * 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l - 1, r + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l - 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l * 1, r + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l * 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 1, r - 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r - 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 1, r * 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r * 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) * MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) * MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) + MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) + MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca + 1] * M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca + 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca * 1] * M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca * 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] / (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] / (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] + (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] + (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] ** (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] ** (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n - 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n - 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n * 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n * 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M + 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 2):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 0):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 0):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M + -1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + -1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L - 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L - 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L * 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L * 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "memo[i][i][p][c] = 1",
      "mutated_line": "memo[i][i][p][c] = 2",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 2\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "memo[i][i][p][c] = 1",
      "mutated_line": "memo[i][i][p][c] = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 0\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "memo[i][i][p][c] = 1",
      "mutated_line": "memo[i][i][p][c] = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 0\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "memo[i][i][p][c] = 1",
      "mutated_line": "memo[i][i][p][c] = -1",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = -1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 2, n + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 2, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 0, n + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 0, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 0, n + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 0, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + -1, n + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + -1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n + 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 2):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 0):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 0):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for j in range(i + 1, n + 1):",
      "mutated_line": "for j in range(i + 1, n + -1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + -1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M - 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M - 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M * 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M * 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L + 1] = 1",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 1\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L + 1] = -1",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = -1\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L + 1] = 1",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 1\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L - 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L - 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L * 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L * 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "memo[i][j][M][c] = i + 1 == j",
      "mutated_line": "memo[i][j][M][c] = i + 1 != j",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 != j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if memo[l][r][p][c] != -1:",
      "mutated_line": "if memo[l][r][p][c] != -2:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -2:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if memo[l][r][p][c] != -1:",
      "mutated_line": "if memo[l][r][p][c] != -0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -0:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if memo[l][r][p][c] != -1:",
      "mutated_line": "if memo[l][r][p][c] != -0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -0:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if memo[l][r][p][c] != -1:",
      "mutated_line": "if memo[l][r][p][c] != --1:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != --1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = dfs(l, r, p, c + 1)",
      "mutated_line": "res = dfs(l, r, p, c + 2)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 2)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = dfs(l, r, p, c + 1)",
      "mutated_line": "res = dfs(l, r, p, c + 0)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 0)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = dfs(l, r, p, c + 1)",
      "mutated_line": "res = dfs(l, r, p, c + 0)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 0)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res = dfs(l, r, p, c + 1)",
      "mutated_line": "res = dfs(l, r, p, c + -1)",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + -1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 2, r + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 2, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 0, r + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 0, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 0, r + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 0, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + -1, r + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + -1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 1, r + 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 2):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 1, r + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 0):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 1, r + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 0):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for i in range(l + 1, r + 1):",
      "mutated_line": "for i in range(l + 1, r + -1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + -1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] == cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] == cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] == ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] == ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c != 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c != 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) / dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) / dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += (dfs(l, i, p + 1, 0) + dfs(i, r, p, c + 1)) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += (dfs(l, i, p + 1, 0) + dfs(i, r, p, c + 1)) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) ** dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) ** dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca - 2] * M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 2] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca - 0] * M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 0] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca - 0] * M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 0] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "S = [[ca - 1] * M for _ in range(n)]",
      "mutated_line": "S = [[ca - -1] * M for _ in range(n)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - -1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L - 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L - 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L * 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L * 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n - 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n - 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n * 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n * 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 2)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 2)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 0)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 0)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 0)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 0)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + -1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + -1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + 3):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 3):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 1):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 0):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 1):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + -2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + -2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M + 2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 2):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 0):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 0):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for p in range(M + 1):",
      "mutated_line": "for p in range(M + -1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + -1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L - 1] = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L - 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L * 1] = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L * 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + 3):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 3):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 1):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + 0):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 0):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + 1):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 1):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for c in range(L + 2):",
      "mutated_line": "for c in range(L + -2):",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + -2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "memo[i][j][M][c] = i + 1 == j",
      "mutated_line": "memo[i][j][M][c] = i - 1 == j",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i - 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "memo[i][j][M][c] = i + 1 == j",
      "mutated_line": "memo[i][j][M][c] = i * 1 == j",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i * 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c + 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c + 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != (ca + c) * 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != (ca + c) * 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 1:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 1:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == -1:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == -1:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 1:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 1:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[+1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[+1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 3) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 3) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 1) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 1) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 0) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 0) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 1) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 1) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + -2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + -2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M - 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M - 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M * 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M * 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 2)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 2)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 0)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 0)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 0)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 0)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + -1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + -1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L + 2] = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 2] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L + 0] = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 0] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L + 0] = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 0] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "memo[i][j][p][L + 1] = 0",
      "mutated_line": "memo[i][j][p][L + -1] = 0",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + -1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "memo[i][j][M][c] = i + 1 == j",
      "mutated_line": "memo[i][j][M][c] = i + 2 == j",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 2 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "memo[i][j][M][c] = i + 1 == j",
      "mutated_line": "memo[i][j][M][c] = i + 0 == j",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 0 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "memo[i][j][M][c] = i + 1 == j",
      "mutated_line": "memo[i][j][M][c] = i + 0 == j",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 0 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "memo[i][j][M][c] = i + 1 == j",
      "mutated_line": "memo[i][j][M][c] = i + -1 == j",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + -1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca - c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca - c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca * c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca * c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 2 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 2 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 0 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 0 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 0 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 0 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - -1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - -1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p - 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p - 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p * 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p * 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 1) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 1) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, -1) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, -1) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 1) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 1) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c - 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c - 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c * 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c * 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-2] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-2] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-0] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-0] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-0] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-0] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[--1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[--1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 2)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 2)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 0)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 0)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 0)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 0)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "mutated_line": "memo = [[[[-1] * (L + 2) for _ in range(M + -1)] for _ in range(n + 1)] for _ in range(n + 1)]",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + -1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i + 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i + 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i * 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i * 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i + 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i + 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i * 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i * 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 2, 0) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 2, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 0, 0) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 0, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 0, 0) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 0, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + -1, 0) * dfs(i, r, p, c + 1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + -1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 2) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 2) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 0) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 0) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 0) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 0) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD",
      "mutated_line": "res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + -1) % MOD",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + -1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - 2][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 2][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - 0][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 0][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - 0][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - 0][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 1][p] != ca + c - 1 if S[i - -1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 1][p] != ca + c - 1 if S[i - -1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 2][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 2][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 0][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 0][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - 0][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - 0][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if S[i - 1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "mutated_line": "if S[i - -1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:",
      "code": "def count_restoration_ways(n, words):\n    MOD = 10 ** 9 + 7\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca - 1] * M for _ in range(n)]\n    for i in range(n):\n        s = words[i]\n        S[i][:len(s)] = map(ord, s)\n    memo = [[[[-1] * (L + 2) for _ in range(M + 1)] for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for p in range(M + 1):\n            for c in range(L + 2):\n                memo[i][i][p][c] = 1\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            for p in range(M + 1):\n                memo[i][j][p][L + 1] = 0\n            for c in range(L + 2):\n                memo[i][j][M][c] = i + 1 == j\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c + 1)\n        for i in range(l + 1, r + 1):\n            if S[i - -1][p] != ca + c - 1 if S[i - 1][p] != cq else c == 0:\n                break\n            res += dfs(l, i, p + 1, 0) * dfs(i, r, p, c + 1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    return dfs(0, n, 0, 0)"
    }
  ]
}